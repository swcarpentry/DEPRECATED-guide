{% extends "templates/_base.html" %}

{% block file_metadata %}
  <meta name="title" content="Basic Programming With Python" />
  <meta name="status" content="Ready for comment" />
{% endblock file_metadata %}

{% block content %}
<ol class="toc">
  <li><a href="#s:basic">Basic Operations</a></li>
  <li><a href="#s:program">Creating Programs</a></li>
  <li><a href="#s:types">Types</a></li>
  <li><a href="#s:io">Reading Files</a></li>
  <li><a href="#s:stdio">Standard Input and Output</a></li>
  <li><a href="#s:for">Repeating Things</a></li>
  <li><a href="#s:logic">Making Choices</a></li>
  <li><a href="#s:flag">Flags</a></li>
  <li><a href="#s:parse">Reading Data Files</a></li>
  <li><a href="#s:lists">Lists</a></li>
  <li><a href="#s:nesting">Nesting</a></li>
  <li><a href="#s:func">Functions</a></li>
  <li><a href="#s:scope">Scope</a></li>
  <li><a href="#s:return">Returning Values</a></li>
  <li><a href="#s:alias">Aliasing</a></li>
  <li><a href="#s:libraries">Libraries</a></li>
  <li><a href="#s:filter">Building Filters</a></li>
  <li><a href="#s:summary">Summing Up</a></li>
</ol>

<p>
  A cochlear implant is a small device placed in the inner ear
  to give the hearing impaired a sense of sound.
  To test how effective they are,
  Aurora Audio wants to measure three things:
  the range of tones that people can hear,
  how well they can discriminate between similar tones.
  and the softest volume they can notice.
  Each test is supposed to be scored from 0 to 5,
  but after her collaborators submitted their data,
  she found that some had scored from -5 to 5 instead.
  She needs to clean up the data before using it.
</p>

<p>
  If Aurora had only one data set,
  the fastest solution might be to use a spreadsheet.
  However,
  she actually has over a hundred data sets,
  with more coming in each week.
  Since she doesn't want to spend hours doing the same things over and over again,
  she wants to write a small program to clean up her data for her.
  To do that,
  she's going to have to learn how to program,
  and that's what the next couple of chapters are about.
</p>

<p>
  We will use a programming language called Python for our examples.
  Python is free,
  reasonably well documented,
  and widely used in science and engineering.
  Our main reason for choosing it,
  though,
  is that newcomers find it easier to read than most other languages.
  It also allows people to do useful things
  without having to master advanced concepts like object-oriented programming.
</p>

<div class="guide">
  <h2>For Instructors</h2>

  <p>
    This lesson is written as an introduction to Python,
    but its real purpose is to introduce
    the single most important idea in programming:
    how to solve problems by building functions,
    each of which can fit in a programmer's working memory.
    In order to teach that,
    we must teach people a little about the mechanics of manipulating data
    with lists and file I/O
    so that their functions can do things they actually care about.
    Our teaching order tries to show practical uses of every idea
    as soon as it is introduced;
    instructors should resist the temptation
    to explain the "other 90%" of the language as they go along.
  </p>

  <p>
    The secondary goal of this lesson is
    to give them a usable mental model of how programs run&mdash;what
    computer science educators call a <a href="glossary.html#notional-machine">notional machine</a>&mdash;so
    that they can debug things when they go wrong.
    In particular,
    they must understand what types, references, and aliasing are,
    and how function call stacks work.
    Again,
    how programs behave only makes sense on top of these ideas,
    but they are easier to absorb when framed by examples.
  </p>

  <p>
    Finally,
    the capstone example in this chapter is
    building something that fits into
    the Unix pipe-and-filter model.
    We do this both because it is a well-motivated medium-sized example,
    and because it helps learners see that
    the software they use isn't magical.
    Tools like <code>grep</code> might be more sophisticated
    than the programs our learners can write
    at this point in their careers,
    but it's crucial they realize
    this is a difference of scale rather than kind.
  </p>

  <p>
    The greatest challenges in teaching this material are
    the diversity of learners' prior knowledge
    and a shortage of time.
    People who have programmed before can absorb this lesson
    several times faster than people who haven't,
    but even they find it hard to get through this
    in less than four or five hours
    if hands-on work is included.
    When time runs short (and it will),
    the topics to cut are:
  </p>

  <ul>
    <li><a href="#s:flag">Flags</a></li>
    <li><a href="#s:parse">Reading Data Files</a></li>
    <li><a href="#s:nesting">Nesting</a></li>
    <li><a href="#s:alias">Aliasing</a></li>
    <li><a href="#s:filter">Building Filters</a></li>
  </ul>

  <p>
    If these five sections are taken out,
    this material can reliably be covered in <span class="duration">four hours</span>.
    If the audience is more advanced,
    or if extra time is available,
    then the material on
    <a href="extras.html#s:python:funcobj">functions as objects</a>
    and <a href="extras.html#s:python:provenance">provenance</a>
    should be used.
    The first is always an "ah ha!" moment for people who get it:
    they can immediately see how storing functions in lists
    and passing them to other functions
    can eliminate redundancy in their code,
    and it shows them how the numerical and image processing libraries they use
    actually work.
    However,
    only about half of learners
    (even in advanced classes)
    have that "ah ha!"
    The second,
    which extends
    <a href="svn.html#s:provenance">the provenance example in the Subversion lesson</a>,
    connects this lesson to earlier material
    in the same way as the <a href="#s:filter">filter example</a>.
  </p>

  <p>
    The biggest idea this lesson <em>doesn't</em> cover is
    the difference between interface and implementation.
    It's crucial to writing maintainable code,
    and to testing,
    but our experience is that it only makes sense
    in the context of a larger example.
    For that reason,
    we defer it to the discussion of <a href="dev.html">Program Development</a>.
  </p>

  <div class="prereq">
    <h3>Prerequisites</h3>
    <p>
      The discussion of <a href="#s:stdio">standard I/O</a>
      and <a href="#s:filter">building filters</a>
      depends on concepts introducing during
      discussion of <a href="shell.html">the shell</a>.
      The rest of this lesson is designed to stand on its own.
    </p>
  </div>

  <div class="notes">
    <h3>Teaching Notes</h3>
    <ul>
      <li>
        Examples in this lesson show use of a command-line interpreter (CLI),
        but work equally well with the IPython Notebook.
        We strongly recommend that you use IPython:
        its <code>%history</code> and <code>%run</code> commands
        make live a lot simpler for everyone.
        Make sure learners can edit text files
        and save them in the right directories
        at the start of the lesson.
        (And if you have Windows users in your class,
        make sure their files can be run by whatever version of Python they have&mdash;we
        have occasionally had line-ending issues.)
      </li>
      <li>
        Watching the instructor grow programs step by step
        is as helpful to learners
        as anything to do with Python.
        In particular,
        the <a href="#s:parse">file-parsing example</a> works best if
        the instructor writes the first version as a single block of code,
        and then extracts functions from it
        as new features are added:
        it's the best way to show learners
        when and why something ought to be put in a function of its own.
        After the instructor has done this a couple of times,
        it's natural for her to say,
        "We know we're going to put this in its own function eventually,
        so why don't we just go ahead and do that right from the start?"
      </li>
      <li>
        This lesson cheats a bit
        by introducing some non-core concepts in challenges.
        These may take longer to work through
        than challenges in other lessons,
        so instructors should check them against learners' abilities
        before diving in.
        They should also expect to give more hints and partial solutions along the way.
      </li>
      <li>
        Python uses tuples in many places,
        but we don't introduce them until we discuss
        <a href="setdict.html#a:tuple">sets and dictionaries</a>,
        mostly because learners find the existence of two list-like structures confusing.
        We therefore try to avoid explaining them except in passing.
      </li>
    </ul>
  </div>
</div>

<section id="s:basic">
  <h2>Basic Operations</h2>

  <div class="understand">
    <h3>Learning Objectives</h3>
    <ul>
      <li>Run the Python interpreter interactively.</li>
      <li>Correctly enter basic arithmetic expressions.</li>
      <li>Explain what variables are and what they are used for.</li>
      <li>Assign numbers and strings to variables.</li>
      <li>Explain what happens when one variable is assigned to another.</li>
      <li>Trace the effect of several consecutive assignment statements.</li>
    </ul>
    <p>
      <span class="duration">15 minutes</span>.
    </p>
  </div>

  <p>
    The best way to learn how to program is to start programming,
    so let's run the Python interpreter
    and type in the following:
  </p>

<pre>
&gt;&gt;&gt; <span class="in">print 1 + 1</span>
<span class="out">2</span>
</pre>

  <p class="continue">
    The <code>&gt;&gt;&gt;</code> <a href="glossary.html#prompt">prompt</a>
    is the interpreter's way of telling us that it's waiting for input,
    like the <code>$</code> prompt in <a href="shell.html">the shell</a>.
    When we enter 1+1,
    Python does the calculation we've asked for
    and prints the result.
  </p>

  <p>
    Now type this:
  </p>

<pre>
&gt;&gt;&gt; <span class="in">x = 1+1</span>
</pre>

  <p class="continue">
    Python doesn't display anything this time
    (except another prompt).
    Instead,
    as <a href="#f:first_variable">Figure 1</a> shows,
    it creates a <a href="glossary.html#variable">variable</a> called <code>x</code>
    and assigns it the value 2.
    We can then get that variable's value simply by entering its name:
  </p>

<pre>
print x
<span class="out">2</span>
</pre>

  <p class="continue">
    (Here and elsewhere,
    we will leave out the Python prompts and just show the code.
    When we do this,
    we will use a horizontal line to separate
    the program from its output.)
  </p>

  <figure id="f:first_variable">
    <img src="python/first_variable.png" alt="Our First Variable" />
    <figcaption>Figure 1: Our First Variable</figcaption>
  </figure>

  <div class="box">
    <h3>Some Things That Don't Work</h3>

    <p>
      Python is a fairly relaxed language,
      but there are still some things it won't let us do.
      For example,
      this doesn't work:
    </p>

<pre>
print x = 1 + 2
<span class="err">SyntaxError: invalid syntax</span>
</pre>

    <p class="continue">
      The problem is that printing and assignment are both
      <a href="glossary.html#statement">statements</a>,
      and statements cannot be mixed together.
      1+2, on the other hand,
      is an <a href="glossary.html#expression">expression</a>&mdash;something
      that produces a new value&mdash;and expressions can be combined in many ways.
      Except for assignment,
      every statement in Python begins with a keyword like <code>print</code>,
      so it's usually easy to tell them apart.
    </p>

    <p>
      Something else that may not work as shown is printing.
      In Python 2,
      <code>print</code> is a statement written on a line of its own.
      In Python 3,
      <code>print</code> is a function,
      and must be written like this:
    </p>

<pre>
print(1+2, 'is', 3)
</pre>

    <p class="continue">
      We use the Python 2 syntax in these lessons.
    </p>

  </div>

  <p>
    We can now use that variable's value in calculations:
  </p>

<pre>
print x * 2
<span class="out">4</span>
</pre>

  <p class="continue">
    including ones that create more variables:
  </p>

<pre>
y = x * 2
print y
<span class="out">4</span>
</pre>

  <p class="continue">
    We can change a variable's value
    by assigning something new to it:
  </p>

<pre>
x = 10
print x
<span class="out">10</span>
</pre>

  <p class="continue">
    As <a href="#f:assign_new_value">Figure 2</a> shows,
    assigning something to <code>x</code> changes what it points to,
    but does not change anything else.
    In particular,
    <code>y</code> still has the value 4 after this assignment:
    it is not automatically updated when <code>x</code>'s value changes,
    as it would in a spreadsheet.
  </p>

  <figure id="f:assign_new_value">
    <img src="python/assign_new_value.png" alt="Assigning a New Value" />
    <figcaption>Figure 2: Assigning a New Value</figcaption>
  </figure>

  <p>
    Here's a more complex calculation:
  </p>

<pre>
x = 98.6
y = (x - 32.0) * (5.0 / 9.0) + 273.15
print y
<span class="out">310.15</span>
</pre>

  <p class="continue">
    Its meaning becomes clearer if we rewrite it as:
  </p>

<pre>
temp_fahr = 98.6
temp_kelvin = (temp_fahr - 32.0) * (5.0 / 9.0) + 273.15
print "body temperature in Kelvin:", temp_kelvin
<span class="out">body temperature in Kelvin: 310.15</span>
</pre>

  <p>
    The first line creates a new variable called <code>temp_fahr</code>
    (short for "temperature in Fahrenheit")
    and gives it the value 98.6
    (<a href="#f:first_memory_model">Figure 3</a>).
    The second line creates another variable to hold the temperature in Kelvin
    (hence its name).
    It calculates a value for this variable
    that depends on the value of <code>temp_fahr</code>.
    The last line prints the result.
    The <a href="glossary.html#string">character string</a>
    (or just "string" for short)
    inside double quotes is printed as-is,
    followed by the value of <code>temp_kelvin</code>.
  </p>

  <figure id="f:first_memory_model">
    <img src="python/first_memory_model.png" alt="First Memory Model" />
    <figcaption>Figure 3: First Memory Model</figcaption>
  </figure>

  <p>
    Every <a href="glossary.html#program">program</a> is just
    a series of statements like the ones shown above
    (for some possibly large value of "just").
    Like all programs,
    this one stores data and does calculations.
    We use variables to do the first,
    and write instructions that use those variables to do the second.
    And like every <em>good</em> program,
    this one is written with human beings in mind.
    Computers get faster every year,
    but our brains don't.
    As a result,
    the real bottleneck in scientific computing is usually not
    how fast the program runs,
    but how long it takes us to write it.
    This is why we use variable names like <code>temp_fahr</code> and <code>temp_kelvin</code>
    instead of <code>x</code> and <code>y</code>.
  </p>

  <div class="box">
    <h3>Creating Variables</h3>

    <p>
      Python creates a variable whenever a value is assigned to a name,
      but won't let us get the value of a variable that hasn't been assigned one.
      For example,
      if we try to do this:
    </p>

<pre>
double_temp = temp_celsius * 2
</pre>

    <p class="continue">
      then Python prints an error message:
    </p>

<pre>
<span class="err">Traceback (most recent call last):
  File "&lt;undefined-variable.py&gt;", line 1, in &lt;module&gt;
NameError: name 'temp_celsius' is not defined</span>
</pre>

    <p class="continue">
      We'll explain what "module" means <a href="funclib.html">later</a>.
      What's important now is that this strictness helps catch a lot of typing mistakes:
      if we mistakenly type <code>temp_far</code> instead of <code>temp_fahr</code>:
    </p>

<pre>
temp_kelvin = (<span class="highlight">temp_far</span> - 32.0) * (5.0 / 9.0) + 273.15
</pre>

    <p class="continue">
      then Python will tell us something's gone wrong.
      It can't help us if we type 3.20 instead of 32.0, though;
      if we want to catch that mistake,
      we'll actually have to <a href="quality.html">test our program</a>.
    </p>
  </div>

  <p>
    Readability is also why we put the temperature in Fahrenheit in a variable,
    then use that variable in line 2,
    rather than just putting 98.6 directly in the calculation.
    If we ever want to convert another temperature,
    it's easier to see and change the value on line 1
    than it would be to find it buried in the middle of a line of arithmetic.
  </p>

  <p>
    Finally,
    this first program also shows how arithmetic is done.
    '+' means addition,
    '*' means multiplication,
    and parentheses group things together,
    just as they do in pen-and-paper arithmetic.
    We have to use parentheses here because
    (also as in arithmetic)
    multiplication takes precedence over addition:
    the expression <code>2*3+5</code> means,
    "Multiply two by three, then add five,"
    rather than,
    "Add three and five, then multiple by two."
    If we want the latter,
    we have to write <code>2*(3+5)</code>.
  </p>

  <div class="box">
    <h3>Repeating Commands</h3>

    <p>
      Just as we could repeat previous commands in the shell
      by using the <a href="shell.html#a:repeat">up arrow</a>,
      so too can we repeat commands in the Python interpreter.
      And while the standard interpreter doesn't have an equivalent
      of the shell's <code>history</code> command,
      more advanced shells like IPython do
      (along with much more).
    </p>
  </div>

  <div class="keypoints">
    <h3>Summary</h3>
    <ul>
      <li>Use '=' to assign a value to a variable.</li>
      <li>Assigning to one variable does not change the values associated with other variables.</li>
      <li>Use <code>print</code> to display values.</li>
      <li>Variables are created when values are assigned to them.</li>
      <li>Variables cannot be used until they have been created.</li>
      <li>Addition ('+'), subtraction ('-'), and multiplication ('*') work as usual in Python.</li>
      <li>Use meaningful, descriptive names for variables.</li>
    </ul>
  </div>

  <div class="challenges">
    <h3>Challenges</h3>

    <ol>

      <li>
        What is the output of:
<pre>
inner = 13.0
outer = 2 * inner
inner = 2 * inner
print outer
</pre>
      </li>

      <li>
        Fill in the blank so that these lines of code produce the output shown.
<pre>
female = 'GGT'
male = 'CAC'
________
print female
<span class="out">GGTGGTCAC</span>
</pre>
      </li>

      <li>
        What single change can be made to the first three lines below to get the output shown?
<pre>
scaling = 10
original = 7
adjusted = primary / scaling
print original + adjusted
<span class="out">7.7</span>
</pre>
      </li>
    </ol>
  </div>
 
</section>

<section id="s:program">
  <h2>Creating Programs</h2>

  <div class="understand">
    <h3>Learning Objectives</h3>
    <ul>
      <li>Store Python commands in a file.</li>
      <li>Use the interpreter to run a file containing Python commands.</li>
    </ul>
    <p>
      <span class="duration">15 minutes</span>.
    </p>
  </div>

  <p>
    Typing in commands over and over again is tedious and error-prone.
    Just as we saved shell commands in <a href="shell.html#s:scripts">shell scripts</a>,
    we can save Python commands in files
    and then have the Python interpreter run those.
    Using your favorite text editor,
    put the following three lines into a plain text file:
  </p>

<pre>
left = "hello"
right = "there"
print left, right
</pre>

  <p class="continue">
    and then save it as <code>greeting.py</code>.
    (By convention,
    Python files end in '.py'
    rather than '.txt'.)
    To run it from the shell,
    type:
  </p>

<pre>
$ <span class="in">python greeting.py</span>
<span class="out">hello there</span>
</pre>

  <p>
    When the Python interpreter executes a file,
    it runs the commands in that file
    just as if they had been typed in interactively.
    It doesn't wait until the whole file has been read
    to start executing;
    instead,
    it runs each command as soon as it can.
    For example,
    if we create another file called <code>division.py</code>
    that contains the single line:
  </p>

<pre>
print "before", 1/0, "after"
</pre>

  <p class="continue">
    and run it,
    the output is:
  </p>

<pre>
before
<span class="err">Traceback (most recent call last):
  File "a.py", line 2, in &lt;module&gt;
    1/0
ZeroDivisionError: integer division or modulo by zero</span>
</pre>

  <p class="continue">
    because Python tries (and fails) to divide by zero
    before printing the word "after".
  </p>

  <div class="box">
    <h3>Using the IPython Notebook</h3>

    <p>
      Our examples are written using a command-line interpreter,
      but you may use the <a href="http://ipython.org/notebook.html">IPython Notebook</a> instead.
      Anything you write with one can be used with the other,
      but as a general rule,
      the Notebook is more useful for interactive or exploratory work,
      while programs saved in files are better suited to running long-lived batches of jobs
      in combination with other command-line tools.
    </p>

  </div>

  <div class="keypoints">
    <h3>Summary</h3>
    <ul>
      <li>Store programs in files whose names end in <code>.py</code> and run them with <code>python <em>name.py</em></code>.</li>
    </ul>
  </div>

  <div class="challenges">
    <h3>Challenges</h3>

    <ol>

      <li>
        Nelle has created a file called <code>example.py</code>
        that contains the following lines:
<pre>
tolerance = 5.0e3
thinning = 2 * tolerance / 1000
</pre>
        What happens when she runs this file from the shell using the command:
<pre>
$ <span class="in">python -i example.py</span>
</pre>
      </li>

      <li>
        Nelle has a file called <code>powers.txt</code> that contains:
<pre>
density = 1.417e3
radius = 4.5
mass = density * (4.0/3.0) * 3.14159 * radius ** 3
print mass
</pre>
        What does the double asterisk <code>**</code> do?
        And does she have to rename this file to <code>powers.py</code>
        in order to run it?
      </li>

    </ol>

  </div>
</section>

<section id="s:types">
  <h2>Types</h2>

  <div class="understand">
    <h3>Learning Objectives</h3>
    <ul>
      <li>Explain what a data type is, and give examples of three different data types.</li>
      <li>Correctly identify the types of integer, floating-point, and string values.</li>
      <li>Call a built-in function.</li>
      <li>Explain what "type conversion" is, and give an example.</li>
      <li>Explain (with an example) why programs shouldn't guess what people want to do.</li>
    </ul>
    <p>
      <span class="duration">10 minutes</span>.
    </p>
  </div>

  <p>
    Let's take another look at our temperature conversion program:
  </p>

<pre>
temp_fahr = 98.6
temp_kelvin = (temp_fahr - 32.0) * (5.0 / 9.0) + 273.15
print "body temperature in Kelvin:", temp_kelvin
<span class="out">body temperature in Kelvin: 310.15</span>
</pre>

  <p>
    Why have we written 5.0/9.0 instead of 5/9?
    Let's see what happens if we take out the .0's:
  </p>

<pre>
temp_fahr = 98.6
<span class="highlight">temp_kelvin = (temp_fahr - 32) * (5 / 9) + 273.15</span>
print "body temperature in Kelvin:", temp_kelvin
<span class="out">body temperature in Kelvin: 273.15</span>
</pre>

  <p>
    That's not right.
    To understand what's gone wrong,
    let's look at 5/9:
  </p>

<pre>
5/9
<span class="out">0</span>
</pre>

  <p>
    The problem is that integers and floating point numbers
    (or <a href="glossary.html#float">floats</a>)
    are different things to a computer.
    If a number doesn't have a decimal point,
    then Python stores its value as an integer (with no fractional part).
    When it divides one integer by another,
    it throws away the remainder.
    If a number contains a decimal point,
    though,
    Python stores it as a float.
    When it does division (or any other kind of arithmetic),
    the result is a float if either of the values involved is a float:
  </p>

  <table>
    <tr>
      <td valign="top">
<pre>
print 10 / 3
<span class="out">3</span>
</pre>
      </td>
      <td valign="top">
<pre>
10.0 / 3
<span class="out">3.3333333333333335</span>
</pre>
      </td>
    </tr>
  </table>

  <p class="continue">
    This makes sense,
    but only if you understand how the chips inside computers work.
    Version 3 of Python changed the rules for division
    so that it returns fractional numbers whenever it needs to.
    However,
    we're using Python 2.7 in this course,
    so 10/3 is 3 until further notice.
  </p>

  <p>
    Every value in a program has a specific <a href="glossary.html#type">type</a>
    which determines how it behaves
    and what can be done to it.
    We can find out what type something is
    using a built-in <a href="glossary.html#function">function</a> called <code>type</code>:
  </p>

  <table>
    <tr>
      <td valign="top">
<pre>
print type(12)
<span class="out">&lt;type 'int'&gt;</span>
</pre>
      </td>
      <td valign="top">
<pre>
type(12.0)
<span class="out">&lt;type 'float'&gt;</span>
</pre>
      </td>
    </tr>
  </table>

  <p>
    Integers and floating-point numbers are two common types;
    another is the character string.
    We can create one by putting characters inside either single or double quotes
    (as long as they match at the beginning and end):
  </p>

<pre>
name = "Alan Turing"
born = 'June 23, 1912'
print name, born
<span class="out">Alan Turing June 23, 1912</span>
</pre>

  <p>
    We can also "add" strings:
  </p>

<pre>
full = name + " (" + born + ")"
print full
<span class="out">Alan Turing (June 23, 1912)</span>
</pre>

  <p>
    What we <em>can't</em> do is add numbers and strings:
  </p>

<pre>
print 2 + "three"
<span class="err">Traceback (most recent call last):
  File "add-numbers-strings.py", line 1, in &lt;module&gt;
    print 2 + "three"
TypeError: unsupported operand type(s) for +: 'int' and 'str'</span>
</pre>

  <p>
    The string "2three" would be a reasonable result in this case,
    but it's not so where <code>2+"3"</code> should produce
    the integer 5 or the string <code>"23"</code>.
    Rather than guessing at the programmer's intentions,
    Python expects some guidance:
  </p>

  <table>
    <tr>
      <td valign="top">
<pre>
print 2 + int("3")
<span class="out">5</span>
</pre>
      </td>
      <td valign="top">
<pre>
print str(2) + "3"
<span class="out">23</span>
</pre>
      </td>
    </tr>
  </table>

  <p>
    <code>int</code> and <code>str</code> are two more built-in functions
    which convert values to particular types.
    We'll look at functions in much more detail later.
  </p>

  <div class="box">
    <h3>Values Have Types, Variables Don't</h3>

    <p>
      One important difference between "dynamic" languages
      like Python, Perl, and R,
      and compiled languages like C++, Java, and Fortran,
      is the relationship between variables and types.
      In a Java program,
      any particular variable can only store values of a particular type:
      if a variable has the type "integer",
      it can not hold a string,
      and vice versa.
      In Python,
      on the other hand,
      a variable is just a name,
      and can refer to anything at all.
      For example,
      the following is perfectly legal in Python:
    </p>

<pre>
age = 35 <span class="comment"># 'age' refers to an integer</span>
age = 'young' <span class="comment"># 'age' now refers to a string</span>
</pre>

    <p>
      Programmers disagree about whether this is good style or bad.
      On the one hand,
      the meaning of <code>age</code> is always the age of the current test subject;
      we're just representing it in different coordinate systems
      (years and then age bracket).
      On the other hand,
      switching types imposes an extra cognitive burden on readers:
      multiplying <code>age</code> by two makes sense when
      the value is an integer,
      but not when it's a string.
    </p>
  </div>

  <div class="keypoints">
    <h3>Summary</h3>
    <ul>
      <li>The most commonly used data types in Python are integers (<code>int</code>), floating-point numbers (<code>float</code>), and strings (<code>str</code>).</li>
      <li>Strings can start and end with either single quote (') or double quote (&quot;).</li>
      <li>Division ('/') produces an <code>int</code> result when given <code>int</code> values: one or both parameters must be <code>float</code> to get a <code>float</code> result.</li>
      <li>"Adding" strings concatenates them, multiplying strings by numbers repeats them.</li>
      <li>Strings and numbers cannot be added because the behavior is ambiguous: convert one to the other type first.</li>
      <li>Variables do not have types, but values do.</li>
    </ul>
  </div>

  <div class="challenges">
    <h3>Challenges</h3>

    <ol>

      <li>
        If the variable <code>x</code> holds a number,
        is the value of <code>int(str(x))</code> the same as the value of <code>x</code>?
      </li>

      <li>
        What is value of <code>molecule</code> after the following code is run?
<pre>
oxygen = 'O'
carbon = 'C
molecule = carbon + oxygen * 2
</pre>
      </li>

    </ol>

  </div>

</section>

<section id="s:io">
  <h2>Reading Files</h2>

  <div class="understand">
    <h3>Learning Objectives</h3>
    <ul>
      <li>Draw a diagram to explain where computers store data.</li>
      <li>Write programs that open, read, and close files.</li>
      <li>Explain how "lines" of text are actually stored in files.</li>
      <li>Call a pre-defined method of a built-in type.</li>
      <li>Write programs that write data to files.</li>
    </ul>
    <p>
      <span class="duration">20 minutes</span>.
    </p>
  </div>

  <p>
    Broadly speaking,
    modern computers store data in one of six places
    (<a href="#f:memory_architecture">Figure 4</a>):
  </p>

  <ol>

    <li>
      Inside the processor itself.
    </li>

    <li>
      In memory.
    </li>

    <li>
      On a local disk.
    </li>

    <li>
      On disk somewhere else on a network.
    </li>

    <li>
      In an offline archive,
      such as a DVD jukebox.
    </li>

  </ol>

  <figure id="f:memory_architecture">
    <img src="python/memory_architecture.png" alt="Where Data is Stored" />
    <figcaption>Figure 4: Where Data is Stored</figcaption>
  </figure>

  <p>
    Each level is tens to thousands of times faster than the one below it,
    but tens to thousands of times more expensive per byte.
    Broadly speaking,
    programs access information in three different ways:
  </p>

  <ol>

    <li>
      The data is in memory.
      The program can manipulate it directly,
      but changes will not be saved when the program ends.
    </li>

    <li>
      The data is on disk.
      The program has to read it into memory to work with it,
      and write changes back out,
      but those changes will persist after the program ends.
    </li>

    <li>
      The data is far away,
      and must be copied to the local machine for use
      (although given the speed of today's internet,
      there is much less difference between "local" and "remote"
      than there used to be).
    </li>

  </ol>

  <p>
    We'll deal with the third case <a href="web.html">later</a>.
    For now,
    let's look at how to get data out of a file on our computer's hard drive.
    Suppose that one of our hearing data files,
    <code>cochlear01.txt</code>,
    is formatted like this:
  </p>

<pre>
Subject: 1782
Date:    2012-05-21
Test     Run  Score
----     ---  -----
range    1    3
range    2    5
discrim  1    1
discrim  2    1
discrim  4    1.5
volume   1    3.5
volume   2    4.0
</pre>

  <p class="continue">
    It's easy to see where the tester decided that half-point scores were OK.
    We can also see that the tester either forgot to record
    the result of the third discrimination test,
    or decided to leave it out.
    Before worrying about that,
    let's write a small program that extracts the subject ID from a data file.
    Save the lines below in a file called <code>first.py</code>
    in the same directory as the <code>cochlear01.txt</code> data file:
  </p>

<pre>
reader = open('cochlear01.txt', 'r')
first_line = reader.readline()
print first_line
reader.close()
</pre>

  <p>
    The first line uses a built-in function called <code>open</code>
    to open our file.
    Its first parameter is the name of the file being opened.
    Its second is the string <code>'r'</code>,
    which signals that we want to read from this file
    (rather than write to it).
  </p>

  <p>
    <code>open</code>
    creates a connection (or <a href="glossary.html#handle">handle</a>)
    between the program and the data on disk
    (<a href="#f:file_object">Figure 5</a>),
    which is assigned to the variable <code>reader</code>.
    There's nothing special about that name&mdash;we could call it <code>newton</code>&mdash;but
    whatever we call it,
    we can ask it to read a line from the file for us
    and assign that string to <code>first_line</code>
    by calling its <a href="glossary.html#method">method</a> <code>readline</code>.
    The program then prints that line and tells the file to close itself.
    This last step isn't strictly necessary in a small program&mdash;Python
    automatically closes any files that are open when the program finishes&mdash;but
    it's a good habit to get into,
    since the operating system limits the number of files any one program can have open at a time.
  </p>

  <figure id="f:file_object">
    <img src="python/file_object.png" alt="File Objects" />
    <figcaption>Figure 5: File Objects</figcaption>
  </figure>

  <div class="box">
    <h3>Methods</h3>

    <p>
      <code>readline</code> is a special kind of function
      called a <a href="glossary.html#method">method</a>.
      It's attached to a particular object&mdash;in this case,
      to the file handle <code>reader</code>.
      You can think of objects and methods as nouns and verbs,
      so when we write <code>reader.readline()</code>,
      we're asking whatever the variable <code>reader</code> points at
      to do <code>readline</code> for us.
      As <a href="#f:methods">Figure 6</a> shows,
      the methods are associated with the thing the variable points at,
      not with the variable itself.
    </p>

    <figure id="f:methods">
      <img src="python/methods.png" alt="Where Methods Are Stored" />
      <figcaption>Figure 6: Where Methods Are Stored</figcaption>
    </figure>

  </div>

  <p>
    Here's what happens when we run our program:
  </p>

<pre>
$ <span class="in">python first.py</span>
<span class="out">Subject: 1782

</span>
</pre>

  <p>
    It's not easy to see, but there's actually an extra blank line in the output.
    Where does it come from?
  </p>

  <p>
    The answer depends on the fact that text files aren't stored in lines:
    that's just how things like text editors and shell commands display them.
    A text file is actually stored as a sequence of bytes
    (<a href="#f:text_file_storage">Figure 7</a>).
    Some of those happen to be newline characters,
    and most tools interpret them as meaning "end of line".
    In particular,
    when asked to read the next line from a file,
    Python's file-reading functions read up to and including the end-of-line marker
    and return that.
  </p>

  <figure id="f:text_file_storage">
    <img src="python/text_file_storage.png" alt="Text File Storage" />
    <figcaption>Figure 7: Text File Storage</figcaption>
  </figure>

  <p>
    Nothing says files have to be stored this way, though.
    On Windows,
    text files use two characters&mdash;a carriage return and a newline&mdash;to
    mark the end of line.
    If we are using Python on Windows,
    it automatically translates those two characters into a single newline when reading,
    and translates newlines back into those two characters when writing,
    so that our programs don't have to worry about it.
  </p>

  <p>
    Coming back to our program,
    the <code>print</code> command automatically adds an end-of-line marker
    to its output.
    We can tell it not to do that by putting a comma at the end of the line.
    This can make things confusing when we're using the interpreter interactively:
  </p>

<pre>
&gt;&gt;&gt; <span class="in">print 5</span> <span class="comment"># without comma</span>
<span class="out">5</span>
&gt;&gt;&gt; <span class="in">print 5,</span> <span class="comment"># with comma</span>
<span class="out">5</span>&gt;&gt;&gt;
</pre>

  <p class="continue">
    but it's useful when we want to prevent newlines doubling up:
  </p>

<pre>
reader = open('cochlear01.txt', 'r')
first_line = reader.readline()
print first_line<span class="highlight">,</span>
reader.close()
<span class="out">Subject: 1782</span>
</pre>

  <p>
    A better way to solve the problem is to get rid of the line ending on the string:
  </p>

<pre>
reader = open('cochlear01.txt', 'r')
first_line = reader.readline()
<span class="highlight">first_line = first_line.strip()</span>
print first_line
reader.close()
<span class="out">Subject: 1782</span>
</pre>

  <p class="continue">
    The variable <code>first_line</code> refers to a string,
    and strings in Python are also objects with methods.
    One of those methods,
    <code>strip</code>,
    creates a new string by removing any leading or trailing spaces, tabs, or line-ending characters
    from the original string
    (<a href="#f:string_strip">Figure 8</a>).
    It does <em>not</em> modify the original string:
    in Python,
    any string has a fixed value,
    just as the integer <code>5</code>'s value is always fixed at 5.
  </p>

  <figure id="f:string_strip">
    <img src="python/string_strip.png" alt="Stripping Strings" />
    <figcaption>Figure 8: Stripping Strings</figcaption>
  </figure>

  <div class="box">
    <h3>Writing Files</h3>

    <p>
      Writing to a file is as easy as reading from one:
    </p>

<pre>
writer = open('mydata.txt', 'w')
print &gt;&gt; writer, 'largest value:', 20
print &gt;&gt; writer, 'smallest value:', -2
writer.close()
</pre>

    <p class="continue">
      We begin by opening the file in <code>'w'</code> (write) mode.
      This gives us a handle that we can use in subsequent operations,
      which we assign to a variable.
      (We've called it <code>writer</code> here,
      but we could call it anything.)
      After that,
      we can print to the file exactly as we have been printing to the screen;
      as always,
      we close the file when we're done
      (which is when the last few things we've written to the file are actually stored on disk).
    </p>

    <p>
      Opening a file for writing erases its previous content,
      or creates the file if it didn't already exist.
      If we don't want to erase any previous content,
      we can open the file for appending using <code>'a'</code> instead of <code>'w'</code>.
    </p>

  </div>

  <div class="keypoints">
    <h3>Summary</h3>
    <ul>
      <li>Data is either in memory, on disk, or far away.</li>
      <li>Most things in Python are objects, and have attached functions called methods.</li>
      <li>When lines are read from files, Python keeps their end-of-line characters.</li>
      <li>Use <code>str.strip</code> to remove leading and trailing whitespace (including end-of-line characters).</li>
      <li>Use <code>open(<em>name</em>, <em>mode</em>)</code> to open a file for reading ('r'), writing ('w'), or appending ('a').</li>
      <li>Opening a file for writing erases any existing content.</li>
      <li>Use <code>file.readline</code> to read a line from a file.</li>
      <li>Use <code>file.close</code> to close an open file.</li>
      <li>Use <code>print &gt;&gt; file</code> to print to a file.</li>
    </ul>
  </div>

  <div class="challenges">
    <h3>Challenges</h3>

    <ol>

      <li>
        If <code>species.txt</code> is a text file,
        what do the following lines print?
<pre>
info = open('species.txt', 'r')
print info.readline().strip()
</pre>
      </li>

      <li>
        What does the following program leave in the file <code>output.txt</code>?
<pre>
results = open('output.txt', 'w')
results.write('first')
results.close()
results = open('output.txt', 'a')
results.write('second')
results.close()
</pre>
      </li>

      <li>
        If the file <code>square.txt</code> contains:
<pre>
abcde
fghij
klmno
</pre>
        what does the following program print?
<pre>
handle = open('square.txt', 'r')
result = len(handle)
handle.close()
print result
</pre>
      </li>

      <li>
        If <code>square.txt</code> contains the three lines shown above,
        and the file <code>final.txt</code> does not exist,
        what is the effect of the following program?
<pre>
reader = open('square.txt', 'r')
writer = open('final.txt', 'w')
writer = reader
reader.close()
writer.close()
</pre>
      </li>

    </ol>

  </div>

</section>

<section id="s:stdio">
  <h2>Standard Input and Output</h2>

  <div class="understand">
    <h3>Learning Objectives</h3>
    <ul>
      <li>Explain what "importing a module" means and does.</li>
      <li>Write programs that import standard library modules.</li>
      <li>Explain what standard input and output are, and how they relate to the <a href="shell.html#b:pipefilter">pipe-and-filter</a> model.</li>
      <li>Write programs that read from standard input.</li>
      <li>Write programs that write to standard output.</li>
    </ul>
    <p>
      <span class="duration">25 minutes</span>.
    </p>
  </div>

  <p>
    Our program currently reads the header from <code>cochlear01.txt</code>
    every time we run it.
    There's not much point in that:
    what we really want is to read from any file,
    or from several files in turn.
    Doing that requires a bit of machinery we haven't seen yet,
    so let's solve a simpler problem:
    reading from standard input instead of from a file.
    Once we can do that,
    we can run our program as:
  </p>

<pre>
$ <span class="in">python first.py &lt; somefile.txt</span>
</pre>

  <p class="continue">
    or read from several files using:
  </p>

<pre>
$ <span class="in">for inputfile in cochlear*.txt
do
    python first.py &lt; $inputfile
done</span>
</pre>

  <p>
    Here's the modified program:
  </p>

<pre>
<span class="highlight">import sys
reader = sys.stdin</span>
first_line = reader.readline()
first_line = first_line.strip()
print first_line
reader.close()
</pre>

  <p class="continue">
    The two lines that have changed are highlighted at the top of the program.
    The first loads a library called <code>sys</code>,
    which connects Python to the system it is running on.
    The second line sets <code>reader</code> to be <code>sys.stdin</code>,
    which is just the standard input stream we met in
    <a href="shell.html#s:pipefilter:pipes">our discussion of pipes</a>.
    Nothing else changes,
    since standard input tries really hard to behave like an open file
    (<a href="#f:replacing_with_stdin">Figure 9</a>).
    In particular,
    the object that <code>sys.stdin</code> (and hence <code>reader</code>) points at
    has a method with the same name and behavior as a file's <code>readline</code> method,
    and another with the same name and behavior as a file's <code>close</code>,
    so we can swap one for the other without having to modify anything else.
  </p>

  <figure id="f:replacing_with_stdin">
    <img src="python/replacing_with_stdin.png" alt="Replacing a File with Standard Input" />
    <figcaption>Figure 9: Replacing a File with Standard Input</figcaption>
  </figure>

  <div class="box">
    <h3>Interactive Testing</h3>

    <p>
      One other benefit of reading from standard input when no files are supplied
      is that it allows interactive testing:
      we can run our program
      and then just type in things we want it to read.
      If we do this,
      we must type control-D to signal the end of input
      (or control-Z in a Windows shell).
    </p>

  </div>

  <div class="box">
    <h3>Writing to Standard Output</h3>

    <p>
      Just as we can write to an open file using <code>print &gt;&gt; handle</code>,
      we can write to standard output using <code>print &gt;&gt; sys.stdout</code>.
      This is redundant, though,
      since <code>print</code> sends things to standard output by default.
    </p>

  </div>

  <div class="keypoints">
    <h3>Summary</h3>
    <ul>
      <li>The operating system automatically gives every program three open "files" called standard input, standard output, and standard error.</li>
      <li>Standard input gets data from the keyboard, from a file when redirected with '&lt;', or from the previous stage in a pipeline with '|'.</li>
      <li>Standard output writes data to the screen, to a file when redirected with '&gt;', or to the next stage in a pipeline with '|'.</li>
      <li>Standard error also writes data to the screen, and is not redirected by '&gt;' or '|'.</li>
      <li>Use <code>import <em>library</em></code> to import a library.</li>
      <li>Use <code>library.thing</code> to refer to something imported from a library.</li>
      <li>The <code>sys</code> library provides open "files" called <code>sys.stdin</code> and <code>sys.stdout</code> for standard input and output.</li>
    </ul>
  </div>

  <div class="challenges">
    <h3>Challenges</h3>

    <ol>

      <li>
        What is the difference between:
<pre>
import sys
reader = sys.stdin
print len(reader.readline())
</pre>
        and:
<pre>
import sys
print len(sys.stdin.readline())
</pre>
      </li>

      <li>
        What is the error in the following program,
        and how would you fix it?
<pre>
import sys
sys.stdin = open('temporary.txt', 'w')
sys.stdin.write(123)
sys.stdin.close()
</pre>
      </li>

      <li>
        Nelle wants to copy the first line of <code>patients.txt</code>
        to the file <code>subjects.txt</code>
        using the shell command:
<pre>
$ <span class="in">python copier.py &gt; subjects.txt</span>
</pre>
        Fill in the blanks in the program below so that it does this.
<pre>
import sys
source = ________
line = ________
source.close()
________.________(line)
</pre>
      </li>

    </ol>

  </div>

</section>

<section id="s:for">
  <h2>Repeating Things</h2>

  <div class="understand">
    <h3>Learning Objectives</h3>
    <ul>
      <li>Write a loop that processes the lines of a file.</li>
      <li>Trace the values taken on by a loop variable during execution of the loop.</li>
      <li>Explain what the "body" of a loop is, and correctly identify the bodies of loops.</li>
    </ul>
    <p>
      <span class="duration">15 minutes</span>.
    </p>
  </div>

  <p>
    Computers are useful because they can do lots of calculations on lots of data,
    which means we need a concise way to represent multiple steps:
    after all,
    writing out a million additions would take longer than doing them.
    Let's start by finding out how many lines we have in our data file,
    showing the prompts as the Python interpreter displays them:
  </p>

<pre>
&gt;&gt;&gt; reader = open('cochlear01.txt', 'r')
&gt;&gt;&gt; number = 0
&gt;&gt;&gt; for line in reader:
...    number = number + 1
&gt;&gt;&gt; reader.close()
&gt;&gt;&gt; print number, 'lines in file'
<span class="out">11 lines in file</span>
</pre>

  <p class="continue">
    Once again, we create a connection to the file using <code>file</code>.
    We then use a <a href="glossary.html#for-loop">for loop</a>
    to get one line from the file at a time.
    We don't do anything with the lines;
    instead,
    we add 1 to the value of <code>number</code> each time we see a new one.
    Once we're done,
    we close the file
    (so that other people and programs can access it safely)
    and report our findings
    (<a href="#f:for_loop">Figure 10</a>).
  </p>

  <figure id="f:for_loop">
    <img src="python/for_loop.png" alt="For Loop" />
    <figcaption>Figure 10: For Loop</figcaption>
  </figure>

  <p>
    The indented line is called the <a href="glossary.html#loop-body">body</a> of the loop.
    It's the command that Python executes repeatedly.
    When Python is expecting us to type in the body of a loop interactively,
    it changes its prompt from <code>&gt;&gt;&gt;</code> to <code>...</code>
    as a reminder.
  </p>

  <p>
    The variable <code>line</code> is sometimes called
    the <a href="glossary.html#loop-variable">loop variable</a>.
    There's nothing special about its name:
    we could equally well have called it <code>something</code>.
    What's important is that the <code>for</code> loop repeatedly
    assigns a value to it,
    then executes the loop body one more time.
  </p>

  <p>
    Python always uses indentation to show what's in the body of a loop
    (or anything else&mdash;we'll see other things that have bodies soon).
    This means that:
  </p>

<pre>
for line in reader:
    print line.strip()
    print "done"
</pre>

  <p class="continue">
    and:
  </p>

<pre>
for line in reader:
    print line.strip()
print "done"
</pre>

  <p class="continue">
    behave differently.  The first one prints:
  </p>

<pre>
<span class="out">Subject: 1782
done
Date:    2012-05-21
done
Test     Run  Score
done
...</span>
</pre>

  <p class="continue">
    because the statement <code>print "done"</code> is inside the loop.
    The second prints:
  </p>

<pre>
<span class="out">Subject: 1782
Date:    2012-05-21
Test     Run  Score
...
volume   2    4.0
done
</span>
</pre>

  <p class="continue">
    because it is not.
  </p>

  <div class="box">
    <h3>Why Indentation?</h3>

    <p>
      Most other languages use visible markers to show the beginnings and ends of loop bodies,
      such as:
    </p>

<pre>
for value in data {
    print value
}
</pre>

    <p class="continue">
      or:
    </p>

<pre>
for value in data
begin
    print value
end
</pre>

    <p>
      Python uses indentation because studies of how people read programs have found
      that's what people actually pay attention to.
      If we write something as:
    </p>
<pre>
for value in data {
    print value
}
    print "done"
</pre>

    <p class="continue">
      then most people reading the code in a hurry will "see"
      the second <code>print</code> statement as part of the loop,
      even though it's not.
    </p>

  </div>

  <p>
    Python has another, more general, kind of loop called a <code>while</code> loop.
    It repeats a block of code as long as a condition is true
    (<a href="#f:while_loop">Figure 11</a>):
  </p>

  <figure id="f:while_loop">
    <img src="python/while_loop.png" alt="While Loop" />
    <figcaption>Figure 11: While Loop</figcaption>
  </figure>

<pre>
counter = 3
while counter &gt; 0:
    print 'in loop', counter
    counter = counter - 1
print 'final value', counter
<span class="out">in loop 3
in loop 2
in loop 1
final value 0</span>
</pre>

  <p>
    <code>for</code> and <code>while</code> loops are sometimes called
    "definite" and "indefinite" loops
    because we know in advance how often the former will run,
    while we don't know for the latter:
    it depends on how the loop changes the values of variables.
    Another difference between the two kinds of loop is that
    if we <em>don't</em> change anything inside a <code>while</code> loop,
    it could run forever.
    For example,
    if we forget to subtract 1 from <code>counter</code> in the example above,
    it will print:
  </p>

<pre>
counter = 3
while counter &gt; 0:
    print 'in loop', counter
print 'final value', counter
<span class="out">in loop 3
in loop 3
in loop 3
...</span>
</pre>

  <p class="continue">
    until we get bored and interrupt it.
    If a program ever seems to hang up&mdash;i.e.,
    it's running,
    but not producing any results&mdash;the cause is often
    an <a href="glossary.html#infinite-loop">infinite loop</a>
    like this.
  </p>

  <p>
    One final important fact about <code>while</code> loops is that
    the condition is only checked at the top of the loop,
    not inside the loop:
    the loop doesn't somehow "watch" variables
    and exit as soon as the loop condition becomes false.
    For example,
    the first line inside the loop shown below makes the loop condition false,
    but it still prints the counter the first time through:
  </p>

<pre>
count = 3
while count &gt; 0:
    count = count - 100
    print count
<span class="out">-97</span>
</pre>

  <div>
    <h3>Why Two Kinds of Loops?</h3>

    <p>
      Any <code>for</code> loop can easily be rewritten as a <code>while</code> loop
      (though doing so requires <a href="#s:lists">some ideas</a> we haven't seen yet),
      and with a bit more work,
      any <code>while</code> loop can be rewritten as a <code>for</code> loop.
      So why do Python and other languages have both kinds of loop?
    </p>

    <p>
      Once again,
      the answer is rooted in human information processing.
      A <code>for</code> loop signals that the items in a collection
      will be processed exactly once,
      in order.
      A <code>while</code> loop offers no such guarantee:
      the loop's control condition can be anything at all,
      so the loop could behave in an infinite number of ways.
      Looking at the previous example once again,
      it would be natural to assume that the <code>while</code> loop would run three times,
      because most loops don't move in steps of 100.
      If there were a dozen lines in the body of the loop,
      and the subtraction was at the bottom of the loop instead of the top,
      it would be easy for a reader to misunderstand this code.
    </p>

  </div>

  <div class="keypoints">
    <h3>Summary</h3>
    <ul>
      <li>Use <code>for <em>variable</em> in <em>something</em>:</code> to loop over the parts of something.</li>
      <li>Use <code>while <em>condition</em>:</code> to loop while something is true.</li>
      <li>The body of a loop must be indented consistently.</li>
      <li>The parts of a string are its characters; the parts of a file are its lines.</li>
    </ul>
  </div>

  <div class="challenges">
    <h3>Challenges</h3>

    <ol>

      <li>
        Suppose that the file <code>counts.txt</code> contains:
<pre>
1
2
3
</pre>
        What are the values of <code>result</code> and <code>data</code>
        each time the loop shown below is executed,
        and what are their final values?
<pre>
source = open('counts.txt', 'r')
result = 'result:'
for data in source:
    result = result + data.strip()
source.close()
print result
</pre>
      </li>

      <li>
        If <code>lines.txt</code> contains dozens or hundreds of lines,
        what is a good short description of what the following program does?
<pre>
source = open(lines.txt', 'r')
one = source.readline()
two = source.readline()
for next in source:
    one = two
    two = next
source.close()
print one
</pre>
      </li>

      <li>
        What does the following program print?
<pre>
text = 'abc'
for char in text:
    text = text + char
print text
</pre>
      </li>

      <li>
        Suppose that the file <code>data.txt</code> contains:
<pre>
1
3
5
7
9
11
13
</pre>
        What does this program print?
<pre>
reader = open('data.txt', 'r')
total = 0
while total &lt; 10:
    total = total + int(reader.readline())
reader.close()
print total
</pre>
      </li>

    </ol>

  </div>

</section>

<section id="s:logic">
  <h2>Making Choices</h2>

  <div class="understand">
    <h3>Learning Objectives</h3>
    <ul>
      <li>Trace the execution of conditional statements.</li>
      <li>Write conditional statements to perform selected statements only under specific conditions.</li>
      <li>Use logical operators to combine tests in conditional statements.</li>
      <li>Explain what "in-place operators" are, and correctly write statements using them.</li>
    </ul>
    <p>
      <span class="duration">15 minutes</span>.
    </p>
  </div>

  <p>
    Let's make another change to our program <code>first.py</code>.
    If you recall,
    our data files look like this:
  </p>

<pre>
Subject: 1782
Date:    2012-05-21
Test     Run  Score
----     ---  -----
range    1    3
range    2    5
discrim  1    1
discrim  2    1
discrim  4    1.5
volume   1    3.5
volume   2    4.0
</pre>

  <p class="continue">
    The first four lines aren't actually data,
    so we really shouldn't include them
    when we're counting how many records are in the file.
    We could "fix" this simply by counting the total number of lines
    and subtracting four:
  </p>

<pre>
<span class="comment"># second.py</span>
reader = open('cochlear01.txt', 'r')
number = 0
for line in reader:
    number = number + 1
reader.close()
print number - 4, 'records in file'
<span class="out">7 records in file</span>
</pre>

  <p class="continue">
    but that is fragile:
    if anyone ever puts more (or less) than four descriptive lines at the top of a data file,
    our count will be wrong again.
    What we <em>really</em> want to do is skip everything up to the dashed lines.
    We also want to check that all the scores are between 0 and 5.
  </p>

  <p>
    Let's step back and build up the machinery we need.
    Suppose that our data files contained nothing but a single number on each line:
  </p>

<pre>
3
5
<span class="highlight">-1</span>
1
1.5
<span class="highlight">7</span>
4.0
</pre>

  <p class="continue">
    (We have deliberately added two out-of-range values for our program to find.)
    Here's a program that reads the data
    and counts the number that fall outside the allowed range:
  </p>

<pre>
import sys
num_outliers = 0
for value in sys.stdin:
    if value &lt; 0:
        num_outliers = num_outliers + 1
    if value &gt; 5:
        num_outliers = num_outliers + 1
print num_outliers, "values out of range"
</pre>

  <p class="continue">
    The command <code>if</code> means exactly what it does in English:
    if a particular condition is true,
    then do the statement or statements that are in the <code>if</code> statement's body
    (i.e., indented underneath it).
    Here,
    we are using one <code>if</code> to see if the current value is less than 0,
    and another to see if it is greater than 5.
    In either case,
    we add one to the count of outliers.
    If neither condition is satisfied,
    the value is clean,
    and <code>num_outliers</code> won't be changed in that loop
    (<a href="#f:loop_cond_flow">Figure 12</a>).
  </p>

  <figure id="f:loop_cond_flow">
    <img src="python/loop_cond_flow.png" alt="Conditional Execution" />
    <figcaption>Figure 12: Conditional Execution</figcaption>
  </figure>

  <p>
    When we run this program, though,
    it reports that all of the values in the input are outliers:
  </p>

<pre>
$ <span class="in">python second.py &lt; cochlear01.txt</span>
<span class="out">7 values out of range</span>
</pre>

  <p class="continue">
    The problem is once again one of types:
    the loop variable <code>line</code> holds a string like <code>'3'</code>,
    not the number 3,
    and all strings are greater than all numbers:
  </p>

<pre>
'hello' &gt; 0
<span class="out">True</span>
</pre>

  <p>
    The fix is straightforward&mdash;we just have to convert
    all the strings to numbers before we do the comparison:
  </p>

<pre>
import sys
num_outliers = 0
for <span class="highlight">line</span> in sys.stdin:
    <span class="highlight">value = float(line)</span>
    if value &lt; 0:
        num_outliers = num_outliers + 1
    if value &gt; 5:
        num_outliers = num_outliers + 1
print num_outliers, "values out of range"
<span class="out">2 values out of range</span>
</pre>

  <div class="box">
    <h3>Why Isn't It An Error?</h3>

    <p>
      Take a closer look at the original verison of the outlier counter,
      which produced the wrong answer:
    </p>

<pre>
for value in sys.stdin:
    if value &lt; 0:
        num_outliers = num_outliers + 1
    ...
</pre>

    <p>
      Why did this produce the wrong answer
      rather than an error message?
      If <code>value</code> contains a string
      and 0 is an integer,
      <code>value+0</code> is an error&mdash;why
      isn't <code>value&lt;0</code> also an error?
    </p>

    <p>
      The answer is that Python always lets us compare things,
      no matter what the types of those things are.
      We can't add a string and a number,
      but we can ask which is greater,
      whether they're equal,
      and so on.
      Python does this so that it can always sort things,
      even if those things have different types,
      and sorting only works if we can compare things.
      We'll revisit sorting <a href="#a:sorting">later</a>.
    </p>
  </div>

  <p>
    Let's make this program a little more readable.
    First,
    we'll combine our two tests using <code>or</code>
    so that the statement that adds one to <code>num_outliers</code>
    doesn't have to be duplicated:
  </p>

<pre>
import sys
num_outliers = 0
for line in sys.stdin:
    value = float(line)
    if (value &lt; 0) or (value &gt; 5):
        num_outliers = num_outliers + 1
print num_outliers, "values out of range"
</pre>

  <p class="continue">
    Alternatively,
    we could count how many values are in range using <code>and</code>:
  </p>

<pre>
import sys
num_valid = 0
for line in sys.stdin:
    value = float(line)
    if (0 &lt;= value) and (value &lt;= 5):
        num_valid = num_valid + 1
print num_valid, "values in range"
</pre>

  <p class="continue">
    which tells us that five values are in range.
    We can simplify the test even further by writing it the way a mathematician would:
  </p>

<pre>
import sys
num_valid = 0
for line in data:
    value = float(line)
    if <span class="highlight">0 &lt;= value &lt;= 5</span>:
        num_valid = num_valid + 1
print num_valid, "values in range"
</pre>

  <p>
    And if we want to count in-range values and outliers at the same time,
    we can use <code>else</code>.
    Its block of code is executed when
    the code in the <code>if</code> it's paired with
    <em>isn't</em> executed
    (<a href="#f:else_flow">Figure 13</a>):
  </p>

  <figure id="f:else_flow">
    <img src="python/else_flow.png" alt="If and Else" />
    <figcaption>Figure 13: If and Else</figcaption>
  </figure>

<pre>
import sys
num_outliers = 0
num_valid = 0
for line in sys.stdin:
    value = float(line)
    if 0 &lt;= value &lt;= 5:
        num_valid = num_valid + 1
    else:
        num_outliers = num_outliers + 1
print num_valid, "in range and", num_outliers, "outliers"
</pre>

  <div class="box">
    <h3>Alternatives</h3>

    <p>
      <code>if</code> lets us check a particular condition,
      and <code>else</code> does something when the <code>if</code> failed.
      Python has a third keyword <code>elif</code> that combines the two:
      it tests a condition,
      but only when all preceding tests have failed.
      For example,
      we can categorize test subjects as follows:
    </p>

<pre>
if age &lt; 12:
    category = 'child'
elif age &lt; 20:
    category = 'teen'
elif age &lt; 40:
    category = 'young adult'
elif age &lt; 65:
    category = 'middle-aged'
else:
    category = 'senior'
</pre>

    <p>
      As <a href="#f:elif">Figure 14</a> shows,
      at most one path is taken through this conditional.
    </p>

    <figure id="f:elif">
      <img src="python/elif.png" alt="If/Elif/Else" />
      <figcaption>Figure 14: If/Elif/Else</figcaption>
    </figure>

  </div>

  <p>
    Finally,
    we have seen expressions like:
  </p>

<pre>
num_valid = num_valid + 1
</pre>

  <p class="continue">
    several times now.
    In Python and many other languages,
    we can simplify this by writing:
  </p>

<pre>
num_valid += 1
</pre>

  <p class="continue">
    which means,
    "Update the value on the left using addition with the value on the right."
    Similarly,
    we could double the value in the variable <code>something</code>
    like this:
  </p>

<pre>
something *= 2
</pre>

  <p class="continue">
    and so on for other binary (two-valued) operators.
    It may seem like a small saving,
    but it actually prevents a lot of bugs
    by eliminating duplicated code.
  </p>
  
  <div class="keypoints">
    <h3>Summary</h3>
    <ul>
      <li>Use <code>if <em>test</em></code> to do something only when a condition is true.</li>
      <li>Use <code>else</code> to do something when a preceding <code>if</code> test is not true.</li>
      <li>The body of an <code>if</code> or <code>else</code> must be indented consistently.</li>
      <li>Combine tests using <code>and</code> and <code>or</code>.</li>
      <li>Use '&lt;', '&lt;=', '&gt;=', and '&gt;' to compare numbers or strings.</li>
      <li>Use '==' to test for equality and '!=' to test for inequality.</li>
      <li>Use <code><em>variable</em> += <em>expression</em></code> as a shorthand for <code><em>variable</em> = <em>variable</em> + <em>expression</em></code> (and similarly for other arithmetic operations).</li>
    </ul>
  </div>

  <div class="challenges">
    <h3>Challenges</h3>

    <ol>
      <li>
        What is the value of <code>x</code> after executing the code shown below?
<pre>
x = 1
x += x + 1
</pre>
        Should you write code this way?
        Why or why not?
      </li>

      <li>
        What change must be made to the following code
        (if any)
        so that it prints the word "one"?
<pre>
major = 5 &gt; 0
minor = 0.5 &lt;= 0
if major and minor:
    print 'both'
elif major or minor:
    print 'one'
else:
    print 'neither'
</pre>
      </li>

      <li>
        A program starts with these two lines:
<pre>
color = 'green'
shape = 'triangle'
</pre>
        Which of the blocks of code shown below
        changes the shape to a square
        without changing the color?
        <table>
          <tr>
            <td valign="top">A</td>
            <td valign="top">
<pre>
if color == 'green':
    shape = 'square'
elif shape == 'square':
    color = 'red'
</pre>
            </td>
          </tr>
          <tr>
             <td valign="top">B</td>
             <td valign="top">
<pre>
if color == 'green':
    shape = 'square'
if shape == 'square':
    color = 'red'
</pre>
             </td>
          </tr>
          <tr>
            <td valign="top">C</td>
            <td valign="top">
<pre>
if color == 'green' or shape == 'square':
    shape = 'circle'
if shape == 'square':
    color = 'red'
</pre>
            </td>
            <tr>
              <td valign="top">D</td>
              <td valign="top">
<pre>
if color == 'green':
    if shape != 'triangle':
        shape = 'circle'
else:
    shape = 'square'
</pre>
              </td>
            </tr>
        </table>
      </li>

      <li>
        Python allows programmers to attach an <code>else</code> to a <code>for</code> loop:
<pre>
name = ''
for char in name:
    print char
else:
    print 'nothing in name'
</pre>
        When would you use this in a data analysis program?
      </li>

    </ol>

  </div>

</section>

<section id="s:flag">
  <h2>Flags</h2>

  <div class="understand">
    <h3>Learning Objectives</h3>
    <ul>
      <li>Explain the difference between Boolean expressions and Boolean values.</li>
      <li>Write statements that create and store Boolean values, and use them correctly in conditional statements.</li>
      <li>Write examples showing how to keep track of events using flag variables.</li>
    </ul>
    <p>
      <span class="duration">20 minutes</span>.
    </p>
  </div>

  <p>
    We're used to thinking of "less than" and "equal to" as adjectives.
    In a program,
    though,
    an expression like <code>value &lt; 0</code> produces one of two values
    called (unsurprisingly) <code>True</code> and <code>False</code>.
    These are called <a href="glossary.html#boolean">Boolean values</a>,
    after the English mathematician George Boole,
    and they can be assigned to variables like any other kind of values:
  </p>

<pre>
x = 5
is_less_than = x &lt; 0
print is_less_than
<span class="out">False</span>
</pre>

  <p>
    It's very common to assign <code>True</code> and <code>False</code> to variables
    to keep track of whether some event has happened.
    For example,
    we could create a variable called <code>have_seen_dashed_line</code>
    to keep track of whether or not we have seen the dashed line that separates
    the header in a data file from the actual data.
    Its initial value will be <code>False</code>,
    because we obviously haven't seen the dashed line before we've read any input.
    As soon as we do see the dashed line,
    we set it to <code>True</code>:
  </p>

<pre>
import sys
have_seen_dashed_line = False
for line in data:
    if line.startswith('---'):
        have_seen_dashed_line = True
print 'Did we ever see the dashed line?', have_seen_dashed_line
<span class="out">True</span>
</pre>

  <p>
    A variable that is used this way is often called
    a <a href="glossary.html#flag">flag</a>.
    We can use the <code>have_seen_dashed_line</code> flag's value
    to decide whether or not to count a line as data:
  </p>

<pre>
import sys
have_seen_dashed_line = False
number = 0
for line in data:
    if line.startswith('---'):
        have_seen_dashed_line = True
    if have_seen_dashed_line:
        number = number + 1
print 'Number of data lines:', number
<span class="out">Number of data lines: 8</span>
</pre>

  <figure id="f:set_and_increment">
    <img src="python/set_and_increment.png" alt="Flagging and Incrementing" />
    <figcaption>Figure 15: Flagging and Incrementing</figcaption>
  </figure>

  <p>
    Whoops&mdash;that's almost right, but not quite.
    There are only 7 data lines in our file:
    why are we reporting 8?
    The reason is that when we see the dashed line,
    we set <code>have_seen_dashed_line</code> to <code>True</code>,
    then immediately check its value,
    see that it's true,
    and increment <code>number</code>
    (<a href="#f:set_and_increment">Figure 15</a>).
    What we want to do is <em>either</em> set the flag
    (so that we'll start incrementing on the next iteration),
    <em>or</em> add one to <code>number</code>.
    Here's the fixed program:
  </p>

<pre>
import sys
have_seen_dashed_line = False
number = 0
for line in data:
    if line.startswith('---'):
        have_seen_dashed_line = True
<span class="highlight">    else:
        if have_seen_dashed_line:
            number = number + 1</span>
print 'Number of data lines:', number
<span class="out">Number of data lines: 7</span>
</pre>

  <p>
    And here's a version that combines the second <code>if</code>
    with the <code>else</code>
    using <code>elif</code>:
  </p>

<pre>
import sys
have_seen_dashed_line = False
number = 0
for line in data:
    if line.startswith('---'):
        have_seen_dashed_line = True
    elif have_seen_dashed_line:
        number = number + 1
print 'Number of data lines:', number
<span class="out">Number of data lines: 7</span>
</pre>

  <p class="continue">
    Organizing our choices this way makes it clearer that
    exactly one will be executed.
  </p>

  <div class="keypoints" id="k:flag">
    <h3>Summary</h3>
    <ul>
      <li>The two Boolean values <code>True</code> and <code>False</code> can be assigned to variables like any other values.</li>
      <li>Programs often use Boolean values as flags to indicate whether something has happened yet or not.</li>
    </ul>
  </div>

  <div class="challenges">
    <h3>Challenges</h3>

    <ol>
      <li>
        When converted to numbers,
        <code>True</code> has the value 1 and <code>False</code> has the value 0:
<pre>
print True + True + False
<span class="out">2</span>
</pre>
        Knowing this,
        explain what the following does and why it works:
<pre>
in_range += 0 &lt;= number &lt;= 5
</pre>
        Do you think this is readable or not?
        Do you think your opinion will change over the next few months or not?
      </li>

      <li>
        Using the same relationship between Boolean values and numbers,
        explain why <code>5 &lt; 0 &lt; 10</code> is <code>False</code>,
        but <code>(5 &lt; 0) &lt; 10</code> is <code>True</code>.
      </li>

      <li>
        Python considers zero and the empty string equivalent to be false,
        and all non-zero numbers and non-empty strings equivalent to be true.
        Knowing that,
        how can you simplify the following lines of code:
<pre>
if len(some_string) != 0:
    print 'string is not empty'
elif some_number != 0:
    print 'number is not zero'
elif some_flag == True:
    print 'flag is true'
</pre>
      </li>

      <li>
        Aurora has inherited some audio sample files
        in which regions are marked with the words "begin" and "end":
<pre>
4.1
4.3
begin
7.2
7.9
8.1
end
5.5
begin
12.0
11.5
end
9.2
</pre>
        She wants to add up the values that lie within each marked region,
        so that for the sample data shown above,
        her program's output would be:
<pre>
<span class="out">23.2
23.5</span>
</pre>
        Fill in the program shown below to do this.
<pre>
import sys
in_region = False
current = 0.0
for line in sys.stdin:
    line = line.strip()
    if in_region:
        if line == 'end':
            print current
            ________
        else:
            ________
    else:
        if line == ________:
            ________
            current = 0.0
print current
</pre>
        Why is the final <code>print</code> statement needed?
        How will the output of the program be wrong without it?
      </li>

    </ol>

  </div>

</section>

<section id="s:parse">
  <h2>Reading Data Files</h2>

  <div class="understand">
    <h3>Learning Objectives</h3>
    <ul>
      <li>Read a simple columnar data file and operate on its values.</li>
    </ul>
    <p>
      <span class="duration">30 minutes</span>.
    </p>
  </div>

  <p>
    It's finally time to clean up Aurora's actual cochlear implant data files.
    Once again,
    these files typically look like this:
  </p>

<pre>
Subject: 1782
Date:    2012-05-21
Test     Run  Score
----     ---  -----
range    1    3
range    2    5
discrim  1    1
discrim  2    1
discrim  4    1.5
volume   1    3.5
volume   2    4.0
</pre>

  <p>
    We already know how to ignore everything
    up to and including the dash line:
  </p>

<pre>
import sys
have_seen_dashed_line = False
number = 0
for line in data:
    if line.startswith('---'):
        have_seen_dashed_line = True
    elif have_seen_dashed_line:
        number = number + 1
print 'Number of data lines:', number
</pre>

  <p class="continue">
    Let's put that in a file called <code>check.py</code>
    and modify it to report scores that are outside the range 0&ndash;5.
    First,
    we need a way to break each line into columns.
    Luckily for us,
    strings know how to split themselves into fields:
  </p>
  
<pre>
&gt;&gt;&gt; typical_line = 'volume   2    4.0'
&gt;&gt;&gt; name, number, score = typical_line.split()
&gt;&gt;&gt; name
'volume'
&gt;&gt;&gt; number
'2'
&gt;&gt;&gt; score
'4.0'
</pre>

  <p class="continue">
    The <code>string.split</code> returns as many new strings
    as there are whitespace-separated fields in the original string.
    In our case,
    there are three fields,
    so we can assign them result of <code>split</code> to three separate variables simultaneously.
    The third field,
    which we have put in the variable <code>score</code>,
    is a string;
    if we want its value as a floating-point number,
    we'll have to convert it using the <code>float</code> function.
    Combining this code with the program we already had,
    we get:
  </p>

<pre>
import sys
have_seen_dashed_line = False
for line in data:
    if line.startswith('---'):
        have_seen_dashed_line = True
    elif have_seen_dashed_line:
<span class="highlight">        name, number, score = line.split()
        score = float(score)</span>
</pre>

  <p>
    A simple <code>if</code> statement is the last piece of the puzzle:
  </p>

<pre>
import sys
have_seen_dashed_line = False
for line in data:
    if line.startswith('---'):
        have_seen_dashed_line = True
    elif have_seen_dashed_line:
        name, number, score = line.split()
        score = float(score)
<span class="highlight">        if (score &lt; 0.0) or (score &gt; 5.0):
            print 'Out of range:', name, number, score</span>
</pre>

  <p>
    This program doesn't produce any output
    when we run it on our original data file
    because all the scores in the file are valid:
  </p>

<pre>
$ <span class="in">python check.py &lt; cochlear01.txt</span>
$
</pre>

  <p class="continue">
    But if we make some of the scores invalid,
    like this:
  </p>

<pre>
Subject: 1782
Date:    2012-05-21
Test     Run  Score
----     ---  -----
range    1    3
range    2    <span class="highlight">7.5</span>
discrim  1    1
discrim  2    1
discrim  4    1.5
volume   1    <span class="highlight">-3</span>
volume   2    4.0
</pre>

  <p class="continue">
    then the output changes to:
  </p>

<pre>
<span class="out">Out of range: range 2 7.5
Out of range: volume 1 -3.0</span>
</pre>

  <p class="continue">
    which is what we wanted.
  </p>

  <div class="box">
    <h3>When Not To Do This</h3>

    <p>
      The technical term for extracting information from a file
      that has some internal structure
      is <a href="glossary.html#parsing">parsing</a>.
      Most of the time,
      you <em>don't</em> want to do this.
      Instead,
      you want to use a parser that someone else has already written and tested.
      We'll meet a few later in this lesson;
      for now,
      though,
      learning how to get values out of files
      is a good way to learn basic programming concepts.
    </p>
  </div>

  <div class="keypoints">
    <h3>Summary</h3>
    <ul>
      <li>Use <code>str.split()</code> to split a string into pieces on whitespace.</li>
      <li>Values can be assigned to any number of variables at once.</li>
    </ul>
  </div>

  <div class="challenges">
    <h3>Challenges</h3>

    <ol>
      <li>
        What does this program calculate?
<pre>
for line in open('columns.txt', 'r'):
    first, second = line.strip().split()
    print int(first) + int(second)
</pre>
      </li>

      <li>
        Explain what this program does,
        and give an example of five or six lines of input
        that will cause each line in this program to be executed
        at least once.
<pre>
import sys
total = 0.0
for line in sys.stdin:
    if line.startswith('#'):
        print total
        total = 0.0
    else:
        total += float(line)
</pre>
      </li>

      <li>
        Explain what this program does:
<pre>
import sys
largest = 0
for line in sys.stdin:
    if '#' in line:
        line, rest = line.split('#')
    largest = max(largest, len(line.strip()))
print largest
</pre>
      </li>

      <li>
        Explain what this program does:
<pre>
import sys
for line in sys.stdin:
    line = line.strip()
    if line:
        print line
</pre>
      </li>

    </ol>
  </div>

</section>

<section id="s:lists">
  <h2>Lists</h2>

  <div class="understand">
    <h3>Learning Objectives</h3>
    <ul>
      <li>Explain why it is useful to store many values together.</li>
      <li>Write programs that create and manipulate lists of numbers and strings.</li>
      <li>Write programs that use loops to operate independently on each value in a list.</li>
      <li>Explain why programs should be tested on short, simple inputs first.</li>
      <li>Explain the difference between mutable and immutable values.</li>
      <li>Index a list to retrieve values at specific locations.</li>
      <li>Show how to alter the values in a list.</li>
      <li>Trace changes to a list's values as a result of assignment.</li>
      <li>Explain what an "out-of-bounds error" is, and give an example showing when one would occur.</li>
      <li>Show how to generate all the valid indices for a list's elements.</li>
      <li>Explain when it is appropriate to use short or long variable names, and why.</li>
    </ul>
    <p>
      <span class="duration">20 minutes</span>.
    </p>
  </div>

  <p>
    Loops give us a way to do many operations by repeating a few instructions.
    Lists give us a way to store many values under one name,
    so that we can do the same things to all of them.
    To start our exploration of lists,
    let's run an interpreter and try this:
  </p>

<pre>
data = [1, 3, 5]
for value in data:
    print value
<span class="out">1
3
5</span>
</pre>

  <p>
    <code>[1, 3, 5]</code> is a <a href="glossary.html#list">list</a>:
    a single object that stores multiple values
    (<a href="#f:simple_list">Figure 16</a>).
    Just as a <code>for</code> loop over an open file
    reads lines from that file one by one
    and assigns them to the loop variable,
    a <code>for</code> loop over a list assigns each value in the list
    to the loop variable in turn.
  </p>

  <figure id="f:simple_list">
    <img src="python/simple_list.png" alt="A Simple List" />
    <figcaption>Figure 16: A Simple List</figcaption>
  </figure>

  <p>
    Let's do something a bit more useful with those numbers:
  </p>

<pre>
data = [1, 4, 2, 3, 3, 4, 3, 4, 1]
total = 0
for n in data:
    total += n
mean = total / len(data)
print "mean is", mean
<span class="out">mean is 2</span>
</pre>

  <p class="continue">
    This loop adds each value in the list to <code>total</code>.
    Once the loop is over,
    we divide <code>total</code> by the length of the list,
    which we find using the built-in function <code>len</code>.
  </p>

  <p>
    The result should be the average of the values in the list,
    but what we get isn't quite right.
    The total of the numbers in the list is 25,
    but we're printing 2 instead of 25/9
    (which is 2.7777&hellip;).
    The problem (once again) is that we're dividing one integer by another,
    which throws away the remainder.
    We can fix this by initializing <code>total</code> to 0.0
    (so that all the additions involve a floating-point number and an integer,
    which produces a floating-point number),
    or by using the <code>float</code> function to do the conversion explicitly:
  </p>

<pre>
data = [1, 4, 2, 3, 3, 4, 3, 4, 1]
total = 0
for n in data:
    total += n
mean = <span class="highlight">float(total)</span> / len(data)
print "mean is", mean
<span class="out">mean is 2.77777777778</span>
</pre>

  <p>
    The <em>real</em> problem isn't a matter of integers versus floats, though.
    The real problem with this program is that
    we didn't know whether the answer was right or wrong,
    so we couldn't tell if the program was correct or not.
    After all,
    the average of these nine numbers might well have been 2.
  </p>
  
  <p>
    The fact that a program runs without crashing doesn't mean it's correct.
    One way to make programs easier to check
    is to run them on smaller or more regular data.
    For example,
    If we ran the program on <code>[1, 4]</code>,
    we'd probably notice that we were getting 2 instead of 2.5.
    Writing programs so that they're checkable is another idea
    that we'll explore in detail <a href="quality.html">later</a>.
  </p>

  <div class="box">
    <h3>Even Simpler</h3>

    <p>
      Python actually has a built-in function called <code>sum</code>,
      so we can get rid of the loop entirely:
    </p>

<pre>
total = sum(data)
print "mean is", float(total) / len(data)
</pre>

    <p class="continue">
      and shorten this even further by calling <code>float</code>
      directly on the result of <code>sum</code>:
    </p>

<pre>
print "mean is", float(sum(data)) / len(data)
</pre>

    <p>
      <code>float(sum(data))</code> is like <em>sin(log(x))</em>:
      the inner function is evaluated first,
      and its result is used as the input to the outer function.
      It's important to get the parentheses in the right place,
      since the expressions:
    </p>
    
<pre>
float(sum(data)) / len(data)
</pre>

    <p class="continue">
      and
    </p>

<pre>
float(sum(data) / len(data))
</pre>

    <p class="continue">
      calculate different things.
      In the first,
      <code>float</code> is applied to <code>sum(data)</code>,
      i.e.,
      Python adds up all the numbers,
      then converts the result to a floating-point value
      before dividing by <code>len(data)</code>
      to get the mean.
    </p>

    <p>
      In the second,
      Python adds up the numbers,
      divides by <code>len(data)</code> to get an integer result,
      and then converts that integer to a floating point number.
      This is just our original bug in a more compact form.
      Once again,
      the only way to guard against it is to test the program.
    </p>

  </div>

  <p>
    Lists are probably used more than any other data structure in programming,
    so let's have a closer look at them.
    First,
    lists are <a href="glossary.html#mutable">mutable</a>,
    i.e.,
    they can be changed after they are created:
  </p>
  
<pre>
data = [1, 4, 2, 3]
result = []
current = 0
for n in data:
    current = current + n
    result.append(current)
print "running total:", result
<span class="out">[1, 5, 7, 10]</span>
</pre>

  <p class="continue">
    <code>result</code> starts off as an <a href="glossary.html#empty-list">empty list</a>,
    and <code>current</code> starts off as zero
    (<a href="#f:running_total">Figure 17</a>).
    Each time the loop executes&mdash;i.e.,
    for each number in <code>values</code>&mdash;Python
    adds the next value in the list to <code>current</code>
    to calculate the running total.
    It then append this value to <code>result</code>,
    so that when the program finishes,
    we have a complete list of partial sums.
  </p>

  <figure id="f:running_total">
    <img src="python/running_total.png" alt="Running Total" />
    <figcaption>Figure 17: Running Total</figcaption>
  </figure>

  <p>
    What if we want to double the values in <code>data</code> in place?
    We could try this:
  </p>

<pre>
data = [1, 4, 2, 3]
for n in data:
    n = 2 * n
print "doubled data is:", data
<span class="out">doubled data is [1, 4, 2, 3]</span>
</pre>

  <p class="continue">
    but as we can see,
    it doesn't work.
    When Python calculates <code>2*n</code>,
    it creates a new value in memory
    (<a href="#f:doubling_list">Figure 18</a>).
    It then makes the variable <code>n</code> point at the value for a few microseconds
    before going around the loop again
    and pointing <code>n</code> at the next value from the list instead.
    Since nothing is pointing to the temporary value we just created any longer,
    Python throws it away.
  </p>

  <figure id="f:doubling_list">
    <img src="python/doubling_list.png" alt="Failed Attempt to Double Values in a List" />
    <figcaption>Figure 18: Failed Attempt to Double Values in a List</figcaption>
  </figure>

  <p>
    The solution to our problem is to <a href="glossary.html#list-indexing">index</a> the list,
    which is just like subscripting a vector in mathematics.
    Here are some examples:
  </p>

<pre>
&gt;&gt;&gt; <span class="in">scientists = ["Newton", "Darwing", "Turing"]</span>
&gt;&gt;&gt; <span class="in">print "length:", len(scientists)</span>
<span class="out">length: 3</span>
&gt;&gt;&gt; <span class="in">print "first element:", scientists[0]</span>
<span class="out">first element: Newton</span>
&gt;&gt;&gt; <span class="in">print "second element:", scientists[1]</span>
<span class="out">second element: Darwing</span>
&gt;&gt;&gt; <span class="in">print "third element:", scientists[2]</span>
<span class="out">third element: Turing</span>
</pre>

  <div class="box">
    <h3>It Seemed Like a Good Idea at the Time</h3>

    <p>
      For reasons that made sense in 1970,
      when the C programming language was invented,
      Python lists are indexed from 0 to N-1 rather than 1 to N.
      C++, C#, Java, and other languages that imitate C also use 0 to N-1,
      while Fortran, Pascal, MATLAB,
      and other languages that imitate human beings use 1 to N.
    </p>

  </div>

  <p>
    How does indexing help us?
    Well,
    after noticing that we have misspelled Darwin's name as "Darwing",
    we can fix it by assigning a new value to that location in the list:
  </p>

<pre>
scientists[1] = "Darwin"
print scientists
<span class="out">["Newton", "Darwin", "Turing"]</span>
</pre>

  <p class="continue">
    <a href="#f:update_list">Figure 19</a> shows
    the list before and after the change.
    Again,
    once we've made the update,
    nothing is pointing to the string "Darwing" with a "g" on the end,
    so the memory it's using is recycled.
  </p>

  <figure id="f:update_list">
    <img src="python/update_list.png" alt="Successfully Doubling Values in a List" />
    <figcaption>Figure 19: Successfully Doubling Values in a List</figcaption>
  </figure>

  <p>
    In order for Python to give us a sensible value,
    the index we provide for a list must be in range,
    i.e.,
    between 0 and one less than the length of the list.
    If it's too large,
    we get an error message:
  </p>

<pre>
scientists = ["Newton", "Darwin", "Turing"]
print scientists[55]
<span class="err">Traceback (most recent call last):
  File "list-04.py", line 2, in &lt;module&gt;
    print "out of range:", scientists[55]
IndexError: list index out of range</span>
</pre>

  <p class="continue">
    The error message doesn't appear
    until Python actually tries to fetch the out-of-bounds value.
    If this is in the middle of some other operation,
    we may see some partial output before our error message:
  </p>

<pre>
scientists = ["Newton", "Darwin", "Turing"]
print "out of range:", scientists[55]
<span class="out">out of range:</span>
<span class="err">Traceback (most recent call last):
  File "list-04.py", line 2, in &lt;module&gt;
    print "out of range:", scientists[55]
IndexError: list index out of range</span>
</pre>

  <div class="box" id="a:negative">
    <h3>Useful but not Intuitive</h3>

    <p>
      Here's something else that's useful.
      In Python (but <em>not</em> in most other languages),
      negative indices count backward from the end of a list:
    </p>

<pre>
scientists = ["Newton", "Darwin", "Turing"]
print "last:", scientists[-1]
print "penultimate:", scientists[-2]
<span class="out">last: Turing
penultimate: Darwin</span>
</pre>

    <p class="continue">
      It's a lot easier to type <code>scientists[-1]</code>
      than <code>scientists[len(scientists)-1]</code>
      to get the last item in a list,
      but it does take some getting used to.
    </p>
  </div>
    
  <p>
    Back to our original problem of doubling values in place.
    We now know that we can do this:
  </p>

<pre>
data = [1, 4, 2]
data[0] = 2 * data[0]
data[1] = 2 * data[1]
data[2] = 2 * data[2]
print "doubled data is:", data
<span class="out">doubled data is [2, 8, 4]</span>
</pre>

  <p class="continue">
    but it clearly doesn't scale:
    we're not going to write a million statements
    to update a list of a million values.
    We need to use a loop,
    but instead of looping over the values in the list,
    we want to loop over the allowed indices of the list.
    To do this,
    we will rely on a function called <code>range</code>
    which creates a list of the first N integers:
  </p>

<pre>
print range(5)
<span class="out">[0, 1, 2, 3, 4]</span>
</pre>

  <p>
    Once again,
    the values go from 0 to one less than the number given to <code>range</code>,
    which just happens to be exactly the indices of a list of that length.
    Let's try it out:
  </p>

<pre>
data = [1, 4, 2]
indices = range(3)
for i in indices:
    print i, data[i]
<span class="out">0 1
1 4
2 2</span>
</pre>

  <p class="continue">
    then fold the call to <code>range</code> into the loop:
  </p>

<pre>
data = [1, 4, 2]
for i in <span class="highlight">range(3)</span>:
    print i, data[i]
<span class="out">0 1
1 4
2 2</span>
</pre>

  <p>
    This program is correct, but fragile:
    if we add more values to the list,
    Python will still only execute the loop three times,
    so we'll still only print the first three values in the list:
  </p>

<pre>
data = [1, 4, 2<span class="highlight">, 5, 1, 3</span>]
for i in range(3):
    print i, data[i]
<span class="out">0 1
1 4
2 2</span>
</pre>

  <p>
    What we want is for the loop to automatically adjust itself
    based on the length of the list:
  </p>

<pre>
data = [1, 4, 2, 5, 1, 3]
<span class="highlight">data_length = len(data)</span>
for i in range(<span class="highlight">data_length</span>):
    print i, data[i]
<span class="out">0 1
1 4
2 2
3 5
4 1
5 3</span>
</pre>

  <p>
    We can now get rid of the variable <code>data_length</code>
    by putting the call to <code>len(data)</code>
    inside the call to <code>range</code>:
  </p>

<pre>
data = [1, 4, 2, 5, 1, 3]
for i in range(<span class="highlight">len(data)</span>):
    print i, data[i]
<span class="out">0 1
1 4
2 2
3 5
4 1
5 3</span>
</pre>

  <p class="continue">
    Again,
    <code>range(len(data))</code> is like <em>sin(log(x))</em>:
    the inner function is evaluated first,
    and its result becomes the input to the outer function.
    Put together like this,
    they are a common <a href="glossary.html#idiom">idiom</a> in Python,
    i.e.,
    a way of saying something that everyone recognizes and uses.
    When an experienced programmer sees:
  </p>

<pre>
for i in range(len(something)):
</pre>

  <p class="continue">
    what she "hears" is:
  </p>

<pre>
for each legal index of something:
</pre>

  <p>
    The reason this idiom is better than what we started with is that
    there is no duplicated information.
    Instead of having a list of length 3,
    and looping from 0 up to 3,
    we have a list of any length whatever,
    and loop from 0 up to that length.
    In general,
    anything that is repeated two or more times in a program
    will eventually be wrong in at least one.
    Putting it another way,
    any piece of information should appear exactly once in a program,
    so that if it needs to change,
    it only needs to be changed in one place.
  </p>

  <div class="box">
    <h3>Short and Long Variable Names</h3>

    <p>
      We have said several times that programs should use meaningful variable names.
      Are we not violating our own rule by using <code>i</code> as a variable in this program?
      The short answer is "yes", but it's a defensible violation.
      Suppose we re-write our loop as:
    </p>

<pre>
data = [1, 4, 2, 5, 1, 3]
for location in range(len(data)):
    print location, data[location]
</pre>

    <p class="continue">
      The longer name are more meaningful,
      but it also takes longer to read.
      Since the original <code>i</code> is only used for a few lines,
      users will easily be able to keep its meaning in short-term memory
      as long as they need to.
      On balance,
      therefore,
      the short name are better in this case.
    </p>

    <p>
      This is actually a general principle in program design.
      A variable that holds a simple value,
      and is only used in a few adjacent lines of code,
      can (and usually should) have a short name.
      A variable that holds a complex value,
      or one which is used over more than a few lines of code,
      should have a longer name
      in order to optimize the tradeoff between reading speed
      and the limitations of human short-term memory.
    </p>

  </div>

  <p>
    Let's finally go back and double the values in place:
  </p>

<pre>
data = [1, 4, 2, 5, 3, 4, 5]
for i in range(len(data)):
    data[i] = 2 * data[i]
print data
<span class="out">[2, 8, 4, 10, 6, 8, 10]</span>
</pre>

  <div class="box">
    <h3>Left and Right</h3>

    <p>
      Seeing the expression <em>x = 2x</em>,
      most mathematicians would say,
      "Right&mdash;so <em>x</em> is zero."
      Seeing the same expression,
      most programmers would say,
      "Right&mdash;you're doubling the value of <em>x</em>."
      <a href="#f:double_in_place">Figure 20</a> shows
      how that actually works:
    </p>

    <ol>

      <li>
        Python reads the current value of <code>x</code> from memory.
      </li>

      <li>
        It multiplies that value by 2,
        storing the result in a temporary location&hellip;
      </li>

      <li>
        &hellip;and then modifies <code>x</code> to point at the new value.
      </li>

    </ol>

    <figure id="f:double_in_place">
      <img src="python/double_in_place.png" alt="Doubling in Place" />
      <figcaption>Figure 20: Doubling in Place</figcaption>
    </figure>

    <p>
      Now look at what happens when Python execute the statements:
    </p>

<pre>
x = 5
y = x
x = 2 * x
</pre>

    <ol>

      <li>
        The variable <code>x</code> is created,
        and set to point at the value 5
        (<a href="#f:new_values_for_variables">Figure 21</a>).
      </li>

      <li>
        The variable <code>y</code> is created,
        and set to point at the same value.
      </li>

      <li>
        The value 10 (i.e., 2&times;5) is created and stored in a temporary location.
      </li>

      <li>
        <code>x</code> is altered to point at that value.
      </li>

    </ol>

    <figure id="f:new_values_for_variables">
      <img src="python/new_values_for_variables.png" alt="New Values for Variables" />
      <figcaption>Figure 21: New Values for Variables</figcaption>
    </figure>

    <p>
      After these operations are complete,
      <code>y</code> is left pointing at the original value, 5.
      It does <em>not</em> point at the same thing <code>x</code> does any longer,
      and its value is <em>not</em> automatically recalculated
      to keep it twice the value of <code>x</code>.
    </p>

  </div>

  <div class="box">
    <h3>Even More Idiomatic</h3>

    <p>
      There's an even better way to do this job.
      Python allows us to assign values to multiple variables at once:
    </p>

<pre>
red, green, blue = 1.0, 0.5, 0.25
print blue, green, red
<span class="out">0.25 0.5 1.0</span>
</pre>

    <p>
      One thing this lets us do is swap variables' values in a single statement:
    </p>

<pre>
left = 'red
right = 'green'
left, right = right, left
print 'left is now', left, 'and right is now', right
<span class="out">left is now green and right is now red</span>
</pre>

    <p>
      Some functions can also return multiple values&mdash;for example,
      <code>divmod</code> returns the quotient and remainder in a single call:
    </p>

<pre>
q, r = divmod(11, 3)
print 'quotient is', q
print 'remainder is', r
<span class="out">quotient is 3
remainder is 2</span>
</pre>

    <p>
      The <code>enumerate</code> function takes
      anything that a <code>for</code> loop can loop over
      as its parameter.
      It returns pairs,
      each of which contains an index and the value at that index:
    </p>

<pre>
for (i, c) in enumerate('word'):
    print 'index', i, 'character', c
index 0 character w
index 1 character o
index 2 character r
index 3 character d
</pre>

    <p>
      These days,
      most Python programmers would use <code>enumerate</code>
      instead of <code>range(len())</code> to update a list in place:
    </p>

<pre>
data = [1, 4, 2, 5, 1, 3]
for (loc, val) in enumerate(data):
    data[loc] = 2 * val
</pre>

  </div>

  <p>
    We often want to work on sub-ranges of lists,
    such as the first five values
    or everything in the interior
    (i.e.,
    everything except the first and last value).
    Like many other languages,
    Python lets us specify ranges using <a href="glossary.html#slice">slices</a>.
    For example,
    if the variable <code>name</code> holds the string <code>'Darwin'</code>,
    then:
  </p>

  <table>
    <tr>
      <th>Expression</th>
      <th>Value</th>
      <th>Explanation</th>
    </tr>
    <tr>
      <td><code>name[0]</code></td>
      <td><code>'D'</code></td>
      <td>a single element</td>
    </tr>
    <tr>
      <td><code>name[0:3]</code></td>
      <td><code>'Dar'</code></td>
      <td>from index 0 up to (but not including) index 3</td>
    </tr>
    <tr>
      <td><code>name[1:3]</code></td>
      <td><code>'ar'</code></td>
      <td>from index 1 up to (but not including) index 3</td>
    </tr>
    <tr>
      <td><code>name[1:-1]</code></td>
      <td><code>'arwi'</code></td>
      <td>from index 1 up to (but not including) the last character</td>
    </tr>
    <tr>
      <td><code>name[:3]</code></td>
      <td><code>'Dar'</code></td>
      <td>missing start index defaults to the beginning</td>
    </tr>
    <tr>
      <td><code>name[3:]</code></td>
      <td><code>'win'</code></td>
      <td>missing end index defaults to the end</td>
    </tr>
    <tr>
      <td><code>name[:]</code></td>
      <td><code>'Darwin'</code></td>
      <td>combining the two rules above</td>
    </tr>
  </table>

  <div class="box">
    <h3>Up To, But Not Including</h3>

    <p>
      Newcomers often trip over the fact that
      <code>thing[lower:upper]</code> includes the element <code>thing[lower]</code>,
      but not the element <code>thing[upper]</code>.
      There are several reasons for this:
    </p>

    <ol>

      <li>
        We want <code>thing[0:len(thing)]</code> to be all of <code>thing</code>.
      </li>

      <li>
        We want <code>upper-lower</code> to be the number of elements in the slide.
      </li>

      <li>
        We want an easy way to select empty sections,
        which is what <code>thing[index:index]</code> does.
      </li>

    </ol>

  </div>

  <p>
    All the same slicing rules work for lists,
    and for other things that have subscripts.
    Keep in mind that taking a slice creates a new object&mdash;changes
    to the result of slicing do <em>not</em> affect the original:
  </p>

<pre>
vowels = ['a', 'e', 'i', 'o', 'u']
front = vowels[:3] <span class="comment"># front is ['a', 'e', 'i']</span>
print 'vowels is', vowels, 'and front is', front
<span class="out">vowels is ['a', 'e', 'i', 'o', 'u'] and front is ['a', 'e', 'i']</span>
vowels[0] = 'y'
print 'vowels is now', vowels, 'and front is', front
<span class="out">vowels is now ['y', 'e', 'i', 'o', 'u'] and front is ['a', 'e', 'i']</span>
front[0] = 'z'
print 'vowels is still', vowels, 'and front is now', front
<span class="out">vowels is still ['y', 'e', 'i', 'o', 'u'] and front is now ['z', 'e', 'i']</span>
</pre>

  <div class="keypoints">
    <h3>Summary</h3>
    <ul>
      <li>Use <code>[<em>value</em>, <em>value</em>, ...]</code> to create a list of values.</li>
      <li><code>for</code> loops process the elements of a list, in order.</li>
      <li><code>len(<em>list</em>)</code> returns the length of a list.</li>
      <li><code>[]</code> is an empty list with no values.</li>
      <li>Lists are mutable: they can be changed in place.</li>
      <li>Use <code><em>list</em>.append(<em>value</em>)</code> to append something to the end of a list.</li>
      <li>Use <code><em>list</em>[<em>index</em>]</code> to access a list element by location.</li>
      <li>The index of the first element of a list is 0; the index of the last element is <code>len(<em>list</em>)-1</code>.</li>
      <li>Negative indices count backward from the end of the list, so <code><em>list</em>[-1]</code> is the last element.</li>
      <li>Trying to access an element with an out-of-bounds index is an error.</li>
      <li><code>range(<em>number</em>)</code> produces the list of numbers <code>[0, 1, ..., <em>number</em>-1]</code>.</li>
      <li><code>range(len(<em>list</em>))</code> produces the list of legal indices for <code><em>list</em></code>.</li>
    </ul>
  </div>

  <div class="challenges">
    <h3>Challenges</h3>

    <ol>

      <li>
        What does the following program print?
<pre>
total = 0
for v in []:
    total += v
print total
</pre>
      </li>

      <li>
        The expression <code>list('abc')</code> produces the list <code>['a', 'b', 'c']</code>.
        What does the expression <code>str(['a', 'b', 'c'])</code> produce?
      </li>

      <li>
        What is the value of the expression <code>len(['abc', 'def'])</code>?
      </li>

      <li>
        What does this program print, and why?
<pre>
for i in 4:
    print i
</pre>
      </li>

      <li>
        What does this program print?
<pre>
sizes = [0, 1, 1, 2, 2]
total = 0
for s in sizes:
    total += sizes[s]
print total
</pre>
      </li>

      <li>
        Explain the order in which operations occur
        in the final line of the program below.
<pre>
pop = [20, 40, 30]
loc = [1, 2, 1]
print pop[loc[2]]
</pre>
      </li>

      <li>
        What does this program print?
<pre>
genders = list('FMFFMFM')
print [genders[0] + genders[-1]]
</pre>
      </li>

      <li>
        What is the value of the list <code>letters</code>
        before the loop shown below,
        and during each iteration of the loop?
<pre>
letters = list('abcd')
for i in range(len(letters)):
    letters[i] = letters[-i]
</pre>
      </li>

      <li>
        What appears to happen when the program below is run?
        Why?
<pre>
values = list('abcd')
for char in values:
    values.append(char)
</pre>
        (Remember:
        to interrupt a running program, type control-C.)
      </li>

      <li id="a:sorting">
        Lists have a method called <code>sort</code>
        that sorts the values in the list:
<pre>
numbers = [5, 3, 10, -2]
numbers.sort()
print numbers
<span class="out">[-2, 3, 5, 10]</span>
</pre>
        They also have a method called <code>reverse</code>
        that reverse the values in the list:
<pre>
words = ['first', 'second', 'third']
words.reverse()
print words
['third', 'second', 'first']
</pre>
        Given these two methods,
        it would seem natural that:
<pre>
values.sort().reverse()
</pre>
        would put the values in the list into reverse sorted order,
        but it doesn't.
        Why not?
        What actually happens,
        and why does Python do that?
      </li>

      <li>
        What do these lines of code leave in the variables
        <code>first</code> and <code>names</code>
        each time through the loop?
<pre>
names = ['Newton', 'Darwin', 'Turing']
while names:
    first, names = names[0], names[1:]
</pre>
      </li>

    </ol>

  </div>

</section>

<section id="s:nesting">
  <h2>Nesting</h2>

  <div class="understand">
    <h3>Learning Objectives</h3>
    <ul>
      <li>Trace the execution of a nested loop.</li>
      <li>Give examples of the kinds of problems that nested loops should be used to solve.</li>
      <li>Construct nested loops with independent ranges.</li>
      <li>Construct nested loops in which the range of the inner loop depends on the state of the outer loop, and give an example showing when this is useful.</li>
      <li>Explain what nested lists are, and their relationship to nested loops.</li>
      <li>Draw data structure diagrams corresponding to nested lists, and write nested lists that correspond to given diagrams.</li>
      <li>Explain what happens when an expression like "<code>table[3][2]</code>" is evaluated.</li>
    </ul>
    <p>
      <span class="duration">30 minutes</span>.
    </p>
  </div>

  <p>
    Going back to Aurora's data cleanup problem,
    suppose that the scores in each data set
    are always supposed to ramp upward:
    if we ever see a value that's less than the value before it,
    something's gone wrong.
    Here's a program that tries to check that
    (again, using inline data instead of reading from a file
    to make the sample code clearer):
  </p>

<pre>
data = [1, 2, 2, 3, 4, 4, 5, 6, 5, 6, 7, 7, 8]
for i in range(len(data)):
    if data[i] &lt; data[i-1]:
        print "failure at index:", i
    i = i + 1
<span class="out">failure at index: 0
failure at index: 8</span>
</pre>

  <p class="continue">
    Whoops&mdash;why is it telling us that there's a failure at index 0?
    Take a close look at the third line:
    when <code>i</code> is 0,
    it compares <code>data[0]</code> to <code>data[-1]</code>,
    but as we said earlier,
    index -1 means the last element of the list.
    We need to make sure that we only compare the <em>second</em> and higher elements
    to the ones before them:
  </p>
    
<pre>
data = [1, 2, 2, 3, 4, 4, 5, 6, 5, 6, 7, 7, 8]
for i in <span class="highlight">range(1, len(data))</span>:
    if data[i] &lt; data[i-1]:
        print "failure at index:", i
    i = i + 1
<span class="out">failure at index: 8</span>
</pre>

  <p class="continue">
    This program uses the fact that <code>range(low, high)</code>
    generates the values from <code>low</code> to <code>high-1</code>.
    We can also use <code>range(low, high, stride)</code>
    to generate values that are spaced <code>stride</code> apart,
    so that <code>range(5, 20, 3)</code> produces
    <code>[5, 8, 11, 14, 17]</code>.
    (Remember,
    <code>range</code> goes up to but not including the top value.)
  </p>

  <p>
    Now suppose that Aurora needs to add up successive triples of her data
    to time-average the scores.
    Our first try steps through the indices three at a time:
  </p>

<pre>
data = [1, 2, 2, 3, 4, 4, 5, 6, 5, 6, 7, 7, 8]
result = []
for i in range(0, len(data), 3):
    sum = data[i] + data[i+1] + data[i+2]
    result.append(sum)
print "grouped data:", result
<span class="err">Traceback (most recent call last):
  File "group-by-threes-fails.py", line 6, in &lt;module&gt;
    sum = data[i] + data[i+1] + data[i+2]
IndexError: list index out of range</span>
</pre>

  <p class="continue">
    It's not immediately obvious what's wrong,
    but a bit of experimenting with shorter lists turns up the problem.
    If the number of elements in the list isn't exactly divisible by 3,
    our program is going to try to reach past the end of the list.
    For example,
    if we have a 4-element list,
    we will add up the values at locations 0, 1, and 2,
    then try to add up the values at locations 3, 4, and 5,
    but locations 4 and 5 aren't valid
    (<a href="#f:a_step_too_far">Figure 22</a>).
  </p>

  <figure id="f:a_step_too_far">
    <img src="python/a_step_too_far.png" alt="A Step Too Far" />
    <figcaption>Figure 22: A Step Too Far</figcaption>
  </figure>

  <p>
    How we should fix this is a question for a scientist
    (or at least a statistician):
    should we throw away the top few values if there aren't enough to make another triple,
    or add up as many as there are and hope for the best?
    Let's assume the latter for now:
  </p>

<pre>
data = [1, 2, 2, 3, 4, 4, 5, 6, 5, 6, 7, 7, 8]
result = []
for i in range(0, len(data), 3):
    sum = data[i]
    if (i+1) &lt; len(data):
        sum += data[i+1]
    if (i+2) &lt; len(data):
        sum += data[i+2]
    result.append(sum)
print "grouped data:", result
<span class="out">grouped data: [5, 11, 16, 20, 8]</span>
</pre>

  <p>
    This works,
    but it feels clumsy:
    if we were adding up in groups of ten,
    we'd have a lot of <code>if</code> statements.
    We need a better way.
  </p>

  <p>
    Our first step toward that better way looks like this:
  </p>

<pre>
vowels = "ae"
consonants = "dnx"
for v in vowels:
    for c in consonants:
        print v + c
<span class="out">ad
an
ax
ed
en
ex</span>
</pre>

  <p>
    <a href="#f:nested_flowchart">Figure 23</a> shows
    what's going on in this <a href="glossary.html#nested-loop">nested loop</a>.
    Each time the <a href="glossary.html#outer-loop">outer loop</a> executes,
    Python runs the entire <a href="glossary.html#inner-loop">inner loop</a>.
    The innermost <code>print</code> statement therefore executes six times,
    because the outer loop runs twice,
    and the inner loop runs three times for each of those iterations.
  </p>
  
  <figure id="f:nested_flowchart">
    <img src="python/nested_flowchart.png" alt="Nested Loops" />
    <figcaption>Figure 23: Nested Loops</figcaption>
  </figure>
  
  <p>
    In this case,
    both loops execute a fixed number of times,
    but that doesn't have to be the case.
    It's common,
    for example,
    to set the number of times an inner loop runs
    based on the current value of the outer loop's counter:
  </p>

<pre>
for i in range(4):
    for j in range(i):
        print i, j
<span class="out">1 0
2 0
2 1
3 0
3 1
3 2</span>
</pre>

  <figure id="f:triangle_nested_loop">
    <img src="python/triangle_nested_loop.png" alt="Nested Loop Execution" />
    <figcaption>Figure 24: Nested Loop Execution</figcaption>
  </figure>
  
  <p>
    <a href="#f:triangle_nested_loop">Figure 24</a> traces
    this little program's execution.
    The first time through,
    <code>i</code> is 0.
    Since <code>range(0)</code> is the empty list <code>[]</code>,
    the inner loop is effectively:
  </p>

<pre>
    for j in []:
        print i, j
</pre>

  <p class="continue">
    so it doesn't execute at all.
    The next time,
    though,
    when <code>i</code> is 1,
    the inner loop is effectively:
  </p>

<pre>
    for j in [0]:
        print i, j
</pre>

  <p class="continue">
    so the innermost <code>print</code> statement is executed once
    with <code>i</code> equal to 1 and <code>j</code> equal to 0.
    The third time around the outer loop,
    <code>i</code> is 2,
    so <code>range(i)</code> is <code>[0, 1]</code>.
    This makes the inner loop execute twice,
    and so on.
  </p>

  <p>
    Now let's go back to Aurora's data smoothing.
    We can step through the data in threes like this:
  </p>

<pre>
for i in range(0, len(data), 3):
    ...body of loop...
</pre>

  <p>
    If we know that the length of a list is an exact multiple of three,
    we can always loop from index <code>i</code>
    up to (but not including) <code>i+3</code>:
  </p>

<pre>
for i in range(0, len(data), 3):
    for j in range(i, i+3):
        ...body of loop...
</pre>

  <p>
    If the list isn't long enough for us to do this,
    we want to go as high as
    the least of <code>i+3</code> and <code>len(data)</code>.
    Using Python's built-in <code>min</code> function,
    this is:
  </p>
  
<pre>
min(i+3, len(data))
</pre>

  <p class="continue">
    so we can write our inner loop as:
  </p>

<pre>
for i in range(0, len(data), 3):
    upper_bound = min(i+3, len(data))
    for j in range(i, upper_bound):
        ...smooth data...
</pre>

  <p>
    Here's the completed data smoothing program:
  </p>

<pre>
data = [1, 2, 2, 3, 4, 4, 5, 6, 5, 6, 7, 7, 8]
result = []
for i in range(0, len(data), 3):
    upper_bound = min(i+3, len(data))
    sum = 0
    for j in range(i, upper_bound):
        sum += data[j]
    result.append(sum)
print "grouped data:", result
<span class="out">grouped data: [5, 11, 16, 20, 8]</span>
</pre>

  <p>
    This program works,
    but there's room for improvement.
    If we ever want to change the smoothing interval,
    we have to replace the number 3 in two places.
    Let's put that value in a variable <code>width</code>
    to reduce the odds of us updating it one place
    and not the other:
  </p>

<pre>
data = [1, 2, 2, 3, 4, 4, 5, 6, 5, 6, 7, 7, 8]
<span class="highlight">width = 3</span>
result = []
for i in range(0, len(data), <span class="highlight">width</span>):
    upper_bound = min(i+<span class="highlight">width</span>, len(data))
    sum = 0
    for j in range(i, upper_bound):
        sum += data[j]
    result.append(sum)
print "grouped data:", result
<span class="out">grouped data: [5, 11, 16, 20, 8]</span>
</pre>

  <p>
    This change also tells readers
    (including our future selves)
    that the stride in the outer loop,
    and the offset used to calculate <code>upper_bound</code>,
    are always supposed to be the same.
    That's yet another reason to use variables with meaningful names:
    it tells people when values are intentionally the same,
    as opposed to accidentally the same.
  </p>

  <p>
    One of the hearing tests Aurora uses
    asks people to point out where a sound is coming from.
    The data files contain lists of XY coordinates:
  </p>

<pre>
4.2 1.7
3.1 5.0
0.8 6.1
... ...
</pre>

  <p>
    She has roughly 100 such files,
    and one more file (in the same format)
    that holds the actual location of each sound.
    She wants to calculate the average distance between
    each actual and reported location.
  </p>
  
  <p>
    The first step is to read a file
    and extract the XY values on each line:
  </p>

<pre>
x_values = []
y_values = []
reader = open('data.txt', 'r')
for line in reader:
    x, y = line.split()
    x = float(x)
    x_values.append(x)
    y = float(y)
    y_values.append(y)
reader.close()
</pre>

  <p>
    We can make this a bit more readable
    by combining the calls to <code>float</code> and <code>append</code>:
  </p>

<pre>
x_values = []
y_values = []
reader = open('data.txt', 'r')
for line in reader:
    x, y = line.split()
    x_values.append(float(x))
    y_values.append(float(y))
reader.close()
</pre>

  <p class="continue">
    but the basic approach is still unwieldy.
    What we really want is a list of XY coordinates,
    not two parallel lists of X and Y coordinates.
    We can easily create what we want
    using <a id="g:nested-list" href="glossary.html#nested-list">nested list</a>.
    <a href="#f:simple_nested_list">Figure 25</a> shows
    what we're going to do,
    and the code below shows
    how we would create a nested list by hand
    for specific XY values:
  </p>

<pre>
&gt;&gt;&gt; <span class="in">coordinates = [ [4.2, 1.7], [3.1, 5.0], [0.8, 6.1] ]</span>
&gt;&gt;&gt; <span class="in">print coordinates[0]</span>
<span class="out">[4.2, 1.7]</span>
&gt;&gt;&gt; <span class="in">print coordinates[0][1]</span>
<span class="out">1.7</span>
</pre>

  <figure id="f:simple_nested_list">
    <img src="python/simple_nested_list.py" alt="A Simple Nested List" />
    <figcaption>Figure 25: A Simple Nested List</figcaption>
  </figure>

  <p>
    This isn't as complicated as it first looks.
    Just as a variable can point at any object,
    so too can any entry in a list.
    And since a list is just an object in memory,
    one list can contain a <a href="glossary.html#reference">reference</a> to another.
    This is why <code>coordinates[0]</code> is <code>[4.2, 1.7]</code>:
    the first entry of the outer list is
    a reference to an entire sublist.
    We could just as easily write:
  </p>

<pre>
&gt;&gt;&gt; <span class="in">temp = coordinates[0]</span>
&gt;&gt;&gt; <span class="in">print temp</span>
<span class="out">[4.2, 1.7]</span>
</pre>

  <p class="continue">
    And since <code>x[1]</code> is 4.2,
    so too is <code>coordinates[0][1]</code>:
    the first subscript select the sublist,
    while the second selects an element from that sublist
    (<a href="#f:indexing_nested_lists">Figure 26</a>).
  </p>
  
  <figure id="f:indexing_nested_lists">
    <img src="python/indexing_nested_lists.png" alt="Indexing Nested Lists" />
    <figcaption>Figure 26: Indexing Nested Lists</figcaption>
  </figure>
  
  <p>
    It's important to understand that the inner list isn't "in" the outer list:
    what the outer list contains is a reference to the inner one.
    We'll return to this <a href="#s:alias">later</a>.
  </p>
  
  <p>
    With nested lists in hand,
    it's straightforward to create a list of coordinate pairs:
  </p>

<pre>
values = []
reader = open('data.txt', 'r')
for line in reader:
    x, y = line.split()
    coord = [float(x), float(y)]
    values.append(coord)
reader.close()
</pre>

  <p class="continue">
    Each time the loop executes,
    this program splits the line into two strings,
    creates a new two-element list containing the corresponding numbers,
    and then appends that list to <code>values</code>.
    <a href="#f:growing_nested_list">Figure 27</a> shows how
    the <code>values</code> list grows as successive pairs of numbers are read.
  </p>
  
  <figure id="f:growing_nested_list">
    <img src="python/growing_nested_list.png" alt="Growing a Nested List" />
    <figcaption>Figure 27: Growing a Nested List</figcaption>
  </figure>

  <p>
    Now suppose that we have two lists of coordinates,
    and we want to find the average distance between corresponding coordinates.
    For the moment,
    we'll just create two representative lists in memory
    and find their average difference:
  </p>
  
<pre>
expected = [ [4.0, 2.0], [3.0, 5.0], [1.0, 6.0] ]
actual   = [ [4.2, 1.7], [3.1, 5.0], [0.8, 6.1] ]
x_diff, y_diff = 0.0,  0.0
for i in range(len(actual)):
    e = expected[i]
    a = actual[i]
    x_diff += abs(e[0] - a[0])
    y_diff += abs(e[1] - a[1])
print "average errors:", x_diff / len(actual), y_diff / len(actual)
<span class="out">average errors: 0.166666666667 0.133333333333</span>
</pre>

  <p class="continue">
    The first two lines set up our data:
    in a real program,
    we'd read values from files.
    The next line initializes <code>x_diff</code> and <code>y_diff</code>,
    which will hold the errors in X and Y respectively.
    Each iteration of the loop
    sets <code>a</code> and <code>e</code> to point at
    corresponding elements of the vectors.
    <code>a[0]</code> is then the X coordinate of an actual point,
    while <code>e[0]</code> is the X coordinate of the corresponding expected point,
    so <code>abs(e[0] - a[0])</code> is the difference,
    which we add to <code>x_diff</code> using <code>+=</code>.
  </p>
  
  <div class="box">
    <h3>Choosing Better Test Cases</h3>
    
    <p>
      How can we be sure that the code shown above is working correctly?
      Putting it another way,
      what test data should we use so that we can tell
      if the answer is right or not?
      One better set of inputs would be:
    </p>

<pre>
expected = [ [0.0, 0.0], [0.0, 0.0], [0.0, 0.0] ]
actual   = [ [1.0, 2.0], [1.0, 4.0], [1.0, 6.0] ]
</pre>

    <p>
      It's clear in this case that the right answers are
      1.0 and 4.0 for X and Y.
      We'll discuss the choice of test cases in more detail
      in a <a href="quality.html">later lesson</a>.
    </p>
  </div>
  
  <p>
    Nested lists have a close relationship to nested loops.
    For example,
    suppose that Aurora has a list with one entry for each test subject,
    and that each of those entries contains several test scores:
  </p>
  
<pre>
scores = [ [1.5, 2.2, 1.7, 1.6],
           [2.8, 3.5, 3.6, 1.6],
           [1.3, 1.1, 1.7, 1.4] ]
</pre>

  <p>
    To calculate the average of all these scores,
    she needs to loop over the outer list
    (to cover each test subject),
    and also to loop over every element of each entry
    (to cover each subject's scores):
  </p>

<pre>
total = 0.0
number = 0
for entry in scores:
    for value in entry:
        total += value
        number += 1
average = total / number
print average
<span class="out">2.0</span>
</pre>

  <p>
    Since the data structure is a list of lists,
    we need to use a loop within a loop.
    If we want to average the scores per subject,
    we would only need to make a small change to this code:
  </p>

<pre>
for entry in scores:
<span class="highlight">    total = 0.0
    number = 0</span>
    for value in entry:
        total += value
        number += 1
<span class="highlight">    average = total / number
    print average</span>
<span class="out">1.75
2.875
1.375</span>
</pre>

  <p class="continue">
    The important change here is that
    <code>total</code> and <code>number</code> are re-initialized
    and then reported
    <em>inside</em> the main loop,
    so that each subject's scores are calculated and printed separately.
  </p>
  
  <p>
    If we want to average corresponding scores for each subject,
    i.e.,
    get the average of each subject's zeroth score,
    then the average of their first score,
    and so on,
    the code suddenly becomes more complex.
    The reason is that
    while <code>scores[1]</code> is "all the scores associated with subject 1",
    there is no equally simple expression meaning
    "the first score associated with all subjects".
    (We will see a structure that allows us to do this <a href="numpy.html">later</a>.)
  </p>
  
  <p>
    Here's the code that averages corresponding scores across subjects:
  </p>

<pre id="a:average_scores">
scores = [ [1.5, 2.2, 1.7, 1.6],
           [2.8, 3.5, 3.6, 1.6],
           [1.3, 1.1, 1.7, 1.4] ]
for loc in range(len(scores[0])):
    total = 0.0
    number = 0
    for entry in scores:
        total += entry[loc]
        number += 1
    average = total / number
    print average
<span class="out">1.86666666667
2.26666666667
2.33333333333
1.53333333333</span>
</pre>

  <p class="continue">
    We will take a closer look at how and why it works in the challenges below.
  </p>
  
  <div class="keypoints">
    <h3>Summary</h3>
    <ul>
      <li><code>range(<em>start</em>, <em>end</em>)</code> creates the list of numbers from <code><em>start</em></code> up to, but not including, <code><em>end</em></code>.</li>
      <li><code>range(<em>start</em>, <em>end</em>, <em>stride</em>)</code> creates the list of numbers from <code><em>start</em></code> up to <code><em>end</em></code> in steps of <code><em>stride</em></code>.</li>
      <li>Use nested loops to do things for combinations of things.</li>
      <li>Make the range of the inner loop depend on the state of the outer loop to automatically adjust how much data is processed.</li>
      <li>Use <code>min(...)</code> and <code>max(...)</code> to find the minimum and maximum of any number of values.</li>
      <li>Use nested lists to store multi-dimensional data or values that have regular internal structure (such as XYZ coordinates).</li>
      <li>Use <code><em>list_of_lists</em>[<em>first</em>]</code> to access an entire sub-list.</li>
      <li>Use <code><em>list_of_lists</em>[<em>first</em>][<em>second</em>]</code> to access a particular element of a sub-list.</li>
      <li>Use nested loops to process nested lists.</li>
    </ul>
  </div>

  <div class="challenges">
    <h3>Challenges</h3>
    
    <ol>
      
      <li>
        What is the final value of <code>total</code> in this program?
<pre>
total = 0
for i in range(2):
    for j in range(-i):
        total += j
print total
</pre>
      </li>

      <li>
        How many different numbers can be put in the blank below so that the value of the expression is 12?
<pre>
sum(range(1, ____, 3))
</pre>
        <ol class="choices">
          <li>Only 1</li>
          <li>2 different values</li>
          <li>3 different values</li>
          <li>The expression's value can never be 12</li>
        </ol>
      </li>
      
      <li>
        How many different numbers can be put in the blank below so that the value of the expression is 12?
<pre>
sum(range(1, 3, ____))
</pre>
        <ol class="choices">
          <li>Only 1</li>
          <li>2 different values</li>
          <li>3 different values</li>
          <li>The expression's value can never be 12</li>
        </ol>
      </li>
      
      <li>
        Fill in the blanks so that this accurately describes
        the fragment of code given below.
        <blockquote>
          <code>final_mass</code> starts at 0,
          which is less than any of the values in ________,
          so <code>________(final_mass, inner)</code> is always 0,
          so <code>max(outer, min(...))</code> is always just ________,
          so the final value is just the last value of <code>outer_masses</code>.
        </blockquote>
<pre>
outer_masses = [10, 20, 30]
inner_masses = [1, 2, 3]
final = 0
for outer in outer_masses:
    for inner in inner_masses:
        final = max(outer, min(final, inner))
print final
</pre>
      </li>
        
      <li>
        Trace the values of <code>loc</code>, <code>total</code>,
        <code>number</code>, <code>entry</code>, and <code>average</code>
        for each iteration of the loop in the 
        <a href="#a:average_scores">final code sample</a>
        in above.
        Why does the loop use the expression <code>range(len(scores[0]))</code>?
      </li>
        
      <li>
        A colleague has defined a 3&times;3 matrix like this:
<pre>
tensor = [ [0, 1, 2],
           [3, 4, 5],
           [6, 7, 8] ]
</pre>
        She then tries to transpose it like this:
<pre>
transpose = []
for i in [-1, -2, -3]:
    transpose.append(tensor[i])
</pre>
        What is the actual result?
      </li>

      <li>
        Fill in the blanks so that this program produces the output shown.
<pre>
final = []
for i in range(______):
    final.append(range(______))
print final
<span class="out">[[], [0], [0, 1]]</span>
</pre>
      </li>
      
      <li>
        What does this program do?
<pre>
alpha = [ [1, 2], [3, 4] ]
beta = [ [10, 20], [30, 40] ]
result = [ [0, 0], [0, 0] ]
for i in range(2):
    for j in range(2):
        for k in range(2):
            result[i][j] += alpha[i][k] * beta[k][j]
</pre>
        <ol>
          <li>Calculate the sums of the rows and columns of <code>alpha</code> and <code>beta</code>.</li>
          <li>Calculate the products of the elements the rows and columns of <code>alpha</code> and <code>beta</code>.</li>
          <li>Calculate the matrix product <code>alpha</code>&times;<code>beta</code></li>
          <li>Calculate the matrix product <code>beta</code>&times;<code>alpha</code></li>
        </ol>
      </li>
      
    </ol>

  </div>

</section>

<section id="s:func">
  <h2>Functions</h2>

  <div class="understand">
    <h3>Learning Objectives</h3>
    <ul>
      <li>Explain the benefits of breaking a program up into functions.</li>
      <li>Define a function of a single parameter.</li>
      <li>Explain what a call stack is, what a variable's scope is, and how the two concepts are related.</li>
      <li>Trace values as they are passed into and returned by functions.</li>
      <li>Compose function calls.</li>
    </ul>
    <p>
      <span class="duration">20 minutes</span>.
    </p>
  </div>

  <p>
    We have used functions several times in this lesson.
    It is now time to see how to create new functions ourselves.
    A function's job is to bundle several steps together
    so that they can be used as if they were a single command.
    The simplest possible function is one that
    produces the same value over and over again:
  </p>
  
<pre>
def zero():
    return 0
</pre>

  <p class="continue">
    We create functions in Python using the keyword <code>def</code>,
    followed by the function's name.
    The empty parentheses signal that the function doesn't take any inputs&mdash;we'll
    see functions that do in a moment&mdash;and the colon signals
    the start of a new block of code.
    The body of the function is then indented,
    just like the body of a loop.
    The keyword <code>return</code> then specifies
    the value that the function produces.
  </p>

  <p>
    Defining a function tells the computer how to do something,
    but doesn't actually do whatever that "something" is.
    To do that,
    we need to call the function:
  </p>

<pre>
result = zero()
print "zero produces", result
<span class="out">zero produces 0</span>
</pre>

  <p>
    When Python sees the call <code>zero()</code>
    it sets aside whatever it was doing,
    goes and does whatever the function <code>zero</code> tells it to do,
    and then continues with its original calculation using the function's result.
    In this case,
    the overall effect is to assign 0 to <code>result</code>,
    which is then printed.
  </p>

  <p>
    Functions that always produce the same value aren't particularly useful,
    so most functions take input values,
    or <a href="glossary.html#parameter">parameters</a>,
    and use them in their calculations.
    A parameter is a variable that is given a new value
    each time the function is called.
    For example,
    the function <code>fahr_to_kelvin</code> defined below
    has a single parameter <code>temp</code>,
    which is assigned the value 32 the first time it is called,
    and the value 212 the second time:
  </p>

<pre>
def fahr_to_kelvin(temp):
    return ((temp - 32.0) * 5.0/9.0) + 273.15

print 'water freezes at', fahr_to_kelvin(32)
print 'water boils at', fahr_to_kelvin(212)
<span class="out">water freezes at 273.15
water boils at 373.15</span>
</pre>

  <p>
    The functions we have seen so far have had only one parameter.
    When we define a function,
    however,
    we can give it any number of parameters.
    When the function is called and a new stack frame is created,
    a new variable is defined for each of those parameters,
    and the actual values given by the caller are assigned to the parameters in order from left to right.
    For example,
    if we define <code>average3</code> to calculate the average of three numbers:
  </p>

<pre>
def average3(a, b, c):
    return (a + b + c) / 3.0
</pre>

  <p class="continue">
    and call it like this:
  </p>

<pre>
x = 2
y = 2
z = 5
print average3(x, y, z)
<span class="out">3.0</span>
</pre>

  <p class="continue">
    then just before the function returns,
    the program's memory is as shown in <a href="#f:memory_before_return">Figure 28</a>.
  </p>

  <figure id="f:memory_before_return">
    <img src="python/memory_before_return.png" alt="State of Memory Before Function Return" />
    <figcaption>Figure 28: State of Memory Before Function Return</figcaption>
  </figure>

  <p>
    Calling this function with the wrong number of values is an error:
  </p>

<pre>
print average3(1, 5)
<span class="err">Traceback (most recent call last):
  File "python/average-3-wrong.py", line 4, in &lt;module&gt;
    print 1, 5, '=&gt;', average3(1, 5)
TypeError: average3() takes exactly 3 arguments (2 given)</span>
</pre>

  <p class="continue" id="a:default-value">
    This is only sensible:
    if we pass two values to <code>average3</code>,
    Python has no way of knowing what third value to use.
    We can create functions that have
    <a href="glossary.html#default-value">default values</a> for parameters
    simply by providing those values when the function is defined:
  </p>

<pre>
def average3(a=0.0, b=0.0, c=0.0):
    return (a + b + c) / 3.0
</pre>

  <p>
    The meaning is straightforward:
    if the caller doesn't tell the function what value to use for <code>a</code>,
    the function should use 0.0,
    and similarly for the other parameters.
    We can now call our function in four different ways:
  </p>

  <table>
    <tr>
      <th>Call</th>
      <th><code>a</code></th>
      <th><code>b</code></th>
      <th><code>c</code></th>
      <th>Result</th>
    </tr>
    <tr>
      <td><code>average3()</code></td>
      <td>0.0</td>
      <td>0.0</td>
      <td>0.0</td>
      <td>0.0</td>
    </tr>
    <tr>
      <td><code>average3(3.0)</code></td>
      <td>3.0</td>
      <td>0.0</td>
      <td>0.0</td>
      <td>1.0</td>
    </tr>
    <tr>
      <td><code>average3(3.0, 6.0)</code></td>
      <td>3.0</td>
      <td>6.0</td>
      <td>0.0</td>
      <td>3.0</td>
    </tr>
    <tr>
      <td><code>average3(3.0, 6.0, 9.0)</code></td>
      <td>3.0</td>
      <td>6.0</td>
      <td>9.0</td>
      <td>6.0</td>
    </tr>
  </table>

  <p class="continue">
    We still can't call this function with more than three parameters,
    though,
    since once again Python wouldn't know where to put the fourth and higher.
  </p>

  <p>
    One restriction on functions with default values
    is that all of the parameters that have default values must come <em>after</em>
    all of the parameters that don't.
    To see why,
    imagine we were allowed to mix defaulting and non-defaulting parameters like this:
  </p>

<pre>
def average(<span class="highlight">start=None, values, end=None</span>):
    if start is None:
        start = 0
    if end is None:
        end = len(values)
    result = 0.0
    i = start
    while i &lt; end:
        result += values[i]
        i += 1
    return result / (end - start)
</pre>

  <p>
    If we call the function with just one parameter,
    it's pretty clear that its value has to be assigned to <code>values</code>.
    But what should Python do if the function is called with two parameters,
    like <code>average([1.0, 2.0, 5.0], 1)</code>?
    Should it use the provided values for the first and second parameters,
    and the default for the third?
    Or should it use the first parameter's default,
    and assign the given values to the second and third?
    We know what we want,
    but Python doesn't:
    remember, it can't infer anything from variables' names.
    We could define some sort of rule to tell it what to do in this case,
    but it's simpler and safer to disallow the problem in the first place.
  </p>

  <div class="box">
    <h3>How Older Languages Do It</h3>

    <p>
      If the language we are using doesn't let us define default parameter values,
      we would have to write two functions:
    </p>

<pre>
def is_close_diff(left, right, difference):
    return abs(left - right) &lt; difference

def is_close_default(left, right):
    return is_close_diff(left, right, 1.0e-6)
</pre>

    <p class="continue" id="a:wrapper">
      This is a common <a href="glossary.html#design-pattern">design pattern</a>
      in many programming languages.
      We start by defining the most general function we can think of&mdash;in
      this case, one that uses a user-specified difference&mdash;and
      then write <a href="glossary.html#wrapper-function">wrapper functions</a>
      as easy-to-use shortcuts for common cases.
      These wrapper functions do <em>not</em> duplicate what's in the general function;
      instead, they call it,
      filling in some or all of the parameters it requires with sensible defaults.
    </p>

    <p>
      The problem with this approach is that
      we have to come up with names for all those little functions.
      Default parameters were invented to solve this problem:
      instead of writing lots of functions,
      we write one,
      and provide default values for some or all of its parameters.
    </p>
  </div>

  <div class="keypoints">
    <h3>Summary</h3>
    <ul>
      <li>Define a function using <code>def <em>name</em>(...)</code></li>
      <li>The body of a function must be indented.</li>
      <li>Use <code><em>name</em>(...)</code> to call a function.</li>
      <li>Use <code>return</code> to return a value from a function.</li>
      <li>The values passed into a function are assigned to its parameters in left-to-right order.</li>
      <li>Function calls are recorded on a call stack.</li>
      <li>Every function call creates a new stack frame.</li>
      <li>The variables in a stack frame are discarded when the function call completes.</li>
      <li>Grouping operations in functions makes code easier to understand and re-use.</li>
    </ul>
  </div>

  <div class="challenges">
    <h3>Challenges</h3>

    <ol>

      <li>
        Draw memory diagrams showing what is on the call stack
        each time it changes in the program below:
<pre>
def double(x):
    return 2 * x

def trim(lower, value, upper):
    if value &lt; lower:
        result = lower
    elif value &gt; upper:
        result = upper
    else:
        result = value
    return value

print double(trim(0, 15, double(5)))
</pre>
      </li>

      <li>
        A colleague of yours wants to apply <code>double</code> and <code>trim</code>
        to every value in a list.
        Her function <code>squish</code> is shown below:
<pre>
def squish(numbers, lower, upper):
    result = []
    for n in numbers:
        result.append(double(trim(lower, n, upper)))
    return result

print squish([-3, 5], 0, 10)
</pre>
        You notice that while <code>trim</code> takes
        the lower bound, the value to be trimmed, and the upper bound as parameters,
        this function takes the values to be trimmed first,
        followed by the lower and upper bounds.
        Explain why this is bad style,
        and what you would do to fix it.
      </li>

      <li>
        This program reads files that contain comments (starting with '#'),
        blank lines (containing only whitespace),
        and words (separated by spaces),
        and prints the longest word found:
<pre>
import sys

longest = ''
for line in sys.stdin:
    line = line.strip().split('#')[0]
    if line:
        words = line.split()
        for w in words:
            if len(w) &gt; len(longest):
                longest = w
print longest
</pre>
        Rewrite it to use two functions call
        <code>get_words</code> and <code>keep_longest</code>
        so that the main program looks like:
<pre>
import sys

longest = ''
for line in sys.stdin:
    words = get_words(line)
    for w in words:
        longest = keep_longest(longest, w)
print longest
</pre>
      </li>

    </ol>

  </div>

</section>

<section id="s:scope">
  <h2>Scope</h2>

  <div class="understand">
    <h3>Learning Objectives</h3>
    <ul>
      <li>Explain what global scope is, and how it differs from local scope.</li>
      <li>Explain why functions shouldn't pass information through global variables.</li>
    </ul>
    <p>
      <span class="duration">20 minutes</span>.
    </p>
  </div>

  <p>
    If one function is good,
    two must be better.
    Let's write a function to convert Kelvin to Celsius:
  </p>

<pre>
def kelvin_to_celsius(temp):
    return temp - 273.15

print 'absolute zero is', kelvin_to_celsius(0)
<span class="out">absolute zero is -273.15</span>
</pre>

  <p class="continue">
    Instead of writing a third equation to translate Fahrenheit into Celsius,
    we can now combine the two functions we have
    to do the required calculation:
  </p>

<pre>
def fahr_to_celsius(temp):
    degrees_k = fahr_to_kelvin(temp)
    return kelvin_to_celsius(degrees_k)

temp_f = 32.0
temp_c = fahr_to_celsius(temp_f)
print 'water freezes at', temp_c
<span class="out">water freezes at 0.0</span>
</pre>

  <p id="a:call-stack">
    To really understand what happens when we combine functions this way,
    we need to understand the <a href="glossary.html#call-stack">function call stack</a>.
    Here are the function definitions once again:
  </p>

<pre>
def fahr_to_kelvin(temp):
    return ((temp - 32.0) * 5.0/9.0) + 273.15

def kelvin_to_celsius(temp):
    return temp - 273.15

def fahr_to_celsius(temp):
    degrees_k = fahr_to_kelvin(temp)
    return kelvin_to_celsius(degrees_k)
</pre>

  <p class="continue">
    All three functions have a parameter called <code>temp</code>;
    how does Python keep them straight?
    Let's call one of the functions
    and print <code>temp</code>'s value after the call:
  </p>

<pre>
def kelvin_to_celsius(temp):
    return temp - 273.15

absolute_zero = 0.0
result = kelvin_to_celsius(absolute_zero)
print 'temp after function call is', temp
<span class="out">temp after function call is</span>
<span class="err">Traceback (most recent call last):
  File "python/print-temp.py", line 5, in &lt;module&gt;
    print 'temp after function call is', temp
NameError: name 'temp' is not defined</span>
</pre>

  <p class="continue">
    Why isn't <code>temp</code> defined?
    And if it isn't,
    why did we get an error for the last line of our program,
    rather than when we used <code>temp</code> inside <code>kelvin_to_celsius</code>?
  </p>

  <p>
    The answer is that
    Python doesn't actually create a variable called <code>temp</code>
    when the function is defined.
    Instead,
    it makes a note that it is supposed to create such a variable
    when <code>kelvin_to_celsius</code> is called,
    and then throw it away when the function finishes executing.
  </p>

  <p>
    This is easier to explain with pictures.
    After executing line 4 of our program,
    Python knows that <code>kelvin_to_celsius</code> refers to a function,
    and that <code>absolute_zero</code> refers to the value 0.0
    (<a href="#f:func_call_step_1">Figure 29</a>):
  </p>

  <figure id="f:func_call_step_1">
    <img src="python/func_call_step_1.png" alt="First Step of Function Call" />
    <figcaption>Figure 29: First Step of Function Call</figcaption>
  </figure>

  <p>
    The first thing it does when it executes line 5 is call <code>kelvin_to_celsius</code>.
    To do this,
    it creates a new storage area for variables
    and puts it on top of the one that holds
    <code>kelvin_to_celsius</code> and <code>absolute_zero</code>.
    Since the function has one parameter,
    <code>temp</code>,
    Python creates a variable with that name in the new storage area
    and gives it the value 0.0
    (since that's what we passed in when we called the function).
    The program's memory is now in the state shown in
    <a href="#f:func_call_step_2">Figure 30</a>:
  </p>

  <figure id="f:func_call_step_2">
    <img src="python/func_call_step_2.png" alt="Second Step of Function Call" />
    <figcaption>Figure 30: Second Step of Function Call</figcaption>
  </figure>

  <p>
    This variable storage area is called
    a <a href="glossary.html#stack-frame">stack frame</a>:
    stack, because it is stacked on top of the previous area,
    and frame, because&hellip;well, just because.
    Every time a function is called&mdash;any function&mdash;Python
    creates a new frame to holds the function's variables
    and puts it on top of the stack.
    While it is executing that function's code,
    Python looks in the top stack frame to find variables;
    when the function returns,
    Python discards the top stack frame
    and starts using the one underneath it again.
  </p>

  <p>
    Since the rest of the statement on line 5
    (the line containing the function call)
    assigns the function's value to <code>not_used</code>,
    memory looks something like <a href="#f:func_call_step_3">Figure 31</a>
    after line 5 is finished:
  </p>

  <figure id="f:func_call_step_3">
    <img src="python/func_call_step_3.png" alt="Third Step of Function Call" />
    <figcaption>Figure 31: Third Step of Function Call</figcaption>
  </figure>

  <p>
    It should now be clear why we got the error we did,
    and why we got it <em>where</em> we did.
    When Python executes line 6,
    the uppermost frame of the stack doesn't contain a variable called <code>temp</code>.
    The frame that <em>did</em> contain that variable
    was discarded when the call to <code>kelvin_to_celsius</code> finished.
  </p>

  <p>
    To understand why Python (and other languages) do all of this,
    let's go back to <code>fahr_to_celsius</code> again.
    Its definition,
    and the definitions of the functions it calls,
    are:
  </p>

<pre>
def fahr_to_kelvin(temp):
    return ((temp - 32.0) * 5.0/9.0) + 273.15

def kelvin_to_celsius(temp):
    return temp - 273.15

def fahr_to_celsius(temp):
    degrees_k = fahr_to_kelvin(temp)
    return kelvin_to_celsius(degrees_k)
</pre>

  <p class="continue">
    These nine lines of code define the variable <code>temp</code> three times&mdash;once
    in each function&mdash;but those three <code>temp</code>s are <em>not</em> the same variable.
    The first <code>temp</code>,
    defined on line 1,
    is created each time <code>fahr_to_kelvin</code> is called,
    and only lasts as long as that call is in progress.
    In computer science jargon,
    it is <a href="glossary.html#local-scope">local</a> to the function.
    Similarly,
    the second <code>temp</code> (on line 4) is local to <code>kelvin_to_celsius</code>,
    and the third (on line 7) to <code>fahr_to_celsius</code>.
    They only exist while the functions that own them are being executed,
    and can only be "seen" inside those functions.
  </p>

  <p>
    Again, some pictures will make this clearer
    (and it does need to be clear,
    since everything else about functions depends on this idea).
    Let's call <code>fahr_to_celsius</code> as before:
  </p>

<pre>
temp_f = 32.0
temp_c = fahr_to_celsius(temp_f)
print 'water freezes at', temp_c
</pre>

  <p>
    Just before line 9 runs,
    the stack consists of a single frame,
    which contains the three functions
    and the variable <code>temp_f</code>
    (<a href="#f:stack_single_frame">Figure 32</a>):
  </p>

  <figure id="f:stack_single_frame">
    <img src="python/stack_single_frame.png" alt="A Call Stack With a Single Frame" />
    <figcaption>Figure 32: A Call Stack With a Single Frame</figcaption>
  </figure>

  <p>
    When we call <code>fahr_to_celsius</code>,
    Python creates a new stack frame containing the variable <code>temp</code>
    and assigns it the value 32.0
    (which it got from <code>temp_f</code>).
    Memory is now as shown in <a href="#f:stack_double_frame">Figure 33</a>.
  </p>

  <figure id="f:stack_double_frame">
    <img src="python/stack_double_frame.png" alt="A New Stack Frame" />
    <figcaption>Figure 33: A New Stack Frame</figcaption>
  </figure>

  <p>
    <code>fahr_to_celsius</code> immediately calls <code>fahr_to_kelvin</code>,
    so Python creates another stack frame
    to hold <code>fahr_to_kelvin</code>'s local variables.
    This frame also contains a variable called <code>temp</code>,
    but since it's in a different frame,
    it's a different variable than <code>fahr_to_celsius</code>'s <code>temp</code>
    (<a href="#f:stack_triple_frame">Figure 34</a>).
  </p>

  <figure id="f:stack_triple_frame">
    <img src="python/stack_triple_frame.png" alt="Yet Another Stack Frame" />
    <figcaption>Figure 34: Yet Another Stack Frame</figcaption>
  </figure>

  <p>
    Using its <code>temp</code>,
    <code>fahr_to_kelvin</code> calculates a result of 273.15.
    When it returns that value,
    Python discards <code>fahr_to_kelvin</code>'s stack frame
    (<a href="#f:stack_back_to_double_frame">Figure 35</a>):
  </p>

  <figure id="f:stack_back_to_double_frame">
    <img src="python/stack_back_to_double_frame.png" alt="Back to a Double Frame" />
    <figcaption>Figure 35: Back to a Double Frame</figcaption>
  </figure>

  <p class="continue">
    and creates a new variable <code>degrees_k</code> to hold that value
    in what is now the top frame&mdash;the one belonging to <code>fahr_to_celsius</code>
    (<a href="#f:new_variable_in_double_frame">Figure 36</a>):
  </p>

  <figure id="f:new_variable_in_double_frame">
    <img src="python/new_variable_in_double_frame.png" alt="A New Variable in the Second Frame" />
    <figcaption>Figure 36: A New Variable in the Second Frame</figcaption>
  </figure>

  <p class="continue">
    Python then goes through the same steps for the call to <code>kelvin_to_celsius</code>.
    It creates a stack frame with a variable <code>temp</code>,
    which it assigns the value 273.15
    (<a href="#f:repeat_stack_frame">Figure 37</a>):
  </p>

  <figure id="f:repeat_stack_frame">
    <img src="python/repeat_stack_frame.png" alt="Repeating the Process" />
    <figcaption>Figure 37: Repeating the Process</figcaption>
  </figure>

  <p class="continue">
    does its calculations,
    and then discards the stack frame when the function is finished.
    Since <code>fahr_to_celsius</code> is also now done,
    Python discards its stack frame,
    creates a variable called <code>temp_c</code> in the original (bottom) frame,
    and assigns it the value 0.0
    (<a href="#f:final_state_of_frames">Figure 38</a>):
  </p>

  <figure id="f:final_state_of_frames">
    <img src="python/final_state_of_frames.png" alt="The Final State" />
    <figcaption>Figure 38: The Final State</figcaption>
  </figure>

  <p>
    Every modern programming language uses this model to manage calculations.
    Each function call creates a new stack frame with its own variables.
    While the function is running,
    it uses the variables in its own frame,
    and when the function call is finished,
    the stack frame is discarded.
  </p>

  <p>
    The area of the program in which a particular variable is visible
    is called its <a href="glossary.html#scope">scope</a>.
    As a rule,
    programming languages do not let functions access variables in other functions' scopes
    because doing so would make large programs almost impossible to write.
    For example,
    imagine we used two functions to sum the squares of the values in a list:
  </p>

<pre>
def sum(numbers):                       <span class="comment">#  1</span>
    result = 0                          <span class="comment">#  2</span>
    for x in numbers:                   <span class="comment">#  3</span>
        result = result + square(x)     <span class="comment">#  4</span>
    return result                       <span class="comment">#  5</span>
                                        <span class="comment">#  6</span>
def square(val):                        <span class="comment">#  7</span>
    result = val * val                  <span class="comment">#  8</span>
    return result                       <span class="comment">#  9</span>
                                        <span class="comment"># 10</span>
print sum([1, 2])                       <span class="comment"># 11</span>
</pre>

  <p class="continue">
    We expect to get 1<sup>2</sup>+2<sup>2</sup> = 5
    via the following steps:
  </p>

  <table border="1">
    <tr>
      <th></th>
      <th><code>sum</code></th>
      <th><code>sum</code></th>
      <th><code>square</code></th>
      <th><code>square</code></th>
    </tr>
    <tr>
      <th>Line</th>
      <th><code>result</code></th>
      <th><code>x</code></th>
      <th><code>val</code></th>
      <th><code>result</code></th>
    </tr>
    <tr>
      <td>2</td>
      <td>0</td>
      <td></td>
      <td></td>
      <td></td>
    </tr>
    <tr>
      <td>3</td>
      <td>0</td>
      <td>1</td>
      <td></td>
      <td></td>
    </tr>
    <tr>
      <td>7</td>
      <td>0</td>
      <td>1</td>
      <td>1</td>
      <td></td>
    </tr>
    <tr>
      <td>8</td>
      <td>0</td>
      <td>1</td>
      <td>1</td>
      <td>1</td>
    </tr>
    <tr>
      <td>4</td>
      <td>1</td>
      <td>1</td>
      <td></td>
      <td></td>
    </tr>
    <tr>
      <td>3</td>
      <td>1</td>
      <td>2</td>
      <td></td>
      <td></td>
    </tr>
    <tr>
      <td>7</td>
      <td>1</td>
      <td>2</td>
      <td>2</td>
      <td></td>
    </tr>
    <tr>
      <td>8</td>
      <td>1</td>
      <td>2</td>
      <td>2</td>
      <td>4</td>
    </tr>
    <tr>
      <td>4</td>
      <td>1</td>
      <td>5</td>
      <td></td>
      <td></td>
    </tr>
    <tr>
      <td>5</td>
      <td>1</td>
      <td>5</td>
      <td></td>
      <td></td>
    </tr>
  </table>

  <p>
    If <code>sum</code>'s <code>result</code> and <code>square</code>'s <code>result</code>
    were the same variable, though,
    we would get 8 instead:
  </p>

  <table border="1">
    <tr>
      <th>Line</th>
      <th><code>result</code></th>
      <th><code>x</code></th>
      <th><code>val</code></th>
    </tr>
    <tr>
      <td>2</td>
      <td>0</td>
      <td></td>
      <td></td>
    </tr>
    <tr>
      <td>3</td>
      <td>0</td>
      <td>1</td>
      <td></td>
    </tr>
    <tr>
      <td>7</td>
      <td>0</td>
      <td>1</td>
      <td>1</td>
    </tr>
    <tr>
      <td>8</td>
      <td>1</td>
      <td>1</td>
      <td>1</td>
    </tr>
    <tr>
      <td>4</td>
      <td>2</td>
      <td>1</td>
      <td></td>
    </tr>
    <tr>
      <td>3</td>
      <td>2</td>
      <td>2</td>
      <td></td>
    </tr>
    <tr>
      <td>7</td>
      <td>2</td>
      <td>2</td>
      <td>2</td>
    </tr>
    <tr>
      <td>8</td>
      <td>4</td>
      <td>2</td>
      <td>2</td>
    </tr>
    <tr>
      <td>4</td>
      <td>8</td>
      <td>2</td>
      <td></td>
    </tr>
    <tr>
      <td>5</td>
      <td>8</td>
      <td>2</td>
      <td></td>
    </tr>
  </table>

  <p class="continue">
    What's worse,
    if we changed the name of the variable in <code>square</code>
    from <code>result</code> to <code>y</code>,
    the final answer would be 5 again.
    Changing the name of a variable shouldn't matter:
    <em>f(x)=x<sup>2</sup></em> and <em>f(y)=y<sup>2</sup></em>
    ought to calculate the same value,
    and if changing a variable name in one part of our program
    can change the result calculated by another,
    we will have to keep the entire program in our head
    in order to make any change safely.
  </p>

  <p>
    The fundamental issue here is one of evolution rather than one of technology.
    Human short-term memory can only hold a few items at a time;
    the value is sometimes given as "seven plus or minus two",
    and while that is an over-simplification,
    it's a good guideline.
    If we need to remember more unrelated bits of information than that for more than a few seconds,
    they become jumbled and we start making mistakes.
  </p>

  <p>
    If we have to keep more than half a dozen things straight in our mind
    in order to understand or change a piece of code,
    we will therefore start making mistakes.
    Most programming languages therefore enforce a "local scope only" rule
    so that programmers can ignore what's inside the functions they are calling,
    or what's outside the functions they are writing,
    and use their short-term memory for the task at hand instead.
  </p>

  <p>
    There is one important pragmatic exception to the "local scope only" rule
    mentioned at the end of the previous section.
    Every function also has access to the <a href="glossary.html#global-scope">global scope</a>,
    which is all the top-level definitions in the program
    (i.e., ones that aren't inside any particular function).
    In our pictures,
    the global scope is the bottom-most frame on the stack,
    which is there when the program starts and never goes away
    (<a href="#f:global_scope">Figure 39</a>).
  </p>

  <figure id="f:global_scope">
    <img src="python/global_scope.png" alt="Global Scope" />
    <figcaption>Figure 39: Global Scope</figcaption>
  </figure>

  <p>
    Functions need access to the global scope because
    that is where other functions are defined.
    Going back to our temperature calculator,
    if <code>fahr_to_celsius</code> could only see variables defined in its local scope,
    it wouldn't be able to see either <code>fahr_to_kelvin</code>
    or <code>kelvin_to_celsius</code>,
    and therefore wouldn't be able to call them.
  </p>

  <p>
    Programmers also usually put constants at the top level of their program
    (i.e., define them in the global scope)
    so that they don't need to pass them into functions.
    For example,
    it's common to see code like this:
  </p>

<pre>
SCALING = 2.5

def scale_up(x):
    return x * SCALING

def scale_down(x):
    return x / SCALING
</pre>

  <p class="continue" id="a:constants">
    (Many programmers write the names of constants in upper case
    to help readers distinguish them from variables,
    but languages don't enforce this.)
    When Python executes <code>scale_up</code> (or <code>scale_down</code>),
    it looks inside that function's scope for a variable called <code>SCALING</code>.
    Since there isn't one,
    it then checks the global scope,
    where it finds what it needs.
  </p>

  <p>
    Defining <code>SCALING</code> once at the top of the program
    ensures that both functions always use the same scaling factor.
    This code produces the same result:
  </p>

<pre>
def scale_up(x):
    return x * 2.5

def scale_down(x):
    return x / 2.5
</pre>

  <p class="continue">
    but experience shows that
    it's very easy for a programmer to change the scaling factor in one function
    and forget to change it in the other.
    Programs always evolve to meet new needs;
    good programmers plan for this,
    because they know that if they don't,
    they'll eventually pay the price.
  </p>

  <p>
    Putting constants in the global scope is good style.
    The following is not
    (and in fact,
    isn't even legal Python,
    for reasons we'll discuss in a moment):
  </p>

<pre>
largest = 0

def fixup(values):
    for i in range(len(values)):
        if values[i] &gt; largest:
            largest = values[i]

def scale(values):
    for i in range(len(values)):
        values[i] = values[i] / largest
</pre>

  <p class="continue">
    Here,
    the function <code>fixup</code> puts the largest value it has seen
    in a global variable called <code>largest</code>,
    which <code>scale</code> then uses.
    This works in simple cases:
  </p>

<pre>
rows = [1.0, 4.0, -2.5, 3.5]
fixup(rows)
scale(rows)
print rows
<span class="out">[0.25, 1.0, 0.0, 0.875]</span>
</pre>

  <p class="continue">
    but look what happens when we try to process another data set:
  </p>

<pre>
columns = [1.5, 1.5, -2.0, 3.0]
fixup(columns)
scale(columns)
print columns
<span class="out">[0.375, 0.375, 0.0, 0.75]</span>
</pre>

  <p class="continue">
    If we actually want each data set fixed up and scaled separately,
    the answer for <code>columns</code> should be <code>[0.5, 0.5, 0.0, 1.0]</code>.
    The problem is that
    the values in <code>columns</code> are actually being scaled by
    the largest value found in <code>rows</code>,
    because that's what was left behind in <code>largest</code>
    by the initial call.
  </p>

  <p>
    Bugs like this are caused by <a href="glossary.html#side-effect">side effects</a>
    that aren't visible in either the functions' definitions or calls.
    They are notoriously difficult to track down,
    so most modern programming languages discourage programmers from using global variables.
    In Python,
    for example,
    the sample program shown above doesn't actually run.
    If we really want it to,
    we have to add one more line:
  </p>

<pre>
largest = 0

def fixup(values):
    <span class="highlight">global largest</span>
    for i in range(len(values)):
        if values[i] &gt; largest:
            largest = values[i]

def scale(values):
    for i in range(len(values)):
        values[i] = values[i] / largest
</pre>

  <p>
    Without the highlighted <code>global</code> statement,
    Python assumes that <code>largest</code> is local to the function <code>fixup</code>.
    Again,
    the root cause is the way that human memory works.
    If information only comes into a function through its parameters,
    it's easy for readers to keep track of what they need to know
    in order to trace the function's behavior.
    But if information can magically appear in the middle of a function
    (as it does in <code>scale</code> when <code>largest</code> is suddenly used
    without having been defined),
    the person reading the program has to keep much more information in their head.
    This increases the chances that they'll misunderstand the program,
    which in turn increases the chances of that program being wrong.
    As a rule,
    therefore,
    functions should <em>only</em> use
    values passed in explicitly as parameters,
    values defined as global constants,
    and variables created locally.
  </p>

  <div class="keypoints">
    <h3>Summary</h3>
    <ul>
      <li>Every function always has access to variables defined in the global scope.</li>
      <li>Programmers often write constants' names in upper case to make their intention easier to recognize.</li>
      <li>Functions should <em>not</em> communicate through global variables.</li>
    </ul>
  </div>

  <div class="challenges">
    <h3>Challenges</h3>

    <ol>

      <li>
        Identify the global variables in this program,
        and rewrite it
        so that the two functions do not share information
        through global variables.
<pre>
def increase(floor):
    for (i, n) in enumerate(values):
        if n &lt; floor:
            values[i] = floor

def scale(amount):
    for i in range(bound):
        values[i] *= amount

values = [4.0, 4.3, 4.7, 5.1]
bound = 2
increase(4.5)
scale(10.0)
</pre>
      </li>

      <li>
        Python allows programmers to define functions inside other functions:
<pre>
def scale_all(values, amount):

    def scale_one(v):
        return 1.0 + v * amount

    for (i, v) in enumerate(values):
        values[i] = scale_one(v)
    return values

scale_all([1.0, 2.0, 3.0], 10.0)
<span class="out">[11.0, 21.0, 31.0]</span>
</pre>
        Draw a memory diagram showing what's on the stack
        when Python is calculating
        <code>1.0 + 2.0 * 10.0</code>
        (the second iteration of the loop in <code>scale_all</code>).
        What happens if we try to call <code>scale_one(7.0)</code>
        after the call to <code>scale_all</code> has completed?
      </li>

    </ol>

  </div>

</section>

<section id="s:return">
  <h2>Returning Values</h2>

  <div class="understand">
    <h3>Learning Objectives</h3>
    <ul>
      <li>Write functions that return values from arbitrary points.</li>
      <li>Explain why functions <em>shouldn't</em> return values at arbitrary points.</li>
      <li>Identify functions that implicitly return <code>None</code>.</li>
    </ul>
    <p>
      <span class="duration">15 minutes</span>.
    </p>
  </div>

  <p>
    All of our functions so far have ended with a <code>return</code> statement,
    and that has been the only <code>return</code> statement they've contained.
    Once again,
    this doesn't have to be the case:
    it is often easier to write functions that return from several places,
    though this can also make them harder to read.
  </p>

  <p>
    Let's start with a function that calculates the sign of a number:
  </p>

<pre>
def sign(num):
    if num &lt; 0:
        return -1
    if num == 0:
        return 0
    return 1
</pre>

  <p class="continue">
    If we call it with a negative number,
    the first branch of the <code>if</code> returns -1.
    If we call it with 0,
    the <code>return</code> in the second <code>if</code> is executed,
    and if we call it with a positive number,
    neither of the <code>if</code> branches is taken,
    so we <a href="glossary.html#fall-through">fall through</a> to the final <code>return</code>,
    which produces the value 1:
  </p>

<pre>
print -5, '=&gt;', sign(-5)
print 0, '=&gt;', sign(0)
print 241, '=&gt;', sign(241)
<span class="out">-5 =&gt; -1
0 =&gt; 0
241 =&gt; 1</span>
</pre>

  <p>
    One common use of multiple return statements
    is to handle special cases at the start of a function.
    For example,
    suppose we decide that we want the average of an empty list to be zero after all.
    We could modify our averaging function to check for this case
    before doing anything else:
  </p>

<pre>
def average(values):

    <span class="comment"># The average of no values is 0.0.</span>
    if len(values) == 0:
        return 0.0

    <span class="comment"># Handle actual values.</span>
    result = 0.0
    for v in values:
        result += v
    return result / len(values)
</pre>

  <p class="continue">
    The early <code>return</code> statement (plus a comment)
    makes it very clear to whoever is reading this code
    that we are handling an empty list in a special way.
    Compare this to an implementation that uses <code>if</code> and <code>else</code>
    to separate the two cases
    while keeping a single <code>return</code> statement at the end of the function:
  </p>

<pre>
def average(values):

    <span class="comment"># The average of no values is 0.0.</span>
    if len(values) == 0:
        result = 0.0

    <span class="comment"># Handle actual values.</span>
    else:
        result = 0.0
        for v in values:
            result += v
        result /= len(values)

    <span class="comment"># Return final result.</span>
    return result
</pre>

  <p class="continue">
    This version is easier to understand in one way,
    but harder in another.
    What makes it harder is our limited short-term memory:
    the body of the <code>else</code> is only four lines long,
    but reading and understanding those lines
    may push the special handling of the empty list out of our mind.
    In this case,
    the code is short enough that
    we will probably be able to retain the special case,
    but if the calculation was more complex,
    we would lose sight of the big picture.
  </p>

  <p>
    What makes it easier is its regularity:
    each possible case of input (empty or non-empty) is handled in a conditional branch,
    and each branch's job is to assign a value to <code>result</code>
    for the function to return.
    If there were six or seven special cases,
    this pattern would help us keep track of what what going on&mdash;provided
    we knew (or recognized) the pattern.
  </p>

  <p>
    The psychological term for what's going on here is
    <a href="glossary.html#chunk">chunking</a>,
    which refers to the way people group items together in memory.
    For example, when you look at the five dots on a dice
    (<a href="#f:five_spots">Figure 40</a>):
  </p>

  <figure id="f:five_spots">
    <img src="python/five_spots.png" alt="Five Spots" />
    <figcaption>Figure 40: Five Spots</figcaption>
  </figure>

  <p class="continue">
    what you actually "see" is the X pattern,
    and what you remember is that pattern rather than five individual dots.
    rather than remembering five individual dots.
    Similarly,
    you remember common words such as "common" as words,
    not as sequences of letters,
    and so on.
  </p>

  <p>
    One of the key differences between experts and novices is that
    experts are better at chunking:
    they don't actually have larger short-term memories,
    but since they recognize a broader repertoire of patterns,
    they are able to manage more information.
    Turning that over,
    the more recognizable patterns are used in a program,
    the easier it is for people to keep it in their heads.
    And as Chase and Simon discuss in their classic paper
    "<a href="bib.html#chase-simon-chess">Perception in chess</a>",
    things that <em>don't</em> conform to patterns can actually be <em>harder</em> for experts to recognize,
    since their brains will mis-match and "correct" what's actually there.
  </p>

  <p>
    Here's a third version of our function that doesn't use an early return.
    and only has one conditional branch:
  </p>

<pre>
def average(values):
    result = 0.0
    if len(values) &gt; 0:
        for v in values:
            result += v
        result /= len(values)
    return result
</pre>

  <p class="continue">
    Many people find this version harder to understand than either of the previous two,
    even though it is shorter.
    The reason is that the special case isn't handled explicitly.
    Instead,
    this function returns 0 for the empty list
    because of the code that <em>isn't</em> executed:
    if the list is empty,
    the loop doesn't run,
    so the initial value of <code>result</code>
    becomes the function's final value by default.
    Spotting this,
    and keeping track of what the function isn't doing as well as what it is,
    is difficult enough that
    many people won't realize there is a special case at all.
  </p>

  <p>
    One last thing to note about functions in Python is that
    every function returns something:
    if there isn't an explicit <code>return</code> statement,
    the value returned is <code>None</code>.
    For example,
    let's comment out the last line of our sign function:
  </p>

<pre>
def sign(num):
    if num &lt; 0:
        return -1
    if num == 0:
        return 0
<span class="comment">#    return 1</span>

print -5, '=&gt;', sign(-5)
print 0, '=&gt;', sign(0)
print 241, '=&gt;', sign(241)
<span class="out">-5 =&gt; -1
0 =&gt; 0
241 =&gt; None</span>
</pre>

  <p class="continue">
    The sign of 241 is now <code>None</code> instead of 1,
    because when the function is called with a positive value,
    neither of the <code>if</code> branches is taken,
    and execution "falls off" the end of the function.
  </p>

  <p>
    Other languages do this differently.
    In C,
    for example,
    trying to use the "result" of a function that doesn't explicitly return something
    is a compilation error&mdash;the program can't even be run.
    No matter what the language,
    this is one reason why commenting out blocks of code is a bad idea:
    it's all too easy to accidentally disable a <code>return</code> statement
    buried inside the code that's no longer being executed.
  </p>

  <div class="keypoints">
    <h3>Summary</h3>
    <ul>
      <li>A function may return values at any point.</li>
      <li>A function should have zero or more <code>return</code> statements at its start to handle special cases, and then one at the end to handle the general case.</li>
      <li>"Accidentally" correct behavior is hard to understand.</li>
      <li>If a function ends without an explicit <code>return</code>, it returns <code>None</code>.</li>
    </ul>
  </div>

  <div class="challenges">
    <h3>Challenges</h3>

    <ol>

      <li>
        One alternative to returning from inside a loop
        is to use the <code>break</code> statement
        to end the loop immediately:
<pre>
def first_negative(values):
    for v in values:
        if v &lt; 0:
            break
    return v
print first_negative([1, 3, -1, 2])
<span class="out">-1</span>
</pre>
        When can this approach result in an error,
        and what kind of error does it produce?
      </li>

      <li>
        This functions counts
        how many values from a list must be summed
        in order to reach some limit:
<pre>
def count_to_limit(values, limit):
    current = 0
    number = 0
    for v in values:
        current += v
        number += 1
        if current &gt;= limit:
            return number

print count_to_limit([1, 2, 3, 5, 7], 8)
<span class="out">4</span>
</pre>
        Fix it so that it returns the right answer
        when <code>limit</code> is negative,
        and when the sum of the values in the list
        never reaches <code>limit</code>.
      </li>

    </ol>

  </div>

</section>

<section id="s:alias">
  <h2>Aliasing</h2>

  <div class="understand">
    <h3>Learning Objectives</h3>
    <ul>
      <li>Explain what an "alias" is.</li>
      <li>Explain why aliases are useful.</li>
      <li>Explain why aliases can make programs harder to understand.</li>
      <li>Identify examples in which aliasing does and does not occur.</li>
      <li>Construct programs which create aliases for data.</li>
      <li>Trace changes to data in programs that contain aliases.</li>
    </ul>
    <p>
      <span class="duration">30 minutes</span>.
    </p>
  </div>
    
  <p>
    At this point,
    we need to take a small side trip to explore something which is very useful,
    but which can also be the source of some hard-to-find bugs.
    Consider the following snippet of Python:
  </p>

<pre>
outer = [ [10, 20, 30], [40, 50, 60] ]
inner = outer[0]
</pre>

  <p class="continue">
    After these two lines have been executed,
    the program's memory is as shown in <a href="#f:aliasing_a">Figure 41</a>:
    <code>outer</code> refers to a two-element list
    containing references to a couple of three-element lists,
    while <code>inner</code> refers to the first of those three-element lists.
  </p>
    
  <figure id="f:aliasing_a">
    <img src="src/python/aliasing_a.png" alt="First Step of Aliasing Example" />
    <figcaption>Figure 41: First Step of Aliasing Example</figcaption>
  </figure>
    
  <p>
    Now let's change the last value of the list that <code>inner</code> refers to:
  </p>

<pre>
inner[2] = 99
</pre>

  <p class="continue">
    This changes memory as shown in <a href="#f:aliasing_b">Figure 42</a>,
    which means that the values of both <code>inner</code> <em>and</em> <code>outer</code>
    have changed:
  </p>

<pre>
&gt;&gt;&gt; <span class="in">print inner</span>
<span class="out">[10, 20, 99]</span>
&gt;&gt;&gt; <span class="in">print outer</span>
<span class="out">[[10, 20, 99], [40, 50, 60]]</span>
</pre>

  <figure id="f:aliasing_b">
    <img src="src/python/aliasing_b.png" alt="Second Step of Aliasing Example" />
    <figcaption>Figure 42: Second Step of Aliasing Example</figcaption>
  </figure>

  <p>
    This is called <a href="glossary.html#alias">aliasing</a>.
    It is not a bug:
    the program is supposed to work this way.
    It doesn't have to, though;
    Python's creator could have decided that:
  </p>
    
<pre>
inner = outer[0]
</pre>

  <p class="continue">
    would create a copy of <code>outer[0]</code>
    and assign that to <code>inner</code>
    rather than aliasing the first element of <code>outer</code>
    (<a href="#f:aliasing_copy">Figure 43</a>).
    That would be easier to understand&mdash;there would be no chance that
    assigning to one variable would cause another variable's value to change&mdash;but
    it would also be less efficient.
    If our sublists contain a million elements each,
    and we're assigning them to temporary variables
    simply to make our program more readable,
    copying would cause unnecessary slow-down.
  </p>
    
  <figure id="f:aliasing_copy">
    <img src="src/python/aliasing_copy.png" alt="Copying Instead of Aliasing" />
    <figcaption>Figure 43: Copying Instead of Aliasing</figcaption>
  </figure>
    
  <p>
    When a programming language copies data,
    and when it creates aliases instead,
    is one of the most important things a programmer must know about it.
    As we'll see <a href="web.html">later</a>,
    it's also one of the most important things to know about large systems of any kind.
    If we query a database,
    is the result a copy of the data as it was when we made the query,
    or a reference to the master copy?
    In the first case,
    we can now change the data however we want without affecting other people,
    but we won't see any updates they make.
    In the second case,
    we will automatically see updates to the data,
    but that means our program has to cope with changes at unpredictable times
    (and also has to re-fetch the data each time it needs it,
    which will reduce performance).
    Neither approach is right or wrong:
    there are simply engineering tradeoffs that we have to be aware of.
  </p>
    
  <div class="box">
    <h3>Copying When You Want To</h3>
      
    <p>
      Python has a library called (naturally enough) <code>copy</code>
      that knows how to copy complex data structures.
      We will take a look at it <a href="#a:copy_library">later</a>
      once we have looked at how Python manages libraries in general.
    </p>

  </div>

  <p>
    We said <a href="#a:call-stack">earlier</a> that
    values are copied into parameters whenever a function is called.
    But as we explained in the <a href="python.html#s:alias">previous chapter</a>,
    variables don't actually store values:
    they are actually just names that refer to values.
    To see what this means for our programs,
    here's a function that takes a string and a list as parameters,
    and appends something to both:
  </p>

<pre src="src/funclib/appender.py">
def appender(a_string, a_list):
    a_string = a_string + 'turing'
    a_list.append('turing')
</pre>

  <p class="continue">
    And here is some code to set up a pair of variables and call that function:
  </p>

<pre src="src/funclib/appender.py">
string_val = 'alan'
list_val = ['alan']
appender(string_val, list_val)
print 'string', string_val
print 'list', list_val
<span class="out">string alan
list ['alan', 'turing']</span>
</pre>

  <p>
    Why did the list change when the string didn't?
    To find out,
    let's trace the function's execution.
    Just before the call,
    the global frame has two variables
    that refer to a string and a list
    (<a href="#f:append_before_call">Figure 44</a>):
  </p>

  <figure id="f:append_before_call">
    <img src="python/append_before_call.png" alt="Before Appending" />
    <figcaption>Figure 44: Before Appending</figcaption>
  </figure>

  <p class="continue">
    The call creates a new stack frame with aliases for those values
    (<a href="#f:append_during_call">Figure 45</a>):
  </p>

  <figure id="f:append_during_call">
    <img src="python/append_during_call.png" alt="While Appending" />
    <figcaption>Figure 45: While Appending</figcaption>
  </figure>

  <p>
    The <code>a_string&nbsp;+&nbsp;'turing'</code> creates a new string <code>'alanturing'</code>;
    assigning this to the variable <code>a_string</code>
    changes what that local variable refers to,
    but doesn't change what the global variable <code>string_val</code> refers to
    (<a href="#f:append_new_string">Figure 46</a>):
  </p>

  <figure id="f:append_new_string">
    <img src="python/append_new_string.png" alt="A New String" />
    <figcaption>Figure 46: A New String</figcaption>
  </figure>

  <p>
    The statement <code>a_list.append('turing')</code>,
    however,
    actually modifies the list that <code>a_list</code> is pointing to:
    (<a href="#f:append_same_list">Figure 47</a>):
  </p>

  <figure id="f:append_same_list">
    <img src="python/append_same_list.png" alt="But the Same List" />
    <figcaption>Figure 47: But the Same List</figcaption>
  </figure>

  <p>
    But this is the same thing that the variable <code>list_val</code> in the caller is pointing to.
    When the function returns and the call frame is thrown away,
    the new string <code>'alanturing'</code> is therefore lost,
    because the only reference to it was in the function call's stack frame.
    The change to the list,
    on the other hand,
    is kept,
    because the function actually modified the list in place:
    (<a href="#f:append_final_state">Figure 48</a>):
  </p>

  <figure id="f:append_final_state">
    <img src="python/append_final_state.png" alt="The Final State of Memory" />
    <figcaption>Figure 48: The Final State of Memory</figcaption>
  </figure>

  <p>
    Let's change one line in the function:
  </p>

<pre src="src/funclib/appender_2.py">
def appender(a_string, a_list):
    a_string = a_string + 'turing'
    <span class="highlight">a_list = a_list + ['turing']</span>
</pre>

  <p class="continue">
    and see what happens when we run the same experiment:
  </p>

<pre src="src/funclib/appender_2.py">
string_val = 'alan'
list_val = ['alan']
appender(string_val, list_val)
print 'string', string_val
print 'list', list_val
<span class="out">string alan
list ['alan']</span>
</pre>

  <p>
    The answer is different because
    concatenating (adding) two lists creates a new list,
    rather than modifying either of the lists being concatenated.
    As a result,
    the local variable <code>a_list</code> is the only thing that refers to the list
    <code>['alan', 'turing']</code>,
    so that value is discarded when the function finishes
    and <code>list_val</code>'s value is undisturbed.
  </p>

  <div class="box">
    <h3>Memory Models</h3>

    <p>
      Python's treatment of lists
      (and other mutable data that we'll see <a href="setdict.html">later</a>)
      isn't the only way to handle things.
      For example,
      MATLAB functions
      use a rule called <a href="glossary.html#copy-on-write">copy on write</a>.
      Initially,
      it creates aliases for arrays that are passed into functions.
      The first time a function assigns to an array,
      though,
      MATLAB clones the array
      and changes the clone rather than the original
      (<a href="#f:copy_on_write">Figure 49</a>).
      This saves it from copying data when it doesn't need to,
      while guaranteeing that functions don't have side effects
      (which makes them easier to think about).
    </p>

    <figure id="f:copy_on_write">
      <img src="python/copy_on_write.png" alt="Copy on Write" />
      <figcaption>Figure 49: Copy on Write</figcaption>
    </figure>

    <p>
      Other languages have slightly different rules about scoping and aliasing.
      Together,
      those rules make up the language's
      <a href="glossary.html#memory-model">memory model</a>.
      Understanding that model is perhaps the most important step
      in understanding how programs written in the language actually work,
      and more importantly,
      how to debug them when they don't.
    </p>
  </div>
  
  <div class="keypoints">
    <h3>Summary</h3>
    <ul>
      <li>Several variables can alias the same data.</li>
      <li>If that data is mutable (e.g., a list), a change made through one variable is visible through all other aliases.</li>
      <li>Values are actually passed into functions by reference, which means that they are aliased.</li>
      <li>Aliasing means that changes made to a mutable object like a list inside a function are visible after the function call completes.</li>
    </ul>
  </div>

  <div class="challenges">
    <h3>Challenges</h3>

    <ol>
      
      <li>
        Draw a diagram to show the state of memory
        after the two lines below have been executed.
<pre>
base = [1]
base.append(base)
</pre>
      </li>
      
      <li>
        Which program creates the memory layout shown in
        <a href="#f:memory_layout_challenge">Figure 50</a>?
        
        <figure id="f:memory_layout_challenge">
          <img src="python/memory_layout_challenge.png" alt="Memory Layout Challenge" />
          <figcaption>Figure 50: Memory Layout Challenge</figcaption>
        </figure>
        
        <table>
          <tr>
            <td valign="top">A</td>
            <td valign="top">
<pre>
alpha = [beta]
beta = [alpha]
</pre>
            </td>
          </tr>
          <tr>
            <td valign="top">B</td>
            <td valign="top">
<pre>
alpha = []
beta = []
alpha[0] = beta
beta[0] = alpha
</pre>
            </td>
          </tr>
          <tr>
            <td valign="top">C</td>
            <td valign="top">
<pre>
alpha = [beta] + alpha
</pre>
            </td>
          </tr>
          <tr>
            <td valign="top">D</td>
            <td valign="top">
<pre>
alpha = []
beta = []
alpha.append(beta)
beta.append(alpha)
</pre>
            </td>
          </tr>
        </table>
      </li>

      <li>
        Modify this program so that it prints
        <code>[[100, 200], [300, 400]]</code>.
<pre>
vector = [100, 200]
matrix = []
matrix.append(vector)
vector[0] = 300
vector[1] = 400
matrix.append(vector)
print matrix
</pre>
      </li>

      <li>
        These lines produce the output shown:
<pre>
readings = [0] * 3
readings[-1] = 'zero'
print readings
<span class="out">[0, 0, 'zero']</span>
</pre>
        By analogy,
        the author of these lines wanted to create a 3&times;3 matrix of zeroes
        with a single value set to the string <code>'zero'</code>.
        What has she actually produced,
        why does it work that way,
        and how can she change her code to get what she wants?
<pre>
vec = [0] * 3
mat = [vec] * 3
mat[-1][-1] = 'zero'
print mat
</pre>
      </li>
      
    </ol>
    
  </div>

</section>

<section id="s:libraries">
  <h2>Libraries</h2>

  <div class="understand">
    <h3>Learning Objectives</h3>
    <ul>
      <li>Import code from one Python module in three different ways and use it in another.</li>
      <li>Predict what code will be executed as it is imported.</li>
      <li>Correctly identify module-scoped variables.</li>
      <li>Explain why every module is a scope, and how that scope relates to the global and local scopes.</li>
      <li>Write programs that use the major elements of the <code>sys</code> and <code>math</code> libraries.</li>
    </ul>
    <p>
      <span class="duration">30 minutes</span>.
    </p>
  </div>

  <p>
    A function is a way to turn a bunch of related statements into a single chunk that can be re-used.
    A <a href="glossary.html#module">module</a>
    or <a href="glossary.html#library">library</a>
    (for our purposes, the terms mean the same thing)
    does for functions what functions do for statements:
    group them together to create more usable chunks.
    This hierarchical organization is similar in spirit to that used in biology:
    instead of family, genus, and species, we have module, function, and statement.
  </p>

  <p>
    As we saw <a href="#s:stdio">earlier</a>,
    we can load a library into a Python program using the <code>import</code> statement.
    What we didn't see then is that
    every Python file can be used as a module by other programs.
    For example,
    suppose we have created a Python file called <code>halman.py</code>
    that defines a single function called <code>threshold</code>:
  </p>

<pre>
<span class="comment"># halman.py</span>
def threshold(signal):
  return 1.0 / sum(signal)
</pre>

  <p class="continue">
    If we want to call this function in a program stored in another file,
    we use <code>import halman</code> to load the contents of <code>halman.py</code>,
    and then call the function as <code>halman.threshold</code>:
  </p>

<pre>
import halman
readings = [0.1, 0.4, 0.2]
print 'signal threshold is', halman.threshold(readings)
</pre>

  <p class="continue">
    We can then run the program that does the <code>import</code>
    and calls the function:
  </p>

<pre>
$ <span class="in">python use_halman.py</span>
<span class="out">signal threshold is 1.42857</span>
</pre>

  <p>
    When a module is imported,
    Python executes the statements it contains
    (which are usually function definitions).
    It then creates an object to store references to all the items defined in that module
    and assigns it to a variable with the same name as the module.
    For example,
    let's create a file called <code>noisy.py</code> that prints out a message
    and then defines <code>NOISE_LEVEL</code> to be 1/3:
  </p>

<pre>
<span class="comment"># noisy.py</span>
print 'Is this module being loaded?'
NOISE_LEVEL = 1./3.
</pre>

  <p class="continue">
    When it imports <code>noisy</code>
    Python executes the first statement&mdash;the <code>print</code>&mdash;and
    displays a message on the screen:
  </p>

<pre>
&gt;&gt;&gt; <span class="in">import noisy</span>
<span class="out">Is this module being loaded?</span>
</pre>

  <p class="continue">
    Importing the module also defines the variable <code>NOISE_LEVEL</code>.
    Inside the main program,
    we can access as <code>noisy.NOISE_LEVEL</code>:
  </p>

<pre>
&gt;&gt;&gt; <span class="in">print noisy.NOISE_LEVEL</span>
<span class="out">0.33333333</span>
</pre>

  <p>
    Just like a function,
    each module is a separate scope,
    so that variable names defined inside a module belong to that module
    and don't collide with variable names defined elsewhere.
    When a function wants to a find a variable,
    it actually looks in its own scope,
    then in its module.
    Our earlier rule "function then global" is just a special case of this,
    since the global scope is just the module scope of our main program
    (<a href="#f:name_resolution">Figure 51</a>).
  </p>

  <figure id="f:name_resolution">
    <img src="python/name_resolution.png" alt="Name Resolution" />
    <figcaption>Figure 51: Name Resolution</figcaption>
  </figure>

  <p>
    To see how this works,
    let's create a file called <code>module.py</code>
    that defines both a variable called <code>NAME</code>
    and a function called <code>func</code> that prints it out:
  </p>

<pre>
<span class="comment"># module.py</span>
NAME = 'Transylvania'

def func(arg):
  return NAME + ' ' + arg
</pre>

  <p class="continue">
    In our main program,
    we also define a variable called <code>NAME</code>,
    then import our module.
    When we call <code>module.func</code>
    it sees the <code>NAME</code> variable that was defined inside the module,
    not the one that was defined globally:
  </p>

<pre>
&gt;&gt;&gt; <span class="in">NAME = 'Hamunaptra'</span>
&gt;&gt;&gt; <span class="in">import module</span>
&gt;&gt;&gt; <span class="in">print module.func('!!!')</span>
<span class="out">Transylvania !!!</span>
</pre>

  <p>
    Once again,
    rules about where and how to look things up might seem arcane,
    but it would be practically impossible to write large programs
    without some kind of scoping them.
    Restricting lookup to the current function,
    its module,
    and the top level of the program makes it easier for people to understand code,
    since there are only three places where the variables used on a particular line might be,
    two of which (the containing function and the file it's in)
    are guaranteed to be nearby.
  </p>

  <div class="box">
    <h3>How Other Languages Do It</h3>

    <p>
      When a dynamic language like Python (or MATLAB, R, Ruby, or Perl) loads a program,
      it actually does two things:
    </p>

    <ol>
      <li>
        translate the statements into instructions the computer can execute,
        and
      </li>
      <li>
        execute those instructions.
      </li>
    </ol>

    <p>
      Compiled languages like Fortran, C++, and Java do these things separately:
      a <a href="glossary.html#compiler">compiler</a> does the translation,
      saving the instructions in a file on disk,
      which a separate <a href="glossary.html#loader">loader</a>
      copies into memory for execution some time later
      (<a href="#f:compiling_vs_interpreting">Figure 52</a>).
      In general,
      compiled languages therefore don't execute instructions while loading;
      instead,
      they wait until everything is in memory before running any of it.
    </p>

    <figure id="f:compiling_vs_interpreting">
      <img src="python/compiling_vs_interpreting.png" alt="Compiling vs. Interpreting" />
      <figcaption>Figure 52: Compiling vs. Interpreting</figcaption>
    </figure>

  </div>

  <p>
    Python's standard library contains over a hundred modules.
    One of the most useful is <code>math</code>,
    which defines <code>sqrt</code> for square roots,
    <code>hypot</code> for calculating x<sup>2</sup>+y<sup>2</sup>,
    and values for <em>e</em> and &pi; that are as accurate as the machine can make them.
  </p>

<pre>
import math
print math.sqrt(2)
<span class="out">1.4142135623730951</span>
print math.hypot(2, 3) <span class="comment"># sqrt(x**2 + y**2)</span>
<span class="out">3.6055512754639891</span>
print math.e, math.pi <span class="comment"># as accurate as possible</span>
<span class="out">2.7182818284590451 3.1415926535897931</span>
</pre>

  <p>
    Since <code>math.sqrt</code> is a handful to type,
    and <code>sqrt</code> is probably not ambiguous,
    Python provides several ways to import things.
    For example,
    we can import specific functions from a library and then call them directly,
    rather than using the <code>modulename.functionname</code> syntax:
  </p>

<pre>
from math import sqrt
sqrt(3)
<span class="out">1.7320508075688772</span>
</pre>

  <p class="continue">
    We can also import a function under a different name,
    so that if two modules define functions with the same name,
    we can give one or the other a different name when we want to use them together:
  </p>

<pre>
from math import hypot as euclid
euclid(3, 4)
<span class="out">5.0</span>
</pre>

  <p>
    Finally,
    we can use <code>import *</code>
    to bring everything in the module into the current scope at once.
    This has the same effect as using <code>from module import a</code>,
    <code>from module import b</code>,
    and so on for every name in the module:
  </p>

<pre>
from math import *
sin(pi)
<span class="out">1.2246063538223773e-16</span>
</pre>

  <p class="continue">
    <code>import *</code> is usually a bad idea:
    if someone adds a new function or variable to the next version of the module,
    your <code>import *</code> could silently overwrite something that you have written,
    or are importing from somewhere else.
    Bugs like this can be extremely hard to find,
    since nothing seemed to change in your program.
  </p>

  <p>
    Another useful library is <code>sys</code> (short for "system").
    It defines constants to tell us what version of Python we're using,
    what operating system we're running on,
    and how large integers are:
  </p>

<pre>
import sys
print sys.version
<span class="out">2.7 (r27:82525, Jul  4 2010, 09:01:59) [MSC v.1500 32 bit (Intel)]</span>
print sys.platform
<span class="out">win32</span>
print sys.maxint
<span class="out">2147483647</span>
print sys.path
<span class="out">['',
 'C:\\WINDOWS\\system32\\python27.zip',
 'C:\\Python27\\DLLs', 'C:\\Python27\\lib',
 'C:\\Python27\\lib\\plat-win',
 'C:\\Python27', 'C:\\Python27\\lib\\site-packages']</span>
</pre>

  <p>
    The most commonly-used element of <code>sys</code>, though, is <code>sys.argv</code>,
    which holds a list of the <a href="glossary.html#command-line-arguments">command-line arguments</a>
    used to run the program.
    The name of the script itself is in <code>sys.argv[0]</code>;
    all the other arguments are put in <code>sys.argv[1]</code>, <code>sys.argv[2]</code>, and so on.
    For example, here's a program that does nothing except print out its command-line arguments:
  </p>

<pre src="python/echo.py">
<span class="comment"># echo.py</span>
import sys
for i in range(len(sys.argv)):
  print i, '"' + sys.argv[i] + '"'
</pre>

  <p class="continue">
    If it is run without any arguments,
    it reports that <code>sys.argv[0]</code> is <code>echo.py</code>:
  </p>

<pre>
$ <span class="in">python echo.py</span>
<span class="out">0 echo.py</span>
</pre>

  <p class="continue">
    When it is run with arguments, though, it displays those as well:
  </p>

<pre>
$ <span class="in">python echo.py first second</span>
<span class="out">0 echo.py</span>
<span class="out">1 first</span>
<span class="out">2 second</span>
</pre>

  <p>
    We can use this to write the world's simplest calculator:
  </p>

<pre>
import sys

total = 0
for value in sys.argv[1:]:
    total += float(value)
print total
$ <span class="in">python calculator.py 1 2 3</span>
<span class="out">6.0</span>
</pre>

  <p class="continue">
    Notice that we loop over <code>sys.argv[1:]</code>,
    i.e.,
    over everything except the first element of <code>sys.argv</code>.
    That first element is always the name of our program
    (in this case, <code>calculator.py</code>),
    which we definitely don't want to try to add to our running total.
  </p>

  <p>
    A more common use of <code>sys.argv</code> is
    to pass the names of a bunch of files into our program.
    Suppose,
    for example,
    that we have a function called <code>summarize</code>
    that opens a file,
    reads the values in it,
    and returns the minimum, average, and maximum:
  </p>

<pre>
def summarize(filename):
    reader = open(filename, 'r')
    least, greatest, total, count = 0.0, 0.0, 0.0
    for line in reader:
        current = float(line)
        least = min(least, current)
        greatest = max(least, current)
        total += current
        count += 1
    reader.close()
    return least, total / count, greatest
</pre>

  <p class="continue">
    If we want to display summaries for several files at once,
    we can require the user to give them as command-line arguments:
  </p>

<pre>
$ python summarize.py july.dat august.dat september.dat
</pre>

  <p class="continue">
    and connect the command line with the program's internals using <code>sys.argv</code>:
  </p>

<pre>
all_filenames = sys.argv[1:]  <span class="comment"># Again, don't include the program name</span>
for filename in all_filenames:
    low, ave, high = summarize(filename)
    print filename, low, ave, high
</pre>

  <p>
    Here are just a few of Python's many other useful libraries:
  </p>

  <ul>

    <li>
      The <code>glob</code> module does pattern-matching on filenames
      using the same <a href="shell.html#a:wildcard">wildcard syntax</a>
      as the shell:
<pre>
$ <span class="input">ls</span>
<span class="out">alpha.txt   beta.txt   helium.dat  hydrogen.dat  zeta.txt</span>
$ <span class="input">python</span>
&gt;&gt;&gt; <span class="input">import glob</span>
&gt;&gt;&gt; <span class="input">print glob.glob('*.dat')</span>
<span class="out">['helium.dat', 'hydrogen.dat']</span>
</pre>
    </li>

    <li id="a:copy_library">
      The <code>copy</code> library makes copies of arbitrary data structures.
      These can be <a href="glossary.html#shallow-copy">shallow</a>
      (only the top-level structure is copied)
      or <a href="glossary.html#deep-copy">deep</a>
      (everything is copied all the way down):
<pre>
import copy
names = [['Charles', 'Darwin'], ['Isaac', 'Newton']]
dup = copy.deepcopy(names)
print dup
<span class="out">[['Charles', 'Darwin'], ['Isaac', 'Newton']]</span>
</pre>
    </li>

    <li>
      The <code>time</code> library manipulates times.
      It contains many functions
      (as do the related <code>datetime</code> and <code>calendar</code> modules&mdash;time
      is more complicated than most people realize).
      One of the most useful functions in <code>time</code> reports the current time in seconds
      according to the system clock;
      the difference between two such calls can be used
      to find out how long a piece of code took to run:
<pre>
import time

start = time.clock()
temp = 0
for i in range(1000000):
    temp += i
end = time.clock()
print 'one million additions took', end - start, 'seconds'
<span class="out">one million additions took 0.13155 seconds</span>
</pre>
    </li>

  </ul>

  <p>
    The real power of a language is in its libraries:
    they are the distilled wisdom and effort
    of all the programmers who have come before us.
    The fastest way to become a more productive programmer
    is to become familiar with them.
  </p>

  <div class="keypoints">
    <h3>Summary</h3>
    <ul>
      <li>Any Python file can be imported as a library.</li>
      <li>The code in a file is executed when it is imported.</li>
      <li>Every Python file is a scope, just like every function.</li>
      <li>Use <code>from <em>library</em> import <em>something</em></code> to import something under its own name.</li>
      <li>Use <code>from <em>library</em> import <em>something</em> as <em>alias</em></code> to import something under the name <code><em>alias</em></code>.</li>
      <li><code>from <em>library</em> import *</code> imports everything in <code><em>library</em></code> under its own name, which is usually a bad idea.</li>
      <li>The <code>math</code> library defines common mathematical constants and functions.</li>
      <li>The system library <code>sys</code> defines constants and functions used in the interpreter itself.</li>
      <li><code>sys.argv</code> is a list of all the command-line arguments used to run the program.</li>
      <li><code>sys.argv[0]</code> is the program's name.</li>
      <li><code>sys.argv[1:]</code> is everything except the program's name.</li>
    </ul>
  </div>

  <div class="challenges">
    <h3>Challenges</h3>

    <ol>

      <li>
        What does this program print?
<pre>
import itertools

for val in itertools.chain('abc', [0, 1, 2]):
    print val
</pre>
      </li>

      <li>
        Some libraries provide <a href="#a:wrapper">wrapper functions</a>
        that add value to existing functions.
        For example,
        the <code>csv</code> module's <code>reader</code> function
        reads values from a file of comma-separated values:
<pre>
import csv

raw = open('data.csv', 'r')
wrapper = csv.reader(raw)
for row in wrapper:
    total = 0.0
    for value in row:
        total += value
    print total
</pre>
        What does <code>csv.reader</code> do
        that simply splitting a string on commas doesn't do?
      </li>

      <li>
        What shell command does the same thing as <code>shutil.copytree</code>?
        What about <code>shutil.rmtree</code>?
      </li>

    </ol>

  </div>

</section>

<section id="s:filter">
  <h2>Building Filters</h2>

  <div class="understand">
    <h3>Learning Objectives</h3>
    <ul>
      <li>Build a program that behaves like a Unix filter.</li>
      <li>Present and explain some heuristics for what should be done in a function and what should be done by its caller.</li>
      <li>Get help interactively in the Python interpreter.</li>
      <li>Provide information to the interactive help system.</li>
      <li>Explain how a file can tell if it's being used as the main program or being loaded as a library.</li>
    </ul>
    <p>
      <span class="duration">30 minutes</span>.
    </p>
  </div>

  <p>
    As well as creating a list of a program's command-line arguments,
    <code>sys</code> also connects the program to standard input,
    standard output,
    and standard error
    (which were introduced in the chapter on <a href="shell.html#s:pipefilter">the Unix shell</a>).
    Here's a typical example of how these variables are used together:
  </p>

<pre>
import sys

def count_lines(reader):
    result = 0
    for line in reader:
        result += 1
    return result

if len(sys.argv) == 1:
    count_lines(sys.stdin)
else:
    for filename in sys.argv[1:]:
        rd = open(filename, 'r')
        count_lines(rd)
        rd.close()
</pre>

  <p class="continue">
    This program looks at <code>sys.argv</code> to see if it was called with any filenames as arguments or not.
    If there were no arguments,
    then <code>sys.argv</code> will only hold the name of the program,
    and its length will be 1.
    In that case, the program reads data from standard input:
  </p>

<pre>
$ <span class="in">python count.py &lt; a.txt</span>
<span class="out">48</span>
</pre>

  <p class="continue">
    Otherwise,
    the program assumes its command-line arguments are the names of files.
    It opens each one in turn,
    counts how many lines are in it,
    and then closes it:
  </p>

<pre>
$ <span class="in">python count.py a.txt b.txt</span>
<span class="out">48
227</span>
</pre>

<div class="box">
  <h3>Who Opens?</h3>

  <p>
    There's a subtle but important difference between <code>count_lines</code>
    and the <code>summarize</code> function we wrote earlier.
    <code>summarize</code> expects a filename as its sole parameter,
    and opens and closes that file itself.
    <code>count_lines</code>,
    on the other hand,
    expects to be given a handle to an already-open file,
    i.e.,
    it expects whoever is calling it to take care of the opening and closing.
  </p>

  <p>
    Why the difference?
    Because we want to use the same <code>count_lines</code> function
    for both the files whose names we're given on the command line,
    and for <code>sys.stdin</code>.
    Putting it another way,
    we can't call <code>open</code> with <code>sys.stdin</code> as a parameter&mdash;it's
    already an open file, not a string&mdash;so
    we have to do our opening before we call the function.
  </p>

  <p>
    We <em>could</em> push responsibility for opening down into the function if we really wanted to,
    so that our main program was just:
  </p>

<pre>
if len(sys.argv) == 1:
    count_lines(sys.stdin)
else:
    for filename in sys.argv[1:]:
        count(filename)
</pre>

  <p class="continue">
    If we do this,
    though,
    the function has to check whether its parameter is a string
    (which we interpret to mean "the name of a file")
    or something else
    (which we hope is an open file we can read from).
    We have to do the same check at the end of the function as well
    to close the file if we opened it:
  </p>

<pre>
def count_lines(source):
<span class="highlight">    if type(source) == str:
        reader = open(source, 'r')</span>
    result = 0
    for line in reader:
        result += 1
<span class="highlight">    if type(source) == str:
        reader.close()</span>
    return result
</pre>

  <p class="continue">
    Most people find the original easier to understand,
    since it does a better job of separating
    the calculation from the file management.
  </p>

</div>

  <p>
    Let's go back to our original program
    and write it a little more politely:
  </p>

<pre>
'''Count lines in files.  If no filename arguments given,
read from standard input.'''

import sys

def count_lines(reader):
  '''Return number of lines in text read from reader.'''
  return len(reader.readlines())

if __name__ == '__main__':
  if len(sys.argv) == 1:
    print count_lines(sys.stdin)
  else:
    r = open(sys.argv[1], 'r')
    print count_lines(r)
    r.close()
</pre>

  <p class="continue">
    The two significant changes are
    the strings at the start of the module and of the function <code>count_lines</code>,
    and the funny-looking line that compares <code>__name__</code> to <code>'__main__'</code>.
    Let's look at them in that order.
  </p>

  <p>
    To help us find our way around libraries,
    Python provides a <code>help</code> function.
    If <code>math</code> has been imported,
    the call <code>help(math)</code> prints out the documentation embedded in the math library:
  </p>

<pre>
import math
help(math)
<span class="out">Help on module math:
NAME
    math
FILE
    /usr/lib/python2.5/lib-dynload/math.so
MODULE DOCS
    http://www.python.org/doc/current/lib/module-math.html
DESCRIPTION
    This module is always available.  It provides access to the
    mathematical functions defined by the C standard.
FUNCTIONS
    acos(...)
        acos(x)
        Return the arc cosine (measured in radians) of x.
    &hellip;        &hellip;        &hellip;</span>
</pre>

  <p>
    Here's how this works.
    If the first thing in a module or function other than blank lines or comments is a string,
    and that string isn't assigned to a variable,
    Python saves it as the documentation string,
    or <a href="glossary.html#docstring">docstring</a>,
    for that module or function.
    These docstrings are what online (and offline) help display.
    For example,
    let's create a file <code>adder.py</code> with a single function <code>add</code>,
    and write docstrings for both the module and the function:
  </p>

<pre src="python/adder.py">
<span class="comment"># adder.py</span>
'''Addition utilities.'''

def add(a, b):
  '''Add arguments.'''
  return a+b
</pre>

  <p class="continue">
    If we import <code>adder</code>,
    <code>help(adder)</code> prints out all of its docstrings,
    i.e., the documentation for the module itself and for all of its functions:
  </p>

<pre>
import adder
help(adder)
<span class="out">NAME
    adder - Addition utilities.
FUNCTIONS
    add(a, b)
        Add arguments.</span>
</pre>

  <p class="continue">
    We can also be more selective,
    and only display the help for a particular function instead:
  </p>

<pre>
&gt;&gt;&gt; help(adder.add)
<span class="out">add(a, b)
       Add arguments.</span>
</pre>

  <p>
    The second part of our more polite program was that odd-looking <code>if</code> statement.
    It depends on a trick to do something useful,
    and that trick needs a bit of explaining.
    When Python reads in a file,
    it assigns a value to a special variable called <code>__name__</code>
    (with two underscores before and after).
    If the file is being run as the main program,
    <code>__name__</code> is assigned the string <code>'__main__'</code>
    (again with two underscores before and after).
    If the file is being loaded as a module by some other program,
    though,
    Python assigns the module's name to <code>__name__</code> instead.
    To show this in action,
    let's create a Python file called <code>my_name.py</code>
    that does nothing but print out the value of <code>__main__</code>:
  </p>

<pre>
print __name__
</pre>

  <p class="continue">
    If we run it directly from the command line,
    it tells us that <code>__name__</code> has the value <code>'__main__'</code>:
  </p>

<pre>
$ <span class="in">python my_name.py</span>
<span class="out">__name__</span>
</pre>

  <p class="continue">
    If we import this file into an interactive Python session,
    though,
    what's printed out during the import is different:
  </p>

<pre>
$ <span class="in">python</span>
&gt;&gt;&gt; import my_name
<span class="out">my_name</span>
</pre>

  <p class="continue">
    We get the same behavior if we import <code>my_name</code> into another program:
  </p>

<pre>
$ <span class="in">cat test_import.py</span>
<span class="out">import my_name</span>
$ <span class="in">python test_import.py</span>
<span class="out">my_name</span>
</pre>

  <p>
    Now,
    suppose that a file contains the conditional statement
    <code>if __name__ == '__main__'</code>.
    The code inside the <code>if</code> will only run if the file is the main program,
    because that's the only situation in which <code>__name__</code> will be <code>'__main__'</code>.
    Put another way,
    the statements inside the conditional will <em>not</em> be run
    if the file is being loaded as a library by some other program.
    This makes it easy to write modules
    that can be used as both programs in their own right,
    and as libraries by other pieces of code.
  </p>

  <p>
    For example,
    the file <code>stats.py</code> defines a function <code>average</code>,
    and then runs three simple tests&mdash;but
    only if <code>__name__</code> has the value <code>'__main__'</code>:
  </p>

<pre>
# stats.py
'''Useful statistical tools.'''

def average(values):
  '''Return average of values or None if no data.'''
  if values:
    return sum(values) / len(values)
  else:
    return None

if __name__ == '__main__':
  print 'test 1 should be None:', average([])
  print 'test 2 should be 1:', average([1])
  print 'test 3 should be 2:', average([1, 2, 3])
</pre>

  <p class="continue">
    If we import this file into an interactive session,
    it doesn't produce any output,
    because <code>stats.__name__</code> has been assigned the value <code>'stats'</code>:
  </p>

<pre>
import stats
print stats.__name__
<span class="out">stats</span>
</pre>

  <p class="continue">
    If we run this file directly, though,
    that same <code>__name__</code> variable will be assigned the value <code>'__main__'</code>,
    so the test <em>will</em> be run:
  </p>

<pre>
$ <span class="in">python stats.py</span>
<span class="out">test 1 should be None: None
test 2 should be 1: 1
test 3 should be 2: 2</span>
</pre>

  <p class="continue">
    This is another common design pattern in Python:
    group related functions into a module,
    then put some tests for those functions in the same module
    under <code>if __name__ == '__main__'</code>,
    so that if the module is run as the main program,
    it will check itself.
  </p>

  <div class="box">
    <h3>How Other Languages Do It</h3>

    <p>          
      The <code>__name__ == 'main'</code> idiom is
      one of the few things that Python got wrong:
      it's economical,
      in that it doesn't introduce any special-purpose machinery that doesn't have to be there anyway,
      but novices have to master several difficult concepts
      before they can understand how it works.
    </p>

    <p>
      Other languages handle the "where do I start?" problem differently.
      C,
      for example,
      expects programs to have a function called <code>main</code>,
      which is automatically invoked to start the program running.
    </p>

  </div>

  <div class="keypoints">
    <h3>Summary</h3>
    <ul>
      <li>If a program isn't told what files to process, it should process standard input.</li>
      <li>Programs that explicitly test values' types are more brittle than ones that rely on those values' common properties.</li>
      <li>The variable <code>__name__</code> is assigned the string <code>'__main__'</code> in a module when that module is the main program, and the module's name when it is imported by something else.</li>
      <li>If the first thing in a module or function is a string that isn't assigned to a variable, that string is used as the module or function's documentation.</li>
      <li>Use <code>help(<em>name</em>)</code> to display the documentation for something.</li>
    </ul>
  </div>

  <div class="challenges">
    <h3>Challenges</h3>

    <p>
      Write <code>head</code> in Python.
      Your program should behave as follows:
    </p>

    <ul>
      <li>
        If it is run with no arguments at all,
        it displays the first 10 lines read from standard input
        (or as many as it can read if there are fewer than 10).
      </li>
      <li>
        If it is run with a single numeric argument N beginning with a '-',
        such as <code>head.py -6</code>,
        it displays the first N lines of input
        (or as many as it can read if there aren't that many).
      </li>
      <li>
        If it is run with one or more filenames as arguments,
        it displays the first 10 lines of each
        (or as many as it can).
      </li>
      <li>
        If it is run with both '-N' and one or more filenames,
        it displays the first N lines of each file.
      </li>
    </ul>

    <p>
      Think carefully about how to break this problem into functions.
      As a bonus,
      make it possible for someone to do this:
    </p>

<pre>
from head import head
reader = open('somefile.txt', 'r')
lines = head.head(reader, 22)
reader.close()
</pre>

    <p class="continue">
      to get the first 22 lines from <code>somefile.txt</code>.
    </p>

  </div>

</section>

<section id="s:summary">
  <h2>Summing Up</h2>

  <p>
    Novices (and people looking for an argument) often ask,
    "What's the best programming language?"
    The answer depends on what we want to do.
    If we want to write small programs quickly,
    and be able to manage the complexity of larger ones,
    then dynamic languages like Python, Ruby, R, and MATLAB are good choices:
    they optimize programming time over execution time.
    If we want to squeeze the last ounce of performance out of our hardware,
    then compiled languages like C++, C#, and modern dialects of Fortran
    are currently better options.
    And if we want a user interface that runs (almost) everywhere,
    Javascript has become a surprisingly strong contender.
  </p>

  <p>
    Functions are a way to divide code up into more comprehensible pieces:
    essentially,
    to replace several pieces of information with one to make the whole easier to understand.
    Functions are therefore not just about eliminating redundancy:
    they are worth writing even if they're only called once.
  </p>

  <p>
    In fact,
    functions are such a powerful idea that
    many people regard programming as the art of defining a mini-language
    in which the solution to the original problem is trivial.
    To close off this chapter,
    let's try to answer a frequently-asked question:
    when should we write functions?
    And what should we put in them?
  </p>

  <p>
    The answers to these questions depend on the fact that
    human short-term memory can only hold a few things at a time.
    If we try to remember more than a double handful of unrelated bits of information
    for more than a few seconds,
    they become jumbled and we start making mistakes.
    In particular,
    if someone has to keep several dozen things straight in their mind
    in order to understand a piece of code,
    that code is too long.
  </p>

  <p>
    Let's consider an example:
  </p>

<pre>
for x in range(1, GRID_WIDTH-1):
    for y in range(1, GRID_HEIGHT-1):
        if (density[x-1][y] &gt; density_threshold) or \
           (density[x+1][y] &gt; density_threshold):
            if (flow[x][y-1] &lt; flow_threshold) or\
               (flow[x][y+1] &lt; flow_threshold):
                temp = (density[x-1][y] + density[x+1][y]) / 2
                if abs(temp - density[x][y]) &gt; update_threshold:
                    density[x][y] = temp
</pre>

  <p class="continue">
    This code uses meaningful variable names,
    and is well structured,
    but it's a lot to digest in one go.
    Let's replace the loop bounds with function calls
    that give us a bit more context:
  </p>

<pre>
for x in grid_interior(GRID_WIDTH):
    for y in grid_interior(GRID_HEIGHT):
        if (density[x-1][y] &gt; density_threshold) or \
           (density[x+1][y] &gt; density_threshold):
            if (flow[x][y-1] &lt; flow_threshold) or\
               (flow[x][y+1] &lt; flow_threshold):
                temp = (density[x-1][y] + density[x+1][y]) / 2
                if abs(temp - density[x][y]) &gt; update_threshold:
                    density[x][y] = temp
</pre>

  <p class="continue">
    <code>grid_interior(num)</code> might just return <code>range(1, num-1)</code>,
    but try reading the first two lines of this code aloud,
    and then the first two lines of what it replaced,
    and see which is easier to understand.
  </p>

  <p>
    Now let's replace those two <code>if</code> statements with function calls as well:
  </p>

<pre>
for x in grid_interior(GRID_WIDTH):
    for y in grid_interior(GRID_HEIGHT):
        if density_exceeds(density, x, y, density_threshold):
            if flow_exceeds(flow, x, y, flow_threshold):
                temp = (density[x-1][y] + density[x+1][y]) / 2
                if abs(temp - density[x][y]) > tolerance:
                    density[x][y] = temp
</pre>

  <p class="continue">
    Again, we've provided more information about what we're actually doing.
    Finally,
    let's use functions to generate the interior of our grid
    and handle updates to our data structure:
  </p>

<pre>
for (x, y) in grid_interior(GRID_WIDTH, GRID_HEIGHT):
    if density_exceeds(density, x, y, density_threshold):
        if flow_exceeds(flow, x, y, flow_threshold):
            update_on_tolerance(density, x, y, tolerance)
</pre>

  <p class="continue">
    Our original nine lines have become four,
    and those four are all at the same mental level.
    It's hard to pin down exactly what that phrase means,
    but most programmers would agree that
    the first version mixed high-level ideas about boundaries and update conditions
    with low-level details of grid access and cell value comparisons.
    In contrast,
    this version only has the high-level stuff;
    the low-level implementation details are hidden in those functions.
  </p>

  <p>
    A conscientious programmer who wrote the code we started with
    would go back and <a href="glossary.html#refactor">refactor</a> it
    to turn it into something like our final version
    before committing it to <a href="svn.html">version control</a>.
    If she did this often enough,
    she would eventually find herself writing the final version first,
    just as mathematicians find themselves skipping more and more "obvious" steps
    as they do more proofs.
    When we see someone "just writing" something elegant,
    the odds are good that they have spent time rewriting their own poor code,
    and in doing so,
    turned conscious decision into unconscious action.
  </p>

</section>
{% endblock content %}
