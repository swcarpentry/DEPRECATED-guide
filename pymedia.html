{% extends "templates/_base.html" %}

{% block file_metadata %}
  <meta name="title" content="Basic Programming With Python and Images" />
  <meta name="status" content="Still being written" />
{% endblock file_metadata %}

{% block content %}

<p>
  Valerie Visual is studying human visual processing.
  More specifically,
  she is studying the way the brain interprets missing or noisy information.
  For one of her experiments,
  she wants to introduce successively larger amounts of random noise into a series of pictures
  to see when different people start to notice that something is wrong.
</p>

<p>
  If Valerie only wanted one or two images,
  the simplest way to create them might be
  to use a tool like Photoshop.
  However,
  she wants to show each test subject several hundred images.
  What she <em>doesn't</em> want to do is
  spend more time creating those images
  than actually running her experiments.
  She's going to have to learn how to program,
  and that's what this lesson is about.
</p>

<p>
  We will use a programming language called Python for our examples.
  Python is free,
  reasonably well documented,
  and widely used in science and engineering.
  Our main reason for choosing it,
  though,
  is that newcomers find it easier to read than most other languages.
  It also allows people to do useful things
  without having to master advanced concepts like object-oriented programming.
</p>

<p>
  The particular version of Python we'll use is called IPython.
  It was developed by and for scientists,
  and comes with many extra tools which we'll explore as we go along.
  The most important of these is an electronic lab notebook
  that allows us to view and annotate our work as we go along.
</p>

<p>
  Finally,
  our programs will use two libraries
  that were specifically written for novices.
  Both work on grids of pixels,
  but the first does this directly in the browser,
  so that we can see what we're doing as we go along,
  while the second manipulates photographs and other image files.
</p>

<section id="s:basic">
  <h2>Basic Operations</h2>

  <div class="understand">
    <h3>Learning Objectives</h3>
    <ul>
      <li>Run and use the IPython Notebook.</li>
      <li>Do basic arithmetic in Python.</li>
      <li>Assign values to variables, and use those variables in expressions.</li>
      <li>Explain how variable names should be chosen, and choose appropriate names for variables.</li>
    </ul>
  </div>

  <p>
    The best way to learn how to program is to start programming,
    so open a shell and run the IPython Notebook by typing:
  </p>

<pre>
$ <span class="in">ipython notebook</span>
<span class="out">[NotebookApp] Using existing profile dir: u'/Users/gwilson/.ipython/profile_default'
[NotebookApp] Serving notebooks from /Users/gwilson
[NotebookApp] The IPython Notebook is running at: http://127.0.0.1:8888/
[NotebookApp] Use Control-C to stop this server and shut down all kernels.</span>
</pre>

  <p class="continue">
    If everything has been installed correctly,
    you will see something like the output shown above,
    which tells you that IPython has started running.
    You will also see something like <a href="#f:ipython_welcome">Figure XXX</a>
    in your browser.
  </p>

  <figure id="f:ipython_welcome">
    <img src="pymedia/ipython_welcome.png" alt="IPython Notebook Startup Screen" />
    <figcaption>Figure XXX: IPython Notebook Startup Screen</figcaption>
  </figure>

  <figure id="f:empty_notebook">
    <img src="pymedia/empty_notebook.png" alt="An Empty Notebook" />
    <figcaption>Figure XXX: An Empty Notebook</figcaption>
  </figure>

  <p>
    If you click on the "New Notebook" button,
    a new tab will open in your browser
    with an empty notebook
    (<a href="#f:empty_notebook">Figure XXX</a>).
    At this point, you're ready to go,
    so type the following line into the text box
    and choose "Run" from the "Cell" menu.
    You should get the output shown
    (<a href="#f:first_computation">Figure XXX</a>).
  </p>

<pre>
<span class="in">print 1 + 1</span>
<span class="out">2</span>
</pre>

  <figure id="f:first_computation">
    <img src="pymedia/first_computation.png" alt="Our First Computation" />
    <figcaption>Figure XXX: Our First Computation</figcaption>
  </figure>

  <p>
    <a href="#f:architecture">Figure XXX</a> shows what just happened.
    When we type something into the notebook and run it,
    the browser sends the contents of the cell to IPython,
    which is running in the background.
    IPython runs our commands and sends output back to the browser,
    which displays it
    and gives us another box for input.
  </p>

  <figure id="f:architecture">
    <img src="pymedia/architecture.png" alt="The Architecture of the IPython Notebook" />
    <figcaption>Figure XXX: The Architecture of the IPython Notebook</figcaption>
  </figure>

  <div class="box">
    <h3>Shortcuts</h3>
    <p>
      We can access all of the Notebook's commands through its menus,
      but it's often easier to use keyboard shortcuts.
      Typing Control-M follows by 'h' (for "help") displays a list of these;
      along with the usual copy, paste, and delete,
      the most commonly used are:
    </p>
    <table>
      <tr>
        <td>Shift-Enter</td>
        <td>Run the current cell and move to the next one.</td>
      </tr>
      <tr>
        <td>Control-Enter</td>
        <td>Run the current cell and stay in it.</td>
      </tr>
      <tr>
        <td>Control-M + L</td>
        <td>Turn line numbering on or off.</td>
      </tr>
      <tr>
        <td>Control-M + A</td>
        <td>Insert a new cell above the current one.</td>
      </tr>
      <tr>
        <td>Control-M + B</td>
        <td>Insert a new cell below the current one.</td>
      </tr>
    </table>
  </div>

  <p>
    Now enter and run this:
  </p>

<pre>
<span class="in">x = 1+1</span>
</pre>

  <p class="continue">
    Python doesn't display anything this time
    (except a new cell).
    Instead,
    as <a href="#f:first_variable">Figure XXX</a> shows,
    it creates a <a href="glossary.html#variable">variable</a> called <code>x</code>
    and assigns it the value 2.
    We can then get that variable's value simply by entering its name:
  </p>

<pre>
<span class="in">print x</span>
<span class="out">2</span>
</pre>

  <figure id="f:first_variable">
    <img src="pymedia/first_variable.png" alt="Our First Variable" />
    <figcaption>Figure XXX: Our First Variable</figcaption>
  </figure>

  <div class="box">

    <h3>Statements vs. Expressions</h3>

    <p>
      Python is a fairly relaxed language,
      but there are some things it won't let us do.
      For example,
      this doesn't work:
    </p>

<pre>
print x = 1 + 2
<span class="err">SyntaxError: invalid syntax</span>
</pre>

    <p class="continue">
      The problem is that printing and assignment are both
      <a href="glossary.html#statement">statements</a>,
      and statements cannot be mixed together.
      1+2, on the other hand,
      is an <a href="glossary.html#expression">expression</a>&mdash;something
      that produces a new value&mdash;and expressions can be combined in many ways.
      Except for assignment,
      every statement in Python begins with a keyword like <code>print</code>,
      so it's usually easy to tell them apart.
    </p>

  </div>

  <p>
    We can now use the value of <code>x</code> in new calculations:
  </p>

<pre>
<span class="in">print x * 2</span>
<span class="out">4</span>
</pre>

  <p class="continue">
    including ones that create more variables:
  </p>

<pre>
<span class="in">y = x * 2</span>
<span class="in">print y</span>
<span class="out">4</span>
</pre>

  <p class="continue">
    We can change a variable's value
    by assigning something new to it:
  </p>

<pre>
<span class="in">x = 10</span>
<span class="in">print x</span>
<span class="out">10</span>
</pre>

  <p class="continue">
    As <a href="#f:assign_new_value">Figure XXX</a> shows,
    assigning something to <code>x</code> changes what it points to,
    but does not change anything else.
    In particular,
    <code>y</code> still has the value 4 after this assignment:
    it is not automatically updated when <code>x</code>'s value changes,
    as it would in a spreadsheet.
  </p>

  <figure id="f:assign_new_value">
    <img src="pymedia/assign_new_value.png" alt="Assigning a New Value" />
    <figcaption>Figure XXX: Assigning a New Value</figcaption>
  </figure>

  <p>
    Notice,
    by the way,
    that some of our input cells contain several lines of Python.
    Referring back to <a href="#f:architecture">Figure XXX</a>,
    everything in a cell is sent to IPython for execution at once,
    and all of the output from those lines comes back as a single new output cell.
  </p>

  <div class="box">
    <h3>When to Print</h3>
    <p class="fixme">explain that only the last line of raw input produces output, and recommend print</p>
  </div>

  <p>
    Here's a more complex calculation:
  </p>

<pre>
<span class="in">x = 98.6</span>
<span class="in">y = (x - 32.0) * (5.0 / 9.0) + 273.15</span>
<span class="in">print y</span>
<span class="out">310.15</span>
</pre>

  <p class="continue">
    Its meaning becomes clearer if we rewrite it as:
  </p>

<pre>
<span class="in">temp_fahr = 98.6</span>
<span class="in">temp_kelvin = (temp_fahr - 32.0) * (5.0 / 9.0) + 273.15</span>
<span class="in">print "body temperature in Kelvin:", temp_kelvin</span>
<span class="out">body temperature in Kelvin: 310.15</span>
</pre>

  <p>
    The first line creates a new variable called <code>temp_fahr</code>
    (short for "temperature in Fahrenheit")
    and gives it the value 98.6
    (<a href="#f:first_memory_model">Figure XXX</a>).
    The second line creates another variable to hold the temperature in Kelvin
    (hence its name).
    It calculates a value for this variable
    that depends on the value of <code>temp_fahr</code>.
    The last line prints the result.
    The <a href="glossary.html#string">character string</a>
    (or just "string" for short)
    inside double quotes is printed as-is,
    followed by the value of <code>temp_kelvin</code>.
  </p>

  <figure id="f:first_memory_model">
    <img src="pymedia/first_memory_model.png" alt="First Memory Model" />
    <figcaption>Figure XXX: First Memory Model</figcaption>
  </figure>

  <p>
    Like every program,
    this one stores data and does calculations.
    We use variables to do the first,
    and write instructions that use those variables to do the second.
    And like every <em>good</em> program,
    it is written with human beings in mind.
    Computers get faster every year,
    but our brains don't.
    As a result,
    the biggest bottleneck in scientific computing is often not how fast the program is,
    but how long it takes us to write it.
    This is why we use variable names like <code>temp_fahr</code> and <code>temp_kelvin</code>
    instead of <code>x</code> and <code>y</code>:
    they optimize the performance of the most expensive hardware we have.
  </p>

  <div class="box" id="a:creating-variables">
    <h3>Creating Variables</h3>

    <p>
      Python creates a variable whenever a value is assigned to a name,
      but won't let us get the value of a variable that hasn't been assigned one.
      For example,
      if we try to do this:
    </p>

<pre>
<span class="in">double_temp = temp_celsius * 2</span>
</pre>

    <p class="continue">
      then Python prints an error message:
    </p>

<pre>
<span class="err">NameError                                 Traceback (most recent call last)
&lt;ipython-input-7-0fae4d15df1c&gt; in &lt;module&gt;()
----&gt; 1 double_temp = temp_celsius * 2

NameError: name 'temp_celsius' is not defined</span>
</pre>

    <p class="continue">
      We'll explain what "module" means <a href="funclib.html">later</a>.
      What's important now is that this strictness helps catch a lot of typing mistakes.
      If we mistakenly type <code>temp_far</code> instead of <code>temp_fahr</code>:
    </p>

<pre>
<span class="in">temp_kelvin = (<span class="highlight">temp_far</span> - 32.0) * (5.0 / 9.0) + 273.15</span>
</pre>

    <p class="continue">
      then Python will tell us something's gone wrong.
      It can't help us if we type 3.20 instead of 32.0, though;
      if we want to catch that mistake,
      we'll actually have to <a href="quality.html">test our program</a>.
    </p>

  </div>

  <p>
    Readability is also why we put the temperature in Fahrenheit in a variable,
    then use that variable in line 2,
    rather than just putting 98.6 directly in the calculation.
    If we ever want to convert another temperature,
    it's easier to see and change the value on line 1
    than it would be to find it buried in the middle of a line of arithmetic.
  </p>

  <div class="box">
    <h3>Tab Completion</h3>

    <p>
      Using longer variable names doesn't necessarily mean doing more typing.
      Like the shell,
      IPython supports <a href="shell.html#a:tab-completion">tab completion</a>:
      if we have created variables called <code>temp_fahr</code> and <code>temp_kelvin</code>,
      then type "te" and press tab,
      the notebook will display a list of completions for us to choose from
      (<a href="#f:tab_completion">Figure XXX</a>.
      If we get as far as typing "temp_f" and press tab,
      the rest of the name will be filled in completely
      because there's only one possible choice.
    </p>

    <figure id="f:tab_completion">
      <img src="pymedia/tab_completion.png" alt="Tab Completion" />
      <figcaption>Figure XXX: Tab Completion</figcaption>
    </figure>

    <p>
      After a while,
      some programmers start to choose variable names to optimize tab completion
      (whether they're conscious of doing so or not).
      For example,
      they might use <code>t_fahr</code> and <code>t_kelvin</code> for temperatures
      so that they only have to type three characters and press tab
      to fill in the rest of the variable name.
      Others find that using slightly longer but more comprehensible names
      is a better balance between typing time and reading time.
      The most important thing is to be consistent:
      every inconsistency in naming costs extra time to read.
    </p>
  </div>

  <p>
    Finally,
    our first few programs show how arithmetic is done.
    '+' means addition,
    '*' means multiplication,
    and parentheses group things together,
    just as they do in pen-and-paper arithmetic.
  </p>

  <div class="keypoints">
    <h3>Summary</h3>
    <ul>
      <li>Use '=' to assign a value to a variable.</li>
      <li>Variables are created when values are assigned to them.</li>
      <li>Variables cannot be used until they have been created.</li>
      <li>Assigning to one variable does not change the values associated with other variables.</li>
      <li>Use <code>print</code> to display multiple values at once.</li>
      <li>Addition ('+'), subtraction ('-'), and multiplication ('*') work as usual in Python.</li>
      <li>Using readable names for variables improves programmer performance.</li>
    </ul>
  </div>

  <div class="challenges">
    <h3>Challenges</h3>
    <p class="fixme">write some challenges</p>
  </div>

</section>

<section id="s:types">
  <h2>Types</h2>

  <div class="understand">
    <h3>Learning Objectives</h3>
    <ul>
      <li>Explain what a data type is.</li>
      <li>Identify the types of integers, floating-point numbers, and strings.</li>
      <li>Call simple built-in functions correctly.</li>
    </ul>
  </div>

  <p>
    Let's take another look at the Python we have written so far:
  </p>

<pre>
<span class="in">temp_fahr = 98.6</span>
<span class="in">temp_kelvin = (temp_fahr - 32.0) * (5.0 / 9.0) + 273.15</span>
<span class="in">print "body temperature in Kelvin:", temp_kelvin</span>
<span class="out">body temperature in Kelvin: 310.15</span>
</pre>

  <p>
    Why have we written 5.0/9.0 instead of 5/9?
    Let's see what happens if we take out the .0's:
  </p>

<pre>
<span class="in">temp_fahr = 98.6</span>
<span class="highlight">temp_kelvin = (temp_fahr - 32) * (5 / 9) + 273.15</span>
<span class="in">print "body temperature in Kelvin:", temp_kelvin</span>
<span class="out">body temperature in Kelvin: 273.15</span>
</pre>

  <p>
    That's not right.
    To understand what's gone wrong,
    let's look at 5/9:
  </p>

<pre>
<span class="in">5/9</span>
<span class="out">0</span>
</pre>

  <p>
    The problem is that the computer treats integers and floating point numbers differently.
    If a number doesn't have a decimal point,
    then Python stores its value as an integer
    with no fractional part.
    And when it divides one integer by another,
    it throws away the remainder:
    to a computer,
    5/2 is 2, not 2.5.
  </p>

  <p>
    If a number contains a decimal point,
    though,
    Python stores it as a floating-point number
    (or <a href="glossary.html#float">float</a>).
    When it does division or any other kind of arithmetic,
    the result is a float if either of the values involved is a float:
  </p>

<pre>
<span class="in">10 / 3</span>
<span class="out">3</span>
<span class="in">10.0 / 3</span>
<span class="out">3.3333333333333335</span>
</pre>

  <p class="continue">
    Version 3 of Python changed the rules for division
    so that it creates fractional numbers when it should.
    However,
    we're using Python 2.7,
    so 10/3 is 3 until further notice.
  </p>

  <div class="box">
    <h3>Remainder</h3>
    <p>
      Python has another "division" operator,
      written '%',
      which returns the remainder that integer division throws away:
    </p>
<pre>
<span class="in">10 % 3</span>
<span class="out">1</span>
<span class="in">15 % 6</span>
<span class="out">3</span>
</pre>
  </div>

  <p>
    Integers and floats are two <a href="glossary.html#type">types</a> of data.
    Every value in a program has a specific type
    that determines how it behaves and what can be done to it.
    We can find out what type something is
    using a built-in <a href="glossary.html#function">function</a> called <code>type</code>:
  </p>

<pre>
<span class="in">type(12)</span>
<span class="out">&lt;type 'int&gt;</span>
<span class="in">type(12.0)</span>
<span class="out">&lt;type 'float&gt;</span>
</pre>

  <p>
    Another common data type is the character string.
    We can create one by putting characters inside either single or double quotes
    (as long as we use the same kind at the beginning and end):
  </p>

<pre>
<span class="in">name = "Alan Turing"</span>
<span class="in">born = 'June 23, 1912'</span>
<span class="in">print name, born</span>
<span class="out">Alan Turing June 23, 1912</span>
</pre>

  <p>
    We can also "add" and "multiply" strings:
  </p>

<pre>
<span class="in">full = name + " (" + born + ")"</span>
<span class="in">print full</span>
<span class="out">Alan Turing (June 23, 1912)</span>
<span class="in">print "ho" * 3</span>
<span class="out">hohoho</span>
</pre>

  <p id="a:add-num-str">
    What we <em>can't</em> do is add numbers and strings:
  </p>

<pre>
<span class="in">print 2 + "three"</span>
<span class="err">TypeError                                 Traceback (most recent call last)
&lt;ipython-input-8-f6f99c093ec8&gt; in &lt;module&gt;()
----&gt; 1 print 2 + "three"

TypeError: unsupported operand type(s) for +: 'int' and 'str'</span>
</pre>

  <p>
    The reason we can't is that
    "2three" would be a reasonable result in this case,
    but it's not so clear what <code>2+"3"</code> should do:
    should it produce the integer 5 or the string <code>"23"</code>?
    Rather than guessing at the programmer's intentions,
    Python requires us to tell it
    whether to convert the number to a string or the string to a number
    so that it knows what kind of addition to do.
    We do this using <code>int</code> and <code>str</code>,
    which are two more built-in functions:
  </p>

<pre>
<span class="in">print 2 + int("3")</span>
<span class="out">5</span>
<span class="in">print str(2) + "3"</span>
<span class="out">23</span>
</pre>

  <p>
    Finally,
    it's important to keep in mind that variables don't have types in Python:
    only values do.
    A variable is a just a name for a value;
    it can refer to a string at one point in a program,
    and a float at another:
  </p>

<pre>
<span class="in">temp = 'temperature'</span>
<span class="in">print temp, type(temp)</span>
<span class="out">temperature &lt;type 'str'&gt;</span>
<span class="in">temp = 37.2</span>
<span class="in">print temp, type(temp)</span>
<span class="out">37.2 &lt;type 'float'&gt;</span>
</pre>

  <div class="box">
    <h3>Static vs. Dynamic Typing</h3>
    <p>
      Programmers argue incessantly about whether this is a good idea or not.
      In <a href="glossary.html#static-typing">statically-typed</a> languages like Fortran, C++, Java, and Haskell,
      every variable has a type,
      and can only store values of that type.
      Proponents say that
      this restriction makes it easier for compilers to optimize programs,
      and for other tools (and human readers) to check their correctness,
      but languages designed for interactive use&mdash;like Python,
      Perl, and R&mdash;tend to be
      <a href="glossary.html#dynamic-typing">dynamically typed</a>
      in order to keep typing&mdash;the fingers-on-keyboard kind&mdash;to a minimum.
    </p>
  </div>

  <div class="keypoints">
    <h3>Summary</h3>
    <ul>
      <li>The most commonly used data types in Python are integers (<code>int</code>), floating-point numbers (<code>float</code>), and strings (<code>str</code>).</li>
      <li>Strings can start and end with either single quote (') or double quote (&quot;).</li>
      <li>Division ('/') produces an <code>int</code> result when given <code>int</code> values: one or both arguments must be <code>float</code> to get a <code>float</code> result.</li>
      <li>The modulo operator ('%') produces the remainder from integer division.</li>
      <li>"Adding" strings concatenates them, multiplying strings by numbers repeats them.</li>
      <li>Strings and numbers cannot be added because the behavior is ambiguous: convert one to the other type first.</li>
      <li>Variables in Python do not have types, but values do.</li>
    </ul>
  </div>

  <div class="challenges">
    <h3>Challenges</h3>
    <p class="fixme">write some challenges</p>
  </div>

</section>

<section id="s:lib">
  <h2>Libraries, Blocks, and Colors</h2>

  <div class="understand">
    <h3>Learning Objectives</h3>
    <ul>
      <li>Explain what a library is and why programmers use them.</li>
      <li>Import a library and use its contents.</li>
      <li>Create and manipulate block images using IPythonBlocks.</li>
      <li>Explain how colors are represented in a computer.</li>
      <li>Create specific colors numerically.</li>
    </ul>
  </div>

  <p>
    Now that we can do basic arithmetic,
    let's look at where the real power of most programming languages is.
    Run this in an IPython Notebook cell:
  </p>

<pre>
<span class="in">import math
print "pi is", math.pi
print "square root of 5 is", math.sqrt(5)</span>
<span class="out">pi is 3.14159265359
square root of 5 is 2.2360679775</span>
</pre>

  <p>
    The first line in this cell is the most important.
    It tells Python to find a library called <code>math</code>
    and load it into our program.
    We can then refer to the variables defined inside that library,
    like &pi;,
    as <code><em>library</em>.<em>variable</em></code>,
    and call its functions,
    like square root,
    as <code><em>library</em>.<em>function</em></code>,
  </p>

  <p>
    Two-part names are used because
    many different libraries can define variables or functions with the same names.
    For example,
    <code>math.log</code> returns the natural logarithm of a number,
    while <code>server.log</code>
    (i.e., the <code>log</code> function defined by the <code>server</code> library)
    writes a log message to a file.
    It's exactly like saying "Valerie's paper" rather than just "the paper".
  </p>

  <div class="box">
    <h3>Shortcuts</h3>

    <p>
      Since <code>math.sqrt</code> is a handful to type,
      and <code>sqrt</code> is probably not ambiguous,
      Python provides several ways to import things.
      For example,
      we can import specific functions from a library and then call them directly:
    </p>

<pre>
<span class="in">from math import sqrt
sqrt(3)</span>
<span class="out">1.7320508075688772</span>
</pre>

    <p class="continue">
      We can also import a function under a different name,
      so that if two modules define functions with the same name,
      we can give one or the other a different name when we want to use them together:
    </p>

<pre>
<span class="in">from math import hypot as euclid
euclid(3, 4)</span>
<span class="out">5.0</span>
</pre>

    <p>
      Finally,
      we can use <code>import *</code>
      to bring everything in the module into the current scope at once.
      This has the same effect as using <code>from module import a</code>,
      <code>from module import b</code>,
      and so on for every name in the module:
    </p>

<pre>
<span class="in">from math import *
sin(pi)</span>
<span class="out">1.2246063538223773e-16</span>
</pre>

    <p class="continue">
      <code>import *</code> is usually a bad idea:
      if someone adds a new function or variable to the next version of the module,
      your <code>import *</code> could silently overwrite something that you have written,
      or are importing from somewhere else.
      Bugs like this can be extremely hard to find,
      since nothing seemed to change in your program.
    </p>
  </div>

  <p>
    We now have everything we need to start drawing pictures.
    Let's start with a simple grid of pixels:
  </p>

<pre>
<span class="in">from ipythonblocks import BlockGrid
grid = BlockGrid(10, 5)
grid.show()</span>
FIXME: output
</pre>

  <p class="continue">
    The first line loads something called <code>BlockGrid</code>
    from the <code>ipythonblocks</code> library.
    <code>BlockGrid</code> isn't actually a function&mdash;it's something
    called a <a href="glossary.html#class">class</a> that we'll discuss later&mdash;but
    it works like one for present purposes.
    When we give it two integers,
    it creates a grid of blocks of the specified width and height.
    We can assign that to a variable
    (in this case, called <code>grid</code>),
    and then ask it to show itself.
  </p>

  <p>
    We can ask a grid what it's height and width are
    using the same dotted notation we use
    to ask a library for the things it contains:
  </p>

<pre>
<span class="in">print 'width:', grid.width
print 'height', grid.height</span>
<span class="out">width: 10
height: 5</span>
</pre>

  <p>
    We can't change these values, though:
  </p>

<pre>
<span class="in">grid.width = 100</span>
<span class="err">AttributeError                            Traceback (most recent call last)
&lt;ipython-input-21-38b1940fb9ea&gt; in &lt;module&gt;()
----&gt; 1 grid.width=100

AttributeError: can't set attribute</span>
</pre>

  <p class="continue">
    The reason is the same as the one given <a href="#a:add-num-str">earlier</a>:
    if we enlarged the grid,
    Python would have to guess what colors to use for the new blocks.
    We could tell it,
    but to do that,
    we need a way to define colors.
  </p>

  <p>
    Luckily,
    we have one&mdash;in fact, we have several.
    The most common,
    called "RGB",
    defines colors according to how much red, green, and blue they contain.
    This is an additive color model:
    the color we see is the sum of the individual color values,
    each of which can range between 0 and 255.
    Why 255?
    Because computer memory is organized into 8-bit bytes,
    and 255 (11111111 in base 2) is the largest integer that can be represented in one byte.
  </p>

  <p>
    In RGB,
    black is (0, 0, 0), i.e., nothing of any color.
    White is the maximum value of all three colors, or (255, 255, 255).
    We can think of this color model is as a cube
    (<a href="#f:color_cube">Figure XXX</a>).:
    the three axes represent the primary colors,
    while secondary colors are combinations of maximum values,
    and each actual color is a coordinate in this cube.
  </p>

  <figure id="f:color_cube">
    <img src="pymedia/color_cube.png" alt="A Color Cube" />
    <figcaption>Figure XXX: A Color Cube</figcaption>
  </figure>

  <p>
    The IPythonBlocks library includes a function called <code>show_color</code>
    that we can use to explore the RGB color cube:
  </p>

<pre>
<span class="in">from ipythonblocks import show_color
show_color(255, 0, 0)</span> <span class="comment"># all red</span>
FIXME: output
<span class="in">show_color(0, 255, 0)
show_color(0, 0, 255)</span>
FIXME: output
<span class="in">show_color(128, 255, 64)</span>
FIXME: output
</pre>

  <p>
    Let's change one corner of our grid from black to green:
  </p>

<pre>
<span class="in">grid[0, 0] = (0, 255, 0)
grid.show()</span>
FIXME: output
</pre>

  <p>
    There's a lot going on in that assignment statement:
  </p>

  <ol>
    <li>
      A color is one value,
      but we write it in three parts (red, green, and blue).
      To make it clear that we want those three parts grouped together,
      we put them in parentheses,
      as in <code>(0, 255, 0)</code>.
      This is <em>not</em> a function call,
      though parentheses are used for calling functions.
      Instead,
      this is called a <a href="glossary.html#tuple">tuple</a>.
      We'll see many more tuples as we go along.
    </li>
    <li>
      If we want to refer to a particular block in a grid,
      we use a <a href="glossary.html#subscript">subscript</a>
      or <a href="glossary.html#index">index</a>,
      just as we do when referring to a particular element of a matrix in mathematics.
      Since subscripts and superscripts are hard to type,
      we put the subscript values in square brackets
      instead of typesetting them.
    </li>
    <li id="a:count-from-zero">
      The corner's coordinates are (0, 0), not (1, 1).
      Programming languages derived from C (a family that includes Python and Perl) all count from 0,
      for the same reason that color values run from 0 to 255
      instead of 1 to 256.
      Some other languages (notably Fortran, MATLAB, and R) count from 1.
      The latter is more sensible&mdash;nobody says, "Zero, one, two, three, four," when counting their fingers&mdash;but
      we're stuck with the former for programming.
    </li>
  </ol>

  <p>
    Finally,
    look closely at which pixel turned green.
    A Cartesian grid is typically drawn with the origin in the lower left,
    or in the center,
    but IPythonBlocks' coordinate scheme is like that of tables and spreadsheets:
    the first index counts down the rows,
    while the second counts across the columns.
    To prove this,
    let's make the block at (1, 2) red:
  </p>

<pre>
<span class="in">grid[1, 2] = (255, 0, 0)
grid.show()</span>
FIXME: output
</pre>

  <p>
    Changing the color of one block isn't very useful, though:
    if we wanted to draw a picture that way,
    we'd have to write millions of assignment statements.
    What we need is a way to set the colors of many blocks at once,
    which is the subject of the next section.
  </p>

  <div class="challenges">
    <h3>Challenges</h3>
    <p class="fixme">write challenges</p>
  </div>

</section>

<section id="s:for">
  <h2>Repeating Things</h2>

  <div class="understand">
    <h3>Learning Objectives</h3>
    <ul>
      <li>Repeat operations using a <code>for</code> loop.</li>
      <li>Trace the value of a loop variable.</li>
      <li>Use the <code>range</code> function to loop over a range of integers.</li>
    </ul>
  </div>

  <p>
    Computers are useful because they can do lots of calculations on lots of data,
    which means we need a concise way to represent multiple steps.
    Let's start by printing the vowels in order the hard way:
  </p>

<pre>
<span class="in">print 'a'
print 'e'
print 'i'
print 'o'
print 'u'</span>
<span class="out">a
e
i
o
u</span>
</pre>

  <p>
    Now let's do it the easy way:
  </p>

<pre>
<span class="in">for character in "aeiou":
    print character</span>
<span class="out">a
e
i
o
u</span>
</pre>

  <p>
    The keywords <code>for</code> and <code>in</code> are used to create
    a <a href="glossary.html#for-loop">for loop</a>.
    Just like a <a href="shell.html#loop">loop in the shell</a>,
    a <code>for</code> loop in Python repeats one or more instructions
    for each value in some collection.
    The indented line is called the <a href="glossary.html#loop-body">body</a> of the loop:
    it's what Python executes repeatedly.
    The variable <code>character</code> is the <a href="glossary.html#loop-variable">loop variable</a>:
    each time the loop is executed,
    it is updated to hold the next value from the collection
    (in this case,
    the next character from the string <code>"aeiou"</code>).
    There's nothing magical about its name:
    we could equally well have called it <code>something</code>,
    but using something meaningful makes the program more readable.
  </p>

  <p>
    Here's another loop that updates variables as it goes along:
  </p>

<pre>
<span class="in">result = ""
for character in "aeiou":
    result = result + 2 * character
print result</span>
<span class="out">aaeeiioouu</span>
</pre>

  <p>
    The variable <code>result</code> is initially assigned
    an <a href="glossary.html#empty-string">empty string</a>
    containing no characters.
    The first time the loop executes,
    the program adds "aa" to it;
    the second time,
    it adds "ee",
    and so on to produce the string shown.
  </p>

  <p>
    Notice that Python uses indentation to show what's in the body of a loop.
    In fact,
    it always uses indentation to show what lines of code belong to what.
    To see why this matters,
    try running this program:
  </p>

<pre>
<span class="in">result = ""
for character in "aeiou":
    result = result + 2 * character
<span class="highlight">    print result</span></span>
<span class="out">aa
aaee
aaeeii
aaeeiioo
aaeeiioouu</span>
</pre>

  <p class="continue">
    Since the <code>print</code> statement is inside the loop,
    it is executed once for each <a href="glossary.html#iteration">iteration</a> of the loop,
    so we see five lines of output.
  </p>

  <div class="box">

    <h3>Why Indentation?</h3>

    <p>
      Most other languages use keywords like <code>do</code> and <code>done</code>
      or <code>begin</code> and <code>end</code> to show what's in the body of a loop,
      or the curly braces '{' and '}'.
      Python uses indentation because studies done in the 1970s and 1980s showed
      that's what people actually pay attention to.
      If we write something as:
    </p>

<pre>
for value in data
begin
    print value
print "done"
end
</pre>

    <p class="continue">
      then most people reading the code in a hurry will "see"
      the second <code>print</code> statement as being outside the loop.
    </p>

  </div>

  <p>
    What if we want to do something a certain number of times,
    rather than once for each character in a string?
    Python has a built-in function called <code>range</code>
    that produces the integer 0, 1, 2, and so on up to a certain value:
  <p>

<pre>
<span class="in">for i in range(3):
    print i</span>
<span class="out">0
1
2</span>
</pre>

  <p>
    As discussed <a href="a:count-from-zero">earlier</a>,
    <code>range</code> starts counting at 0,
    not at 1.
    It therefore stops one number short of the argument it's given
    so that it produces the right number of values in total.
  </p>

  <p>
    Using loops,
    it's easy to color in many pixels with just a couple of lines of code:
  </p>

<pre>
<span class="in">grid = BlockGrid(10, 5)
for i in range(10):
    grid[0, i] = (255, 0, 0)
grid.show()</span>
FIXME: output
</pre>

  <p class="fixme">arguments are (X, Y), but coords are (Y, X)</p>

  <p>
    The first line of this little program creates a 10&times;5 grid.
    The next line is a loop that will run 10 times.
    Each time around,
    the next integer in the sequence 0&hellip;9 is assigned to the variable <code>i</code>.
    Inside the loop,
    we use <code>i</code> as the second (column) subscript to <code>grid</code>:
    the first time through the loop,
    we turn the block <code>grid[0, 0]</code> red,
    the next time the block <code>grid[0, 1]</code>,
    then <code>grid[0, 2]</code>
    and so on up to <code>grid[0, 9]</code>
    to fill in the entire row.
  </p>

  <div class="box">
    <h3>When Short Names Are OK</h3>

    <p>
      We said earlier that programs should use meaningful variable names.
      Are we not violating our own rule by using <code>i</code> as a variable in this program?
      The short answer is "yes", but it's a defensible violation.
      Suppose we re-write our loop as:
    </p>

<pre>
<span class="in">for column in range(10):
    grid[0, column] = (255, 0, 0)</span>
</pre>

    <p class="continue">
      The longer name is more meaningful,
      but it also takes longer to read.
      Since the original <code>i</code> is only used for a few lines,
      users will easily be able to keep its meaning in short-term memory
      as long as they need to.
      On balance,
      therefore,
      the short name are better in this case.
    </p>

    <p>
      This is actually a general principle in program design.
      A variable that holds a simple value,
      and is only used in a few adjacent lines of code,
      can (and usually should) have a short name.
      A variable that holds a complex value,
      or one which is used over more than a few lines of code,
      should have a longer name
      in order to optimize the tradeoff between reading speed
      and the limitations of human short-term memory.
    </p>
  </div>

  <p>
    What happens if we use index the grid in the wrong order,
    i.e.,
    run the row coordinate from 0 to 9?
  </p>

<pre>
<span class="in">for i in range(10):
    grid[<span class="highlight">i, 0</span>] = (255, 0, 0)
grid.show()</span>
<span class="err">IndexError                                Traceback (most recent call last)
&lt;ipython-input-36-3a81075e1fb2&gt; in &lt;module&gt;()
      1 for i in range(10):
----&gt; 2     grid[i, 0] = (255, 0, 0)
      3 grid.show()

IndexError: list index out of range</span>
</pre>

  <p>
    Python halts the program with an error because
    we eventually try to change the color of <code>grid[5, 0]</code>,
    which doesn't exist:
    row indices only go as high as 4,
    and trying to access a non-existent block is an error,
    just as trying to access a non-existent variable is.
  </p>

  <p>
    But Python doesn't notice this until we actually get there.
    If we display the grid now,
    we see:
  </p>

<pre>
FIXME: output
</pre>

  <p class="continue">
    which shows that the first five iterations of the loop ran
    before the error occurred.
  </p>

  <p>
    Here's a better way to write this loop:
  </p>

<pre>
<span class="in">for i in range(<span class="highlight">grid.height</span>):
    grid[i, 0] = (255, 0, 0)
grid.show()</span>
FIXME: output
</pre>

  <p>
    What makes this better is
    the change from using 5, 10, or any specific number in the <code>range</code> call
    to using <code>grid.height</code> instead.
    The grid knows how large it is;
    rather than relying on our memory
    (which is often faulty),
    we should rely on the computer's
    (which usually isn't).
    Doing this also makes the program more robust:
    if we come back later and change the grid size to 20&times;30,
    we don't have to re-read every line
    looking for 10's that ought to become 30's.
  </p>

  <div class="box">
    <h3>Don't Repeat Yourself</h3>
    <p>
      Every fact in a program should be represented once and only once,
      so that if the program needs to be changed,
      only one change,
      in one place,
      is needed.
      Putting it another way,
      if most changes to a program can be made
      by changing one thing in one place,
      that program is well designed.
    </p>
  </div>

  <p>
    What if we want to set the color of a sub-rectangle of our grid?
    For example,
    suppose we want to turn the nine pixels in the upper left corner blue.
    We could do this:
  </p>

<pre>
<span class="in">grid[0, 0] = (0, 0, 255)
grid[0, 1] = (0, 0, 255)
grid[0, 2] = (0, 0, 255)
grid[1, 0] = (0, 0, 255)
grid[1, 1] = (0, 0, 255)
grid[1, 2] = (0, 0, 255)
grid[2, 0] = (0, 0, 255)
grid[2, 1] = (0, 0, 255)
grid[2, 2] = (0, 0, 255)</span>
</pre>

  <p class="continue">
    but we already know that's a bad approach.
    We'd be better off using a loop for each row
    to cut our program from nine lines to six:
  </p>

<pre>
<span class="in">for i in range(3):
    grid[<span class="highlight">0</span>, i] = (0, 0, 255)
for i in range(3):
    grid[<span class="highlight">1</span>, i] = (0, 0, 255)
for i in range(3):
    grid[<span class="highlight">2</span>, i] = (0, 0, 255)</span>
</pre>

  <p>
    Look more closely:
    the only difference between the three loops is
    the row index used in each,
    and those indices go in sequence from 0 to 2.
    That means we can use another loop to produce them:
  </p>

<pre>
<span class="in">for row in range(3):
    for col in range(3):
        grid[row, col] = (255, 0, 0)</span>
grid.show()
FIXME: display
</pre>

  <p>
    This is called a <a href="glossary.html#nested-loop">nested loop</a>.
    Each time the <a href="glossary.html#outer-loop">outer loop</a> runs,
    the <a href="glossary.html#inner-loop">inner loop</a> runs three times,
    so that every possible combination of row and column index
    is seen exactly once.
    We get the same result if we turn the loops inside out
    and run over the columns;
    the only difference is the order in which blocks are colored in
    (<a href="#f:nested_loop">Figure XXX</a>).
  </p>

  <figure id="f:nested_loop">
    <img src="pymedia/nested_loop.png" alt="Nested Loops" />
    <figcaption>Figure XXX: Nested Loops</figcaption>
  </figure>

  <p>
    There are cases where the order of the loops matters.
    In the program below,
    the range of the inner loop depends on
    the current value of the outer loop's index:
  </p>

<pre>
<span class="in">grid = BlockGrid(10, 5)
for row in range(col):
    for col in range(5):
        grid[row, col] = (0, 255, 0)
grid.show()</span>
FIXME: output
</pre>

  <p class="continue">
    The first time around the outer loop,
    <code>col</code> is 0,
    so the inner loops doesn't run at all:
    <code>range(0)</code> counts from 0 up to <em>but not including</em> 0,
    so it produces no output.
    The second time around the outer loop,
    <code>col</code> is 0,
    so the inner loop runs once
    and turns <code>grid[1, 0]</code> green.
    The third time,
    <code>col</code> is 1,
    so the inner loop turns <code>grid[2, 0]</code> and <code>grid[2, 1]</code> green,
    and so on.
  </p>

  <p>
    Let's try inverting the loops:
  </p>

<pre>
<span class="in">for <span class="highlight">row</span> in range(5):
    for <span class="highlight">col</span> in range(<span class="highlight">row</span>):
        grid[row, col] = (0, 0, 255)
grid.show()</span>
FIXME: output
</pre>

  <p class="continue">
    <a href="#f:diagonal_loops">Figure XXX</a> shows the order in which
    these nested loops turn cells blue.
    To fill in the cells between the two triangles,
    we can use a single loop like this:
  </p>

<pre>
<span class="in">for diagonal in range(5):
    grid[diagonal, diagonal] = (0, 255, 255)
grid.show()</span>
FIXME: output
</pre>

  <p>
    This program works,
    but it violates our rules about
    making programs readable
    and not repeating information.
    More specifically,
    the number 5 shows up in several places,
    and tuples like (0, 255, 255) aren't exactly meaningful.
    Here's how we should write it instead:
  </p>

<pre>
<span class="in">from ipythonblocks import BlockGrid, colors
grid = BlockGrid(10, 5)
for col in range(grid.height):
    for row in range(col):
        grid[row, col] = colors['Blue']
for row in range(grid.height):
    for col in range(row):
        grid[row, col] = colors['Green']
for diagonal in range(grid.height):
    grid[diagonal, diagonal] = colors['Aqua']
grid.show()</span>
FIXME: output
</pre>

  <p>
    <code>colors</code> defines roughly 140 standard colors
    so that we can use them by name:
    for example,
    <code>colors['Yellow']</code> is the tuple <code>(255, 255, 0)</code>.
    Our loop ranges use <code>grid.height</code>,
    so if we decide to make our grid 20&times;20,
    all we will need to change is the second line of the program,
    and everything else will work.
  </p>

  <div class="challenges">
    <h3>Challenges</h3>
    <p class="fixme">write challenges</p>
  </div>

</section>

<section id="s:index">
  <h2>Indexing, Slicing, and Update Operators</h2>

  <div class="understand">
    <h3>Learning Objectives</h3>
    <ul>
      <li>Select single elements of a sequence using indexes.</li>
      <li>Use negative indices to select elements relative to the end of a sequence.</li>
      <li>Select and operate on multiple elements of a sequence using slices.</li>
      <li>Use strides to select non-adjacent sequence elements.</li>
    </ul>
  </div>

  <p>
    A <code>for</code> loop is one way to tell the computer to do something many times.
    Another is to tell it where to do things,
    and let it figure out how best to take action.
  </p>

  <p>
    To see how this works,
    let's first revisit indexing.
    We have seen that <code>grid[0, 1]</code> refers to a single block in a grid.
    Many other things in Python can be indexed as well,
    such as strings:
  </p>

<pre>
<span class="in">print "Darwin"[2]</span>
<span class="out">r</span>
</pre>

  <p class="continue">
    and lists:
  </p>

<pre>
<span class="in">names = ["Newton", "Darwin", "Turing"]
print names[1]</span>
<span class="out">Darwin</span>
</pre>

  <p>
    Here's something that <em>doesn't</em> work:
  </p>

<pre>
<span class="in">print names[999]</span>
<span class="err">IndexError                                Traceback (most recent call last)
&lt;ipython-input-6-7359c12a3ca3&gt; in &lt;module&gt;()
      1 names = ["Newton", "Darwin", "Turing"]
----&gt; 2 print names[999]

IndexError: list index out of range</span>
</pre>

  <p>
    The list <code>names</code> only has three entries,
    so <code>names[999]</code> doesn't exist.
    Rather than giving us some default value (such as zero)
    or extending the list and filling in the new values with a default,
    Python considers this an error.
    The reasoning is the same as that given <a href="#a:creating-variables">earlier</a>:
    if we haven't defined a value,
    our program shouldn't guess what we might have wanted.
  </p>

  <p>
    Given that,
    you might be surprised to learn that
    Python actually lets use use negative indices:
  </p>

<pre>
<span class="in">print names[-1]</span>
<span class="out">Turing</span>
</pre>

  <p>
    As <a href="#f:negative_indexing">Figure XXX</a> shows,
    these count backwards from the end of the list or string.
    They're not actually necessary:
    if we want to get the last element of
    the list or string referred to by the variable <code>thing</code>,
    we can always write:
  </p>

<pre>
thing[len(thing) - 1]
</pre>

  <p class="continue">
    However,
    this is harder both to type and to read.
  </p>

  <figure id="f:negative_indexing">
    <img src="pymedia/negative_indexing.png" alt="Negative Indexing" />
    <figcaption>Figure XXX: Negative Indexing</figcaption>
  </figure>

  <p>
    All of the indices we have seen so far have specified single items,
    but that doesn't have to be the case.
    We can instead specify ranges of values,
    also called a <a href="glossary.html#slice">slice</a>:
  </p>

<pre>
<span class="in">name = "Alan Turing"
print name[3:8]</span>
<span class="out">Tur</span>
<span class="in">print name[5:5]</span>
<span class="out"></span>
<span class="in">print name[5:2]</span>
<span class="out"></span>
<span class="in">print name[5:999]</span>
<span class="out">Turing</span>
<span class="in">print name[5:-1]</span>
<span class="out">Turin</span>
<span class="in">print name[1:-1]</span>
<span class="out">lan Turin</span>
<span class="in">print name[:6]</span>
<span class="out">Alan T</span>
<span class="in">print name[6:]</span>
<span class="out">uring</span>
<span class="in">print name[:]</span>
<span class="out">Alan Turing</span>
</pre>

  <p>
    Slices are written as <code>[<em>lower</em>:<em>upper</em>]</code>.
    Python interprets them according to the following rules:
  </p>

  <ul>
    <li>
      A slice runs from its lower bound up to, but not including, its upper bound,
      so that the total number of elements selected is upper-lower.
      (In mathematical terms,
      a slice is either "half open" or "half closed".)
    </li>
    <li>
      This means that a slice whose lower and upper bounds are the same,
      like <code>[5:5]</code>,
      selects nothing.
      It also means that if the upper bound is less than the lower bound,
      as in <code>[5:2]</code>,
      nothing is selected as well.
    </li>
    <li>
      Slices are more lenient than single indices:
      if one of the bounds is out of range,
      it is treated as being 0 or the length of the object,
      so that <code>name[5:999]</code> is legal
      even when there are only 11 characters in <code>name</code>.
      Some of us think this inconsistency is a bug;
      others think it is a useful feature.
    </li>
    <li>
      Negative indices count backward as always,
      so <code>name[5:-1]</code> goes from the fifth character
      up to, but not including,
      the last character.
    </li>
    <li>
      As a result,
      <code>thing[1:-1]</code> is everything in <code>thing</code>
      except the first and last element.
      This is often useful in scientific programming
      when we want to select the interior of a range of values.
    </li>
    <li>
      If we omit the lower bound, it defaults to 0;
      if we omit the upper, it defaults to the length of the thing we're slicing.
      Thus,
      <code>name[:6]</code> is the same as <code>name[0:6]</code>
      and <code>name[6:]</code> is the same as <code>name[6:len(name)]</code>.
    </li>
    <li>
      So by extension,
      if we omit both bounds,
      we simply select the entire thing.
    </li>
  </ul>

  <p>
    Slices work in two dimensions as well as one.
    To see this,
    let's create a grid and then change the color of the upper left corner:
  </p>

<pre>
<span class="in">grid = BlockGrid(5, 5)
grid[0:3, 0:3] = (255, 0, 128)
grid.show()</span>
FIXME: display
</pre>

  <p class="continue">
    As this example shows,
    the slices in each dimension are combined to select a range of elements.
    Assigning to that range then changes the color of all those elements at once.
  </p>

  <p>
    Exactly what happens when we assign to a slice
    depends on the type of thing we're slicing.
    For example,
    if we assign to a slice of a list,
    we replace the values in that range
    with a new sequence of values
    (<a href="#f:slice_assign_1">Figure XXX</a>):
  </p>

<pre>
<span class="in">elements = ['H', 'He', 'Li', 'Be', 'Bo', 'C', 'N']
elements[1:-1] = ['Na', 'Mg']
print elements</span>
<span class="out">['H', 'Na', 'Mg', 'N']</span>
</pre>

  <figure id="f:slice_assign_1">
    <img src="pymedia/slice_assign_1.png" alt="Assigning to Slices" />
    <figcaption>Figure XXX: Assigning to Slices</figcaption>
  </figure>

  <p>
    By default,
    a slice selects every value between its bounds.
    We can optionally provide a <a href="glossary.html#stride">stride</a>
    to select regularly-spaced elements instead:
  </p>

<pre>
<span class="in">grid = BlockGrid(8, 5)
grid = (255, 128, 0) <span class="comment"># Turn all elements orange.</span>
grid[0:8:3, :] = (0, 128, 255) <span class="comment"># Turn every third row blue.</span>
grid[:, ::2] = (255, 0, 128) <span class="comment"># Then turn every second column pink.</span>
grid.show()</span>
FIXME: display
</pre>

  <p>
    Slicing is an example of <a href="glossary.html#declarative-programming">declarative programming</a>.
    Instead of telling the computer <em>how</em> to do something,
    we tell it <em>what</em> to do,
    and let it figure out what steps to take to achieve that goal.
    Behind the scenes,
    the computer might use a <code>for</code> loop to re-color each block in the grid.
    It might also use some of the advanced features of the CPU
    to change several blocks simultaneously,
    or distribute the work between different CPUs if we have a powerful enough machine.
    We don't need to know:
    we just need to know that the right thing will happen,
    and that we can spend our time worrying about more important things.
  </p>

  <div class="challenges">
    <h2>Challenges</h2>

    <ol>
      <li>
        Explain why these three lines of code produce the output shown.
<pre>
<span class="in">elements = ['H', 'He', 'Li', 'Be', 'Bo', 'C', 'N']
elements[1:-1] = 'Xe'
print elements</span>
<span class="out">['H', 'X', 'e', 'N']</span>
</pre>
      </li>
    </ol>

  </div>

</section>

<section id="s:logic">
  <h2>Making Choices</h2>

  <div class="understand">
    <h3>Learning Objectives</h3>
    <ul>
      <li>Control which statements are executed using conditionals.</li>
      <li>Combine multiple tests using Boolean operators.</li>
      <li>Use in-place operators to update variables, and explain the advantages of doing so.</li>
    </ul>
  </div>

  <p>
    The program we have written so far have all done the same operations
    regardless of their data.
    In many cases,
    though,
    we want to choose what operations to perform
    based on the data we're given.
    The usual way to do this is to use <a href="glossary.html#conditional">conditional</a> statements.
    Let's start with a simple example:
  </p>

<pre>
<span class="in">if 5 &gt; 0:
    print '5 is greater than 0'
if 5 &lt; 0:
    print '5 is less than 0'</span>
<span class="out">5 is greater than 0</span>
</pre>

  <p>
    The logic is fairly easy to follow.
    The keyword <code>if</code> is followed by an expression.
    If that expression is true,
    Python executes the indented block of code that belongs to the <code>if</code>;
    if the expression is false,
    it doesn't.
    In this case,
    since 5 actually is greater than 0,
    the first <code>print</code> statement runs,
    but not the second.
  </p>

  <p>
    Now let's try this:
  </p>

<pre>
<span class="in">for char in 'GATTACA':
    if char == 'A':
        print 'found an A'</span>
<span class="out">found an A
found an A
found an A</span>
</pre>

  <p>
    Python uses a double equals sign <code>==</code> to test for equality
    (because the single equals sign <code>=</code> is used for assignment).
    Each time through the loop above,
    the current value of <code>char</code> is compared to the character 'A'.
    When the two are equal,
    the program prints a message;
    since the letter appears three times in 'GATTACA',
    the message is printed three times.
  </p>

  <p>
    All right,
    how about this?
  </p>

<pre>
<span class="in">VOWELS = 'AEIOU'
num_vowels = 0
num_other = 0
for char in 'GATTACA':
    if char in VOWELS:
        num_vowels = num_vowels + 1
    else:
        num_other = num_other + 1
print num_vowels, 'vowels and', num_other, 'other characters'</span>
<span class="out">3 vowels and 4 other characters</span>
</pre>

  <p>
    This little program introduces two new language features.
    The first is the <code>in</code> operator,
    which,
    as its name suggests,
    tests whether a value (such as a character)
    is in a collection (such as a string).
    In this case,
    we're using it to see if the current character is in our list of vowels.
  </p>

  <p>
    The other feature is the keyword <code>else</code>,
    which is used to introduce an alternative to an <code>if</code>.
    Here,
    if a character is a vowel,
    Python increments <code>num_vowels</code>.
    If that test fails&mdash;i.e., if the character <em>isn't</em> in <code>VOWELS</code>&mdash;Python
    executes the both of the <code>else</code>
    and increments <code>num_other</code> instead
    (<a href="f:if_else_flowchart">Figure XXX</a>).
  </p>

  <figure id="f:if_else_flowchart">
    <img src="pymedia/if_else_flowchart.png" alt="If-Else Control Flow" />
    <figcaption>If-Else Control Flow</figcaption>
  </figure>

  <p>
    We can make this program more readable
    by rewriting the body of the loop like this:
  </p>

<pre>
for char in 'GATTACA':
    if char in VOWELS:
        <span class="highlight">num_vowels += 1</span>
    else:
        <span class="highlight">num_other += 1</span>
</pre>

  <p>
    The notation <code>x += 1</code> means, "Add one to the variable <code>x</code>."
    This is called an <a href="glossary.html#in-place-operator">in-place operator</a>,
    since it reads the current value of <code>x</code>
    and writes a new value back to the same variable.
    We can similarly use <code>x += 5</code> to add 5 to <code>x</code>,
    <code>x *= 3</code> to triple it,
    and so on.
  </p>

  <div class="box">
    <h3>It's the Little Things</h3>

    <p>
      Using in-place operators may seem like a small saving,
      but they actually prevent a lot of bugs by eliminating duplicated code,
      particularly when complex one- and two-dimensional indexes are being used.
      For example,
      compare the following two snippets of code:
    </p>

<pre>
<span class="comment"># First version.</span>
temperature[last_x - 1, last_y + 1] = (1.0 + adjustment) * temperature[last_x + 1, last_y + 1]

<span class="comment"># Second version.</span>
temperature[last_x - 1, last_y + 1] *= 1.0 + adjustment
</pre>

    <p>
      Did you notice that the X index on the left and right in the first version are different?
      In the second case,
      it's clear that the temperature of a particular cell is being adjusted
      using only its own value.
    </p>
  </div>

  <p>
    With conditionals in hand,
    let's draw a pattern on a grid:
  </p>

<pre>
<span class="in">from ipythonblocks import BlockGrid, colors
ROWS = 5
COLS = 10
grid = BlockGrid(COLS, ROWS)
for r in range(ROWS):
    for c in range(COLS):
        if r &lt; c:
            grid[r, c] = colors['Red']
        elif r == c:
            grid[r, c] = colors['Blue']
        else:
            grid[r, c] = colors['Green']
grid.show()</span>
FIXME: display
</pre>

  <p class="continue">
    As you might guess,
    <code>elif</code> is a shorthand for "else if":
    we use it to provide another alternative in a set of conditionals.
    We can have as many <code>elif</code>s as we want
    between the opening <code>if</code> and the optional <code>else</code> at the end.
    Each is tested in order,
    and the first one whose condition is true is executed.
  </p>

  <p>
    Now that we have this grid,
    we can write programs that take action based on its values.
    For example,
    we can add a bit of red to each block that doesn't have any:
  </p>

<pre>
<span class="in">for r in range(ROWS):
    for c in range(COLS):
        if grid[r, c].red == 0:
            grid[r, c].red = 128
grid.show()</span>
FIXME: display
</pre>

  <p class="continue">
    Again,
    since the author of IPythonBlocks chose sensible names for things,
    we can read this program with little difficulty.
    The nested loops iterate through the blocks in row-and-column order.
    At each block,
    we test whether the red component of its color is zero.
    If it is,
    we set it to 128 (i.e., half the maximum intensity).
    This leaves the pure red blocks alone,
    but adds red to green and blue blocks.
  </p>

  <div class="challenges">
    <h3>Challenges</h3>
    <p class="fixme">write some challenges</p>
  </div>

</section>

<section id="s:design">
  <h2>Building Bigger Programs</h2>

  <div class="understand">
    <h3>Learning Objectives</h3>
    <p class="fixme">write learning objectives</p>
  </div>

  <p class="fixme">do not need to reimport libraries all the time</p>

  <p>
    We've covered a lot of topics in the last few sections,
    so let's take a moment to do something with it all.
    To start,
    let's give ourselves an easy way to fill one row of a grid
    with blocks of particular colors:
  </p>

<pre>
<span class="in">from ipythonblocks import BlockGrid, colors

COLS = 6
ROWS = 1
INITIAL = 'GBRRBG' <span class="comment"># G=green, B=black, R=red</span>

grid = BlockGrid(COLS, ROWS)
for i in range(len(INITIAL)):
    if INITIAL[i] == 'G':
        grid[0, i] = colors['Green']
    elif INITIAL[i] == 'B':
        grid[0, i] = colors['Black']
    elif INITIAL[i] == 'R':
        grid[0, i] = colors['Red']
grid.show()</span>
FIXME: display
</pre>

  <p>
    The idea in this code is simple:
    if we want to initialize blocks in an irregular way,
    we write down the colors we want as a string of characters
    with 'B' for black, 'R' for red, and so on.
    We then loop over that string,
    setting the color of the block corresponding to each character.
    This actually takes twice as many lines of code
    as doing it directly:
  </p>

<pre>
<span class="in">grid[0, 0] = colors['Green']
grid[0, 1] = colors['Black']
grid[0, 2] = colors['Red']
grid[0, 3] = colors['Red']
grid[0, 4] = colors['Black']
grid[0, 5] = colors['Green']</span>
</pre>

  <p class="continue">
    but is easier to read,
    because the actual description of what colors go where
    only takes up one line
    (the one that defines <code>INITIAL</code>).
    It is also more scalable:
    if we want to create a grid that is 40 blocks wide,
    all we have to do is change the definition of <code>INITIAL</code>,
    and everything else just works.
  </p>

  <p>
    Or does it?
    Let's try:
  </p>

<pre>
<span class="in">COLS = 6
ROWS = 1
INITIAL = 'GGGBRRBGGBRRBGGBRRBGGBRRBGGBRRBGGBRRBGBB'

grid = BlockGrid(COLS, ROWS)
for i in range(len(INITIAL)):
    if INITIAL[i] == 'G':
        grid[0, i] = colors['Green']
    elif INITIAL[i] == 'B':
        grid[0, i] = colors['Black']
    elif INITIAL[i] == 'R':
        grid[0, i] = colors['Red']
grid.show()</span>
<span class="error">IndexError                                Traceback (most recent call last)
&lt;ipython-input-4-2d159b61b6d0&gt; in &lt;module&gt;()
      8         grid[0, i] = colors['Green']
      9     elif INITIAL[i] == 'B':
---&gt; 10         grid[0, i] = colors['Black']
     11     elif INITIAL[i] == 'R':
     12         grid[0, i] = colors['Red']

IndexError: list index out of range</span>
</pre>

  <p>
    The problem is that <code>INITIAL</code> has 40 characters,
    but <code>COLS</code> is only 6,
    so when we try to set the block corresponding to the seventh character of the string,
    the index is out of bounds for the grid.
    The wrong way to solve this is to tell users that
    they must change <code>COLS</code> each time they change <code>INITIAL</code>.
    The right way is
    to base the definition of <code>COLS</code> on <code>INITIAL</code>
    so that the two can never be out of step:
  </p>

<pre>
<span class="in">INITIAL = 'GGGBRRBGGBRRBGGBRRBGGBRRBGGBRRBGGBRRBGBB'
COLS = <span class="highlight">len(INITIAL)</span>
ROWS = 1
...code as before...</span>
FIXME: display
</pre>

  <p>
    The basic principle behind this change is <a href="glossary.html#dry">DRY</a>:
    Don't Repeat Yourself.
    Every fact in a program should appear exactly once;
    every part of the program that needs it should refer to that definition
    so that parts of the program cannot be inconsistent with each other.
  </p>

  <p>
    Let's test out our change on a 10-column grid:
  </p>

<pre>
<span class="in">INITIAL = 'GGGBPPBGGB'
COLS = len(INITIAL)
ROWS = 1

grid = BlockGrid(COLS, ROWS)
for i in range(len(INITIAL)):
    if INITIAL[i] == 'G':
        grid[0, i] = colors['Green']
    elif INITIAL[i] == 'B':
        grid[0, i] = colors['Black']
    elif INITIAL[i] == 'R':
        grid[0, i] = colors['Red']
grid.show()</span>
FIXME: display
</pre>

  <p class="continue">
    This grid is the right size,
    but some of the colors are wrong.
    Along with G's and B's,
    <code>INITIAL</code> contains P's (for "purple"),
    but the conditional statement inside the loop doesn't check for this letter.
    As a result,
    some cells are black (their default initial color) by accident
    rather than because we wanted them to be black.
  </p>

  <p>
    It's easy enough in this case to add another branch to the conditional
    to handle the letter 'P',
    but if we have made the mistake once,
    we're likely to make it again.
    To guard against it,
    we should add an <a href="glossary.html#assertion">assertion</a>
    to the program.
    An assertion is simply a statement that something is true
    at a certain point in the program's execution.
    When the program runs,
    Python checks the assertion's condition each time it is encountered.
    If the condition is false,
    Python halts the program and presents whatever error message we have defined:
  </p>

<pre>
<span class="in">INITIAL = 'GGGBPPBGGB'
COLS = len(INITIAL)
ROWS = 1

grid = BlockGrid(COLS, ROWS)
for i in range(len(INITIAL)):
    <span class="highlight">assert INITIAL[i] in 'GBR', 'Unknown character: ' + INITIAL[i]</span>
    if INITIAL[i] == 'G':
        grid[0, i] = colors['Green']
    elif INITIAL[i] == 'B':
        grid[0, i] = colors['Black']
    elif INITIAL[i] == 'R':
        grid[0, i] = colors['Red']
grid.show()</span>
<span class="err">AssertionError                            Traceback (most recent call last)
&lt;ipython-input-6-da35b08e73ef&gt; in &lt;module&gt;()
      5 grid = BlockGrid(COLS, ROWS)
      6 for i in range(len(INITIAL)):
----&gt; 7     assert INITIAL[i] in 'GBR', 'Unknown character: ' + INITIAL[i]
      8     if INITIAL[i] == 'G':
      9         grid[0, i] = colors['Green']

AssertionError: Unknown character: P</span>
</pre>

  <p>
    We can now go and add purple to our color scheme:
  </p>

  <p>
    This is the longest Python program we've seen so far,
    but we can understand it by reading one section at a time:
  </p>

<pre>
<span class="in">INITIAL = 'GGGBPPBGGB'
COLS = len(INITIAL)
ROWS = 1

grid = BlockGrid(COLS, ROWS)
for i in range(len(INITIAL)):
    assert INITIAL[i] in 'GBR<span class="highlight">P</span>', 'Unknown character: ' + INITIAL[i]
    if INITIAL[i] == 'G':
        grid[0, i] = colors['Green']
    elif INITIAL[i] == 'B':
        grid[0, i] = colors['Black']
    elif INITIAL[i] == 'R':
        grid[0, i] = colors['Red']
<span class="highlight">    elif INITIAL[i] == 'P':
        grid[0, i] = colors['Purple']</span>
grid.show()</span>
FIXME: display
</pre>

  <p>
    This works,
    but it violates our DRY principle:
    each time we want to add a color,
    we have to change the assertion <em>and</em> add another <code>elif</code>.
    Here's a better approach:
  </p>

<pre>
<span class="in">INITIAL = 'GGGBPPBGGB'
COLS = len(INITIAL)
ROWS = 1

grid = BlockGrid(COLS, ROWS)
for i in range(len(INITIAL)):
    if INITIAL[i] == 'G':
        grid[0, i] = colors['Green']
    elif INITIAL[i] == 'B':
        grid[0, i] = colors['Black']
    elif INITIAL[i] == 'R':
        grid[0, i] = colors['Red']
    elif INITIAL[i] == 'P':
        grid[0, i] = colors['Purple']
<span class="highlight">    else:
        assert False, 'Unknown character: ' + INITIAL[i]</span>
grid.show()</span>
FIXME: display
</pre>

  <p class="continue">
    This version falls into the <code>else</code>
    if the character from <code>INITIAL</code>
    isn't any of the characters we know how to handle.
    In that case,
    we always want to fail,
    so we assert that <code>False</code> is true
    (which it never is).
  </p>

  <p>
    Later,
    when we meet
    <a href="setdict.html">sets and dictionaries</a>,
    we'll see an ever better way to structure this code.
    For the moment,
    though,
    let's move on to animating it instead.
    Try running this inside the IPython Notebook:
  </p>

<pre>
<span class="in">grid = BlockGrid(20, 1)
for i in range(20):
    grid[0, i] = colors['Blue']
    grid.flash()
grid.show()</span>
FIXME: display
</pre>

  <p>
    <code>grid.flash</code> displays the grid for about a quarter of a second.
    Since we're changing the colors of the blocks in the grid between each call,
    the result appears animated.
    (The <code>grid.show</code> call at the end leaves the final image on the screen;
    without it,
    the grid would disappear after being flashed for the last time.)
  </p>

  <p>
    Let's combine our initializer with some animation
    to fill in a grid row-by-row:
  </p>

<pre>INITIAL = 'GGGBPPBGGB'
COLS = len(INITIAL)
ROWS = 5

grid = BlockGrid(COLS, ROWS)
for i in range(len(INITIAL)):
    if INITIAL[i] == 'G':
        grid[0, i] = colors['Green']
    elif INITIAL[i] == 'B':
        grid[0, i] = colors['Black']
    elif INITIAL[i] == 'R':
        grid[0, i] = colors['Red']
    elif INITIAL[i] == 'P':
        grid[0, i] = colors['Purple']
    else:
        assert False, 'Unknown character: ' + INITIAL[i]

for i in range(1, ROWS):
    grid.flash()
    grid[i, :] = grid[i-1, :]
grid.show()
</pre>

  <p>
    The four lines of code at the end are a little trickier than they first appear.
    The first time through the loop,
    <code>i</code> is 1,
    so the assignment inside the loop is effectively:
  </p>

<pre>
    grid[1, :] = grid[0, :]
</pre>

  <p class="continue">
    The second time through the loop,
    when <code>i</code> is 2,
    the assignment is equivalent to:
  </p>

<pre>
    grid[2, :] = grid[1, :]
</pre>

  <p class="continue">
    and so on.
    Each row therefore gets a copy of whatever's above it,
    one row at a time.
  </p>

  <p>
    To close off this section,
    let's do this with columns as well.
    If we want to <a href="glossary.html#shift">shift</a> the blocks in row <code>i</code>
    one space to the right,
    we can do this:
  </p>

<pre>
    grid[i, 1:COLS] = grid[i, 0:COLS-1]
</pre>

  <p class="continue">
    or more succinctly:
  </p>

<pre>
    grid[i, 1:] = grid[i, :-1]
</pre>

  <p>
    It's important to use the correct subscript on the correct side:
    we are <em>reading</em> values from the start of the row
    up to (but not including) its last element
    on the right side of the assignment,
    and <em>writing</em> to everything from the first cell up to the end of the row
    on the left side.
    If we swap these,
    we will appear to move colors in the other direction.
  </p>

  <p>
    Here's our final program:
  </p>

<pre><span class="comment"># Constants.</span>
INITIAL = 'GGGBPPBGGB'
COLS = len(INITIAL)
ROWS = len(INITIAL)

<span class="comment"># Initialize the first row of the grid.</span>
grid = BlockGrid(COLS, ROWS)
for i in range(len(INITIAL)):
    if INITIAL[i] == 'G':
        grid[0, i] = colors['Green']
    elif INITIAL[i] == 'B':
        grid[0, i] = colors['Black']
    elif INITIAL[i] == 'R':
        grid[0, i] = colors['Red']
    elif INITIAL[i] == 'P':
        grid[0, i] = colors['Purple']
    else:
        assert False, 'Unknown character: ' + INITIAL[i]

<span class="comment"># Animate filling of successive rows, shifting right each time.</span>
for i in range(1, ROWS):
    grid.flash()
    grid[i, 1:] = grid[i-1, :-1]

<span class="comment"># Show final state of grid.</span>
grid.show()
</pre>

  <p>
    This does what we want,
    but even with explanatory comments at the start of each block,
    it has become unwieldy.
    We need a way to break programs down into more digestible pieces,
    and that is the subject of the next three sections.
  </p>

  <div class="challenges">
    <h3>Challenges</h3>
    <p class="fixme">write some challenges</p>
  </div>

</section>

<section id="s:func">
  <h2>Functions</h2>

  <div class="understand">
    <h3>Learning Objectives</h3>
    <ul>
      <li>Explain the benefits of breaking a program up into functions.</li>
      <li>Define a function of a single parameter.</li>
      <li>Explain what a call stack is, what a variable's scope is, and how the two concepts are related.</li>
      <li>Trace values as they are passed into and returned by functions.</li>
      <li>Compose function calls.</li>
    </ul>
    <p>
      <span class="duration">20 minutes</span>.
    </p>
  </div>

  <p>
    We have called functions many times in this lesson.
    It is now time to see how to create new functions ourselves.
    A function's job is to bundle several steps together
    so that they can be used as if they were a single command.
    The simplest possible function is one that
    produces the same value over and over again:
  </p>
  
<pre>
def zero():
    return 0
</pre>

  <p class="continue">
    We create functions in Python using the keyword <code>def</code>,
    followed by the function's name.
    The empty parentheses signal that the function doesn't take any inputs&mdash;we'll
    see functions that do in a moment&mdash;and the colon signals
    the start of a new block of code.
    The body of the function is then indented,
    just like the body of a loop.
    The keyword <code>return</code> then specifies
    the value that the function produces.
  </p>

  <p>
    Defining a function tells the computer how to do something,
    but doesn't actually do whatever that "something" is.
    To do that,
    we need to call the function:
  </p>

<pre>
result = zero()
print "zero produces", result
<span class="out">zero produces 0</span>
</pre>

  <p>
    When Python sees the call <code>zero()</code>
    it sets aside whatever it was doing,
    goes and does whatever the function <code>zero</code> tells it to do,
    and then continues with its original calculation using the function's result.
    In this case,
    the overall effect is to assign 0 to <code>result</code>,
    which is then printed.
  </p>

  <p>
    Functions that always produce the same value aren't particularly useful,
    so most functions take input values,
    usually called <a href="glossary.html#parameter">parameters</a>
    or <a href="glossary.html#argument">arguments</a>.
    A parameter is a variable that is given a new value
    each time the function is called.
    For example,
    the function <code>fahr_to_kelvin</code> defined below
    has a single parameter <code>temp</code>,
    which is assigned the value 32 the first time it is called,
    and the value 212 the second time:
  </p>

<pre>
def fahr_to_kelvin(temp):
    return ((temp - 32.0) * 5.0/9.0) + 273.15

print 'water freezes at', fahr_to_kelvin(32)
print 'water boils at', fahr_to_kelvin(212)
<span class="out">water freezes at 273.15
water boils at 373.15</span>
</pre>

  <p>
    The functions we have seen so far have had only one parameter.
    When we define a function,
    however,
    we can give it any number of parameters.
    When the function is called and a new stack frame is created,
    a new variable is defined for each of those parameters,
    and the actual values given by the caller are assigned to the parameters in order from left to right.
    For example,
    if we define <code>average3</code> to calculate the average of three numbers:
  </p>

<pre>
def average3(a, b, c):
    return (a + b + c) / 3.0
</pre>

  <p class="continue">
    and call it like this:
  </p>

<pre>
x = 2
y = 2
z = 5
print average3(x, y, z)
<span class="out">3.0</span>
</pre>

  <p class="continue">
    then just before the function returns,
    the program's memory is as shown in <a href="#f:memory_before_return">Figure XXX</a>.
  </p>

  <figure id="f:memory_before_return">
    <img src="pymedia/memory_before_return.png" alt="State of Memory Before Function Return" />
    <figcaption>Figure 28: State of Memory Before Function Return</figcaption>
  </figure>

  <p>
    Calling this function with the wrong number of values is an error:
  </p>

<pre>
print average3(1, 5)
<span class="err">Traceback (most recent call last):
  File "python/average-3-wrong.py", line 4, in &lt;module&gt;
    print 1, 5, '=&gt;', average3(1, 5)
TypeError: average3() takes exactly 3 arguments (2 given)</span>
</pre>

  <p class="continue" id="a:default-value">
    This is only sensible:
    if we pass two values to <code>average3</code>,
    Python has no way of knowing what third value to use.
    We can create functions that have
    <a href="glossary.html#default-value">default values</a> for parameters
    simply by providing those values when the function is defined:
  </p>

<pre>
def average3(a=0.0, b=0.0, c=0.0):
    return (a + b + c) / 3.0
</pre>

  <p>
    The meaning is straightforward:
    if the caller doesn't tell the function what value to use for <code>a</code>,
    the function should use 0.0,
    and similarly for the other parameters.
    We can now call our function in four different ways:
  </p>

  <table>
    <tr>
      <th>Call</th>
      <th><code>a</code></th>
      <th><code>b</code></th>
      <th><code>c</code></th>
      <th>Result</th>
    </tr>
    <tr>
      <td><code>average3()</code></td>
      <td>0.0</td>
      <td>0.0</td>
      <td>0.0</td>
      <td>0.0</td>
    </tr>
    <tr>
      <td><code>average3(3.0)</code></td>
      <td>3.0</td>
      <td>0.0</td>
      <td>0.0</td>
      <td>1.0</td>
    </tr>
    <tr>
      <td><code>average3(3.0, 6.0)</code></td>
      <td>3.0</td>
      <td>6.0</td>
      <td>0.0</td>
      <td>3.0</td>
    </tr>
    <tr>
      <td><code>average3(3.0, 6.0, 9.0)</code></td>
      <td>3.0</td>
      <td>6.0</td>
      <td>9.0</td>
      <td>6.0</td>
    </tr>
  </table>

  <p class="continue">
    We still can't call this function with more than three parameters,
    though,
    since once again Python wouldn't know where to put the fourth and higher.
  </p>

  <p>
    One restriction on functions with default values
    is that all of the parameters that have default values must come <em>after</em>
    all of the parameters that don't.
    To see why,
    imagine we were allowed to mix defaulting and non-defaulting parameters like this:
  </p>

<pre>
def average(<span class="highlight">start=None, values, end=None</span>):
    if start is None:
        start = 0
    if end is None:
        end = len(values)
    result = 0.0
    i = start
    while i &lt; end:
        result += values[i]
        i += 1
    return result / (end - start)
</pre>

  <p>
    If we call the function with just one parameter,
    it's pretty clear that its value has to be assigned to <code>values</code>.
    But what should Python do if the function is called with two parameters,
    like <code>average([1.0, 2.0, 5.0], 1)</code>?
    Should it use the provided values for the first and second parameters,
    and the default for the third?
    Or should it use the first parameter's default,
    and assign the given values to the second and third?
    We know what we want,
    but Python doesn't:
    remember, it can't infer anything from variables' names.
    We could define some sort of rule to tell it what to do in this case,
    but it's simpler and safer to disallow the problem in the first place.
  </p>

  <div class="box">
    <h3>How Older Languages Do It</h3>

    <p>
      If the language we are using doesn't let us define default parameter values,
      we would have to write two functions:
    </p>

<pre>
def is_close_diff(left, right, difference):
    return abs(left - right) &lt; difference

def is_close_default(left, right):
    return is_close_diff(left, right, 1.0e-6)
</pre>

    <p class="continue" id="a:wrapper">
      This is a common <a href="glossary.html#design-pattern">design pattern</a>
      in many programming languages.
      We start by defining the most general function we can think of&mdash;in
      this case, one that uses a user-specified difference&mdash;and
      then write <a href="glossary.html#wrapper-function">wrapper functions</a>
      as easy-to-use shortcuts for common cases.
      These wrapper functions do <em>not</em> duplicate what's in the general function;
      instead, they call it,
      filling in some or all of the parameters it requires with sensible defaults.
    </p>

    <p>
      The problem with this approach is that
      we have to come up with names for all those little functions.
      Default parameters were invented to solve this problem:
      instead of writing lots of functions,
      we write one,
      and provide default values for some or all of its parameters.
    </p>
  </div>

  <div class="keypoints">
    <h3>Summary</h3>
    <ul>
      <li>Define a function using <code>def <em>name</em>(...)</code></li>
      <li>The body of a function must be indented.</li>
      <li>Use <code><em>name</em>(...)</code> to call a function.</li>
      <li>Use <code>return</code> to return a value from a function.</li>
      <li>The values passed into a function are assigned to its parameters in left-to-right order.</li>
      <li>Function calls are recorded on a call stack.</li>
      <li>Every function call creates a new stack frame.</li>
      <li>The variables in a stack frame are discarded when the function call completes.</li>
      <li>Grouping operations in functions makes code easier to understand and re-use.</li>
    </ul>
  </div>

  <div class="challenges">
    <h3>Challenges</h3>

    <ol>

      <li>
        Draw memory diagrams showing what is on the call stack
        each time it changes in the program below:
<pre>
def double(x):
    return 2 * x

def trim(lower, value, upper):
    if value &lt; lower:
        result = lower
    elif value &gt; upper:
        result = upper
    else:
        result = value
    return value

print double(trim(0, 15, double(5)))
</pre>
      </li>

      <li class="fixme">write more challenges</li>

    </ol>

  </div>

</section>

<section id="s:scope">
  <h2>Scope</h2>

  <div class="understand">
    <h3>Learning Objectives</h3>
    <ul>
      <li>Explain what global scope is, and how it differs from local scope.</li>
      <li>Explain why functions shouldn't pass information through global variables.</li>
    </ul>
    <p>
      <span class="duration">20 minutes</span>.
    </p>
  </div>

  <p>
    If one function is good,
    two must be better.
    Let's write a function to convert Kelvin to Celsius:
  </p>

<pre>
def kelvin_to_celsius(temp):
    return temp - 273.15

print 'absolute zero is', kelvin_to_celsius(0)
<span class="out">absolute zero is -273.15</span>
</pre>

  <p class="continue">
    Instead of writing a third equation to translate Fahrenheit into Celsius,
    we can now combine the two functions we have
    to do the required calculation:
  </p>

<pre>
def fahr_to_celsius(temp):
    degrees_k = fahr_to_kelvin(temp)
    return kelvin_to_celsius(degrees_k)

temp_f = 32.0
temp_c = fahr_to_celsius(temp_f)
print 'water freezes at', temp_c
<span class="out">water freezes at 0.0</span>
</pre>

  <p id="a:call-stack">
    To really understand what happens when we combine functions this way,
    we need to understand the <a href="glossary.html#call-stack">function call stack</a>.
    Here are the function definitions once again:
  </p>

<pre>
def fahr_to_kelvin(temp):
    return ((temp - 32.0) * 5.0/9.0) + 273.15

def kelvin_to_celsius(temp):
    return temp - 273.15

def fahr_to_celsius(temp):
    degrees_k = fahr_to_kelvin(temp)
    return kelvin_to_celsius(degrees_k)
</pre>

  <p class="continue">
    All three functions have a parameter called <code>temp</code>;
    how does Python keep them straight?
    Let's call one of the functions
    and print <code>temp</code>'s value after the call:
  </p>

<pre>
def kelvin_to_celsius(temp):
    return temp - 273.15

absolute_zero = 0.0
result = kelvin_to_celsius(absolute_zero)
print 'temp after function call is', temp
<span class="out">temp after function call is</span>
<span class="err">Traceback (most recent call last):
  File "python/print-temp.py", line 5, in &lt;module&gt;
    print 'temp after function call is', temp
NameError: name 'temp' is not defined</span>
</pre>

  <p class="continue">
    Why isn't <code>temp</code> defined?
    And if it isn't,
    why did we get an error for the last line of our program,
    rather than when we used <code>temp</code> inside <code>kelvin_to_celsius</code>?
  </p>

  <p>
    The answer is that
    Python doesn't actually create a variable called <code>temp</code>
    when the function is defined.
    Instead,
    it makes a note that it is supposed to create such a variable
    when <code>kelvin_to_celsius</code> is called,
    and then throw it away when the function finishes executing.
  </p>

  <p>
    This is easier to explain with pictures.
    After executing line 4 of our program,
    Python knows that <code>kelvin_to_celsius</code> refers to a function,
    and that <code>absolute_zero</code> refers to the value 0.0
    (<a href="#f:func_call_step_1">Figure 29</a>):
  </p>

  <figure id="f:func_call_step_1">
    <img src="pymedia/func_call_step_1.png" alt="First Step of Function Call" />
    <figcaption>Figure 29: First Step of Function Call</figcaption>
  </figure>

  <p>
    The first thing it does when it executes line 5 is call <code>kelvin_to_celsius</code>.
    To do this,
    it creates a new storage area for variables
    and puts it on top of the one that holds
    <code>kelvin_to_celsius</code> and <code>absolute_zero</code>.
    Since the function has one parameter,
    <code>temp</code>,
    Python creates a variable with that name in the new storage area
    and gives it the value 0.0
    (since that's what we passed in when we called the function).
    The program's memory is now in the state shown in
    <a href="#f:func_call_step_2">Figure 30</a>:
  </p>

  <figure id="f:func_call_step_2">
    <img src="pymedia/func_call_step_2.png" alt="Second Step of Function Call" />
    <figcaption>Figure 30: Second Step of Function Call</figcaption>
  </figure>

  <p>
    This variable storage area is called
    a <a href="glossary.html#stack-frame">stack frame</a>:
    stack, because it is stacked on top of the previous area,
    and frame, because&hellip;well, just because.
    Every time a function is called&mdash;any function&mdash;Python
    creates a new frame to holds the function's variables
    and puts it on top of the stack.
    While it is executing that function's code,
    Python looks in the top stack frame to find variables;
    when the function returns,
    Python discards the top stack frame
    and starts using the one underneath it again.
  </p>

  <p>
    Since the rest of the statement on line 5
    (the line containing the function call)
    assigns the function's value to <code>not_used</code>,
    memory looks something like <a href="#f:func_call_step_3">Figure 31</a>
    after line 5 is finished:
  </p>

  <figure id="f:func_call_step_3">
    <img src="pymedia/func_call_step_3.png" alt="Third Step of Function Call" />
    <figcaption>Figure 31: Third Step of Function Call</figcaption>
  </figure>

  <p>
    It should now be clear why we got the error we did,
    and why we got it <em>where</em> we did.
    When Python executes line 6,
    the uppermost frame of the stack doesn't contain a variable called <code>temp</code>.
    The frame that <em>did</em> contain that variable
    was discarded when the call to <code>kelvin_to_celsius</code> finished.
  </p>

  <p>
    To understand why Python (and other languages) do all of this,
    let's go back to <code>fahr_to_celsius</code> again.
    Its definition,
    and the definitions of the functions it calls,
    are:
  </p>

<pre>
def fahr_to_kelvin(temp):
    return ((temp - 32.0) * 5.0/9.0) + 273.15

def kelvin_to_celsius(temp):
    return temp - 273.15

def fahr_to_celsius(temp):
    degrees_k = fahr_to_kelvin(temp)
    return kelvin_to_celsius(degrees_k)
</pre>

  <p class="continue">
    These nine lines of code define the variable <code>temp</code> three times&mdash;once
    in each function&mdash;but those three <code>temp</code>s are <em>not</em> the same variable.
    The first <code>temp</code>,
    defined on line 1,
    is created each time <code>fahr_to_kelvin</code> is called,
    and only lasts as long as that call is in progress.
    In computer science jargon,
    it is <a href="glossary.html#local-scope">local</a> to the function.
    Similarly,
    the second <code>temp</code> (on line 4) is local to <code>kelvin_to_celsius</code>,
    and the third (on line 7) to <code>fahr_to_celsius</code>.
    They only exist while the functions that own them are being executed,
    and can only be "seen" inside those functions.
  </p>

  <p>
    Again, some pictures will make this clearer
    (and it does need to be clear,
    since everything else about functions depends on this idea).
    Let's call <code>fahr_to_celsius</code> as before:
  </p>

<pre>
temp_f = 32.0
temp_c = fahr_to_celsius(temp_f)
print 'water freezes at', temp_c
</pre>

  <p>
    Just before line 9 runs,
    the stack consists of a single frame,
    which contains the three functions
    and the variable <code>temp_f</code>
    (<a href="#f:stack_single_frame">Figure 32</a>):
  </p>

  <figure id="f:stack_single_frame">
    <img src="pymedia/stack_single_frame.png" alt="A Call Stack With a Single Frame" />
    <figcaption>Figure 32: A Call Stack With a Single Frame</figcaption>
  </figure>

  <p>
    When we call <code>fahr_to_celsius</code>,
    Python creates a new stack frame containing the variable <code>temp</code>
    and assigns it the value 32.0
    (which it got from <code>temp_f</code>).
    Memory is now as shown in <a href="#f:stack_double_frame">Figure 33</a>.
  </p>

  <figure id="f:stack_double_frame">
    <img src="pymedia/stack_double_frame.png" alt="A New Stack Frame" />
    <figcaption>Figure 33: A New Stack Frame</figcaption>
  </figure>

  <p>
    <code>fahr_to_celsius</code> immediately calls <code>fahr_to_kelvin</code>,
    so Python creates another stack frame
    to hold <code>fahr_to_kelvin</code>'s local variables.
    This frame also contains a variable called <code>temp</code>,
    but since it's in a different frame,
    it's a different variable than <code>fahr_to_celsius</code>'s <code>temp</code>
    (<a href="#f:stack_triple_frame">Figure 34</a>).
  </p>

  <figure id="f:stack_triple_frame">
    <img src="pymedia/stack_triple_frame.png" alt="Yet Another Stack Frame" />
    <figcaption>Figure 34: Yet Another Stack Frame</figcaption>
  </figure>

  <p>
    Using its <code>temp</code>,
    <code>fahr_to_kelvin</code> calculates a result of 273.15.
    When it returns that value,
    Python discards <code>fahr_to_kelvin</code>'s stack frame
    (<a href="#f:stack_back_to_double_frame">Figure 35</a>):
  </p>

  <figure id="f:stack_back_to_double_frame">
    <img src="pymedia/stack_back_to_double_frame.png" alt="Back to a Double Frame" />
    <figcaption>Figure 35: Back to a Double Frame</figcaption>
  </figure>

  <p class="continue">
    and creates a new variable <code>degrees_k</code> to hold that value
    in what is now the top frame&mdash;the one belonging to <code>fahr_to_celsius</code>
    (<a href="#f:new_variable_in_double_frame">Figure 36</a>):
  </p>

  <figure id="f:new_variable_in_double_frame">
    <img src="pymedia/new_variable_in_double_frame.png" alt="A New Variable in the Second Frame" />
    <figcaption>Figure 36: A New Variable in the Second Frame</figcaption>
  </figure>

  <p class="continue">
    Python then goes through the same steps for the call to <code>kelvin_to_celsius</code>.
    It creates a stack frame with a variable <code>temp</code>,
    which it assigns the value 273.15
    (<a href="#f:repeat_stack_frame">Figure 37</a>):
  </p>

  <figure id="f:repeat_stack_frame">
    <img src="pymedia/repeat_stack_frame.png" alt="Repeating the Process" />
    <figcaption>Figure 37: Repeating the Process</figcaption>
  </figure>

  <p class="continue">
    does its calculations,
    and then discards the stack frame when the function is finished.
    Since <code>fahr_to_celsius</code> is also now done,
    Python discards its stack frame,
    creates a variable called <code>temp_c</code> in the original (bottom) frame,
    and assigns it the value 0.0
    (<a href="#f:final_state_of_frames">Figure 38</a>):
  </p>

  <figure id="f:final_state_of_frames">
    <img src="pymedia/final_state_of_frames.png" alt="The Final State" />
    <figcaption>Figure 38: The Final State</figcaption>
  </figure>

  <p>
    Every modern programming language uses this model to manage calculations.
    Each function call creates a new stack frame with its own variables.
    While the function is running,
    it uses the variables in its own frame,
    and when the function call is finished,
    the stack frame is discarded.
  </p>

  <p>
    The area of the program in which a particular variable is visible
    is called its <a href="glossary.html#scope">scope</a>.
    As a rule,
    programming languages do not let functions access variables in other functions' scopes
    because doing so would make large programs almost impossible to write.
    For example,
    imagine we used two functions to sum the squares of the values in a list:
  </p>

<pre>
def sum(numbers):                       <span class="comment">#  1</span>
    result = 0                          <span class="comment">#  2</span>
    for x in numbers:                   <span class="comment">#  3</span>
        result = result + square(x)     <span class="comment">#  4</span>
    return result                       <span class="comment">#  5</span>
                                        <span class="comment">#  6</span>
def square(val):                        <span class="comment">#  7</span>
    result = val * val                  <span class="comment">#  8</span>
    return result                       <span class="comment">#  9</span>
                                        <span class="comment"># 10</span>
print sum([1, 2])                       <span class="comment"># 11</span>
</pre>

  <p class="continue">
    We expect to get 1<sup>2</sup>+2<sup>2</sup> = 5
    via the following steps:
  </p>

  <table border="1">
    <tr>
      <th></th>
      <th><code>sum</code></th>
      <th><code>sum</code></th>
      <th><code>square</code></th>
      <th><code>square</code></th>
    </tr>
    <tr>
      <th>Line</th>
      <th><code>result</code></th>
      <th><code>x</code></th>
      <th><code>val</code></th>
      <th><code>result</code></th>
    </tr>
    <tr>
      <td>2</td>
      <td>0</td>
      <td></td>
      <td></td>
      <td></td>
    </tr>
    <tr>
      <td>3</td>
      <td>0</td>
      <td>1</td>
      <td></td>
      <td></td>
    </tr>
    <tr>
      <td>7</td>
      <td>0</td>
      <td>1</td>
      <td>1</td>
      <td></td>
    </tr>
    <tr>
      <td>8</td>
      <td>0</td>
      <td>1</td>
      <td>1</td>
      <td>1</td>
    </tr>
    <tr>
      <td>4</td>
      <td>1</td>
      <td>1</td>
      <td></td>
      <td></td>
    </tr>
    <tr>
      <td>3</td>
      <td>1</td>
      <td>2</td>
      <td></td>
      <td></td>
    </tr>
    <tr>
      <td>7</td>
      <td>1</td>
      <td>2</td>
      <td>2</td>
      <td></td>
    </tr>
    <tr>
      <td>8</td>
      <td>1</td>
      <td>2</td>
      <td>2</td>
      <td>4</td>
    </tr>
    <tr>
      <td>4</td>
      <td>1</td>
      <td>5</td>
      <td></td>
      <td></td>
    </tr>
    <tr>
      <td>5</td>
      <td>1</td>
      <td>5</td>
      <td></td>
      <td></td>
    </tr>
  </table>

  <p>
    If <code>sum</code>'s <code>result</code> and <code>square</code>'s <code>result</code>
    were the same variable, though,
    we would get 8 instead:
  </p>

  <table border="1">
    <tr>
      <th>Line</th>
      <th><code>result</code></th>
      <th><code>x</code></th>
      <th><code>val</code></th>
    </tr>
    <tr>
      <td>2</td>
      <td>0</td>
      <td></td>
      <td></td>
    </tr>
    <tr>
      <td>3</td>
      <td>0</td>
      <td>1</td>
      <td></td>
    </tr>
    <tr>
      <td>7</td>
      <td>0</td>
      <td>1</td>
      <td>1</td>
    </tr>
    <tr>
      <td>8</td>
      <td>1</td>
      <td>1</td>
      <td>1</td>
    </tr>
    <tr>
      <td>4</td>
      <td>2</td>
      <td>1</td>
      <td></td>
    </tr>
    <tr>
      <td>3</td>
      <td>2</td>
      <td>2</td>
      <td></td>
    </tr>
    <tr>
      <td>7</td>
      <td>2</td>
      <td>2</td>
      <td>2</td>
    </tr>
    <tr>
      <td>8</td>
      <td>4</td>
      <td>2</td>
      <td>2</td>
    </tr>
    <tr>
      <td>4</td>
      <td>8</td>
      <td>2</td>
      <td></td>
    </tr>
    <tr>
      <td>5</td>
      <td>8</td>
      <td>2</td>
      <td></td>
    </tr>
  </table>

  <p class="continue">
    What's worse,
    if we changed the name of the variable in <code>square</code>
    from <code>result</code> to <code>y</code>,
    the final answer would be 5 again.
    Changing the name of a variable shouldn't matter:
    <em>f(x)=x<sup>2</sup></em> and <em>f(y)=y<sup>2</sup></em>
    ought to calculate the same value,
    and if changing a variable name in one part of our program
    can change the result calculated by another,
    we will have to keep the entire program in our head
    in order to make any change safely.
  </p>

  <p>
    The fundamental issue here is one of evolution rather than one of technology.
    Human short-term memory can only hold a few items at a time;
    the value is sometimes given as "seven plus or minus two",
    and while that is an over-simplification,
    it's a good guideline.
    If we need to remember more unrelated bits of information than that for more than a few seconds,
    they become jumbled and we start making mistakes.
  </p>

  <p>
    If we have to keep more than half a dozen things straight in our mind
    in order to understand or change a piece of code,
    we will therefore start making mistakes.
    Most programming languages therefore enforce a "local scope only" rule
    so that programmers can ignore what's inside the functions they are calling,
    or what's outside the functions they are writing,
    and use their short-term memory for the task at hand instead.
  </p>

  <p>
    There is one important pragmatic exception to the "local scope only" rule
    mentioned at the end of the previous section.
    Every function also has access to the <a href="glossary.html#global-scope">global scope</a>,
    which is all the top-level definitions in the program
    (i.e., ones that aren't inside any particular function).
    In our pictures,
    the global scope is the bottom-most frame on the stack,
    which is there when the program starts and never goes away
    (<a href="#f:global_scope">Figure 39</a>).
  </p>

  <figure id="f:global_scope">
    <img src="pymedia/global_scope.png" alt="Global Scope" />
    <figcaption>Figure 39: Global Scope</figcaption>
  </figure>

  <p>
    Functions need access to the global scope because
    that is where other functions are defined.
    Going back to our temperature calculator,
    if <code>fahr_to_celsius</code> could only see variables defined in its local scope,
    it wouldn't be able to see either <code>fahr_to_kelvin</code>
    or <code>kelvin_to_celsius</code>,
    and therefore wouldn't be able to call them.
  </p>

  <div class="keypoints">
    <h3>Summary</h3>
    <ul>
      <li>Every function call creates a new scope.</li>
      <li>Every function has access to its own variable and to variables defined in the global scope.</li>
    </ul>
  </div>

  <div class="challenges">
    <h3>Challenges</h3>
    <p class="fixme">write challenges</p>
  </div>

</section>

<section id="s:return">
  <h2>Returning Values</h2>

  <div class="understand">
    <h3>Learning Objectives</h3>
    <ul>
      <li>Write functions that return values from arbitrary points.</li>
      <li>Explain why functions <em>shouldn't</em> return values at arbitrary points.</li>
      <li>Identify functions that implicitly return <code>None</code>.</li>
    </ul>
    <p>
      <span class="duration">15 minutes</span>.
    </p>
  </div>

  <p>
    All of our functions so far have ended with a <code>return</code> statement,
    and that has been the only <code>return</code> statement they've contained.
    Once again,
    this doesn't have to be the case:
    it is often easier to write functions that return from several places,
    though this can also make them harder to read.
  </p>

  <p>
    Let's start with a function that calculates the sign of a number:
  </p>

<pre>
def sign(num):
    if num &lt; 0:
        return -1
    if num == 0:
        return 0
    return 1
</pre>

  <p class="continue">
    If we call it with a negative number,
    the first branch of the <code>if</code> returns -1.
    If we call it with 0,
    the <code>return</code> in the second <code>if</code> is executed,
    and if we call it with a positive number,
    neither of the <code>if</code> branches is taken,
    so we <a href="glossary.html#fall-through">fall through</a> to the final <code>return</code>,
    which produces the value 1:
  </p>

<pre>
print -5, '=&gt;', sign(-5)
print 0, '=&gt;', sign(0)
print 241, '=&gt;', sign(241)
<span class="out">-5 =&gt; -1
0 =&gt; 0
241 =&gt; 1</span>
</pre>

  <p>
    One common use of multiple return statements
    is to handle special cases at the start of a function.
    For example,
    suppose we decide that we want the average of an empty list to be zero after all.
    We could modify our averaging function to check for this case
    before doing anything else:
  </p>

<pre>
def average(values):

    <span class="comment"># The average of no values is 0.0.</span>
    if len(values) == 0:
        return 0.0

    <span class="comment"># Handle actual values.</span>
    result = 0.0
    for v in values:
        result += v
    return result / len(values)
</pre>

  <p class="continue">
    The early <code>return</code> statement (plus a comment)
    makes it very clear to whoever is reading this code
    that we are handling an empty list in a special way.
    Compare this to an implementation that uses <code>if</code> and <code>else</code>
    to separate the two cases
    while keeping a single <code>return</code> statement at the end of the function:
  </p>

<pre>
def average(values):

    <span class="comment"># The average of no values is 0.0.</span>
    if len(values) == 0:
        result = 0.0

    <span class="comment"># Handle actual values.</span>
    else:
        result = 0.0
        for v in values:
            result += v
        result /= len(values)

    <span class="comment"># Return final result.</span>
    return result
</pre>

  <p class="continue">
    This version is easier to understand in one way,
    but harder in another.
    What makes it harder is our limited short-term memory:
    the body of the <code>else</code> is only four lines long,
    but reading and understanding those lines
    may push the special handling of the empty list out of our mind.
    In this case,
    the code is short enough that
    we will probably be able to retain the special case,
    but if the calculation was more complex,
    we would lose sight of the big picture.
  </p>

  <p>
    What makes it easier is its regularity:
    each possible case of input (empty or non-empty) is handled in a conditional branch,
    and each branch's job is to assign a value to <code>result</code>
    for the function to return.
    If there were six or seven special cases,
    this pattern would help us keep track of what what going on&mdash;provided
    we knew (or recognized) the pattern.
  </p>

  <p>
    The psychological term for what's going on here is
    <a href="glossary.html#chunk">chunking</a>,
    which refers to the way people group items together in memory.
    For example, when you look at the five dots on a dice
    (<a href="#f:five_spots">Figure 40</a>):
  </p>

  <figure id="f:five_spots">
    <img src="pymedia/five_spots.png" alt="Five Spots" />
    <figcaption>Figure 40: Five Spots</figcaption>
  </figure>

  <p class="continue">
    what you actually "see" is the X pattern,
    and what you remember is that pattern rather than five individual dots.
    rather than remembering five individual dots.
    Similarly,
    you remember common words such as "common" as words,
    not as sequences of letters,
    and so on.
  </p>

  <p>
    One of the key differences between experts and novices is that
    experts are better at chunking:
    they don't actually have larger short-term memories,
    but since they recognize a broader repertoire of patterns,
    they are able to manage more information.
    Turning that over,
    the more recognizable patterns are used in a program,
    the easier it is for people to keep it in their heads.
    And as Chase and Simon discuss in their classic paper
    "<a href="bib.html#chase-simon-chess">Perception in chess</a>",
    things that <em>don't</em> conform to patterns can actually be <em>harder</em> for experts to recognize,
    since their brains will mis-match and "correct" what's actually there.
  </p>

  <p>
    Here's a third version of our function that doesn't use an early return.
    and only has one conditional branch:
  </p>

<pre>
def average(values):
    result = 0.0
    if len(values) &gt; 0:
        for v in values:
            result += v
        result /= len(values)
    return result
</pre>

  <p class="continue">
    Many people find this version harder to understand than either of the previous two,
    even though it is shorter.
    The reason is that the special case isn't handled explicitly.
    Instead,
    this function returns 0 for the empty list
    because of the code that <em>isn't</em> executed:
    if the list is empty,
    the loop doesn't run,
    so the initial value of <code>result</code>
    becomes the function's final value by default.
    Spotting this,
    and keeping track of what the function isn't doing as well as what it is,
    is difficult enough that
    many people won't realize there is a special case at all.
  </p>

  <p>
    One last thing to note about functions in Python is that
    every function returns something:
    if there isn't an explicit <code>return</code> statement,
    the value returned is <code>None</code>.
    For example,
    let's comment out the last line of our sign function:
  </p>

<pre>
def sign(num):
    if num &lt; 0:
        return -1
    if num == 0:
        return 0
<span class="comment">#    return 1</span>

print -5, '=&gt;', sign(-5)
print 0, '=&gt;', sign(0)
print 241, '=&gt;', sign(241)
<span class="out">-5 =&gt; -1
0 =&gt; 0
241 =&gt; None</span>
</pre>

  <p class="continue">
    The sign of 241 is now <code>None</code> instead of 1,
    because when the function is called with a positive value,
    neither of the <code>if</code> branches is taken,
    and execution "falls off" the end of the function.
  </p>

  <p>
    Other languages do this differently.
    In C,
    for example,
    trying to use the "result" of a function that doesn't explicitly return something
    is a compilation error&mdash;the program can't even be run.
    No matter what the language,
    this is one reason why commenting out blocks of code is a bad idea:
    it's all too easy to accidentally disable a <code>return</code> statement
    buried inside the code that's no longer being executed.
  </p>

  <div class="keypoints">
    <h3>Summary</h3>
    <ul>
      <li>A function may return values at any point.</li>
      <li>A function should have zero or more <code>return</code> statements at its start to handle special cases, and then one at the end to handle the general case.</li>
      <li>"Accidentally" correct behavior is hard to understand.</li>
      <li>If a function ends without an explicit <code>return</code>, it returns <code>None</code>.</li>
    </ul>
  </div>

  <div class="challenges">
    <h3>Challenges</h3>

    <ol>

      <li>
        One alternative to returning from inside a loop
        is to use the <code>break</code> statement
        to end the loop immediately:
<pre>
def first_negative(values):
    for v in values:
        if v &lt; 0:
            break
    return v
print first_negative([1, 3, -1, 2])
<span class="out">-1</span>
</pre>
        When can this approach result in an error,
        and what kind of error does it produce?
      </li>

      <li>
        This functions counts
        how many values from a list must be summed
        in order to reach some limit:
<pre>
def count_to_limit(values, limit):
    current = 0
    number = 0
    for v in values:
        current += v
        number += 1
        if current &gt;= limit:
            return number

print count_to_limit([1, 2, 3, 5, 7], 8)
<span class="out">4</span>
</pre>
        Fix it so that it returns the right answer
        when <code>limit</code> is negative,
        and when the sum of the values in the list
        never reaches <code>limit</code>.
      </li>

    </ol>

  </div>

</section>

<section id="s:images">
  <h2>Manipulating Images</h2>

  <div class="understand">
    <h3>Learning Objectives</h3>
    <ul>
      <li class="fixme">write learning objectives</li>
    </ul>
    <p>
      <span class="duration">fixme</span>.
    </p>
  </div>

  <p>
    We now have almost everything we need
    to create the altered images Valerie needs for her experiments.
    The only thing we're missing is some actual image processing.
    Luckily,
    that's easy to add given what we've already learned:
  </p>

<pre>
<span class="in">from skimage import novice
flower = novice.open('flower.png')
flower.show()</span>
</pre>

  <p>
    The first statement asks Python to find a library called <code>skimage</code>
    (the SciKit image processing library)
    and load its <code>novice</code> module.
    The second statement asks <code>novice</code> to open
    an file called <code>flower.png</code>
    and assign the result to the variable <code>flower</code>.
    Finally,
    we ask that image to display itself.
    If all has gone well,
    this should show a picture of the world's cutest child
    (<a href="#f:flower">Figure XXX</a>).
  </p>
  
  <figure id="f:flower">
    <img src="pymedia/flower.png" alt="The World's Cutest Child" />
    <figcaption>The World's Cutest Child</figcaption>
  </figure>
  
  <div class="box">
    <h3>There's More Than One Way to Name It</h3>

    <p>
      We could also have written this little program as:
    </p>

<pre>
import skimage
flower = skimage.novice.open('flower.png')
flower.show()
</pre>

    <p>
      And yes,
      we could do this:
    </p>

<pre>
from skimage.novice import open
flower = open('flower.png')
</pre>

    <p class="continue">
      but it would be a very bad idea,
      since it would replace Python's built-in <code>open</code>
      with <code>skimage.novice</code>'s <code>open</code>.
    </p>

  </div>

  <p>
    Like block grids,
    images have properties:
  </p>

<pre>
<span class="in">from skimage import novice

flower = novice.open('flower.png')
print flower.format</span>
<span class="out">'png'</span>
<span class="in">print flower.size</span>
<span class="out">(240, 180)</span>
<span class="in">print flower.width</span>
<span class="out">240</span>
<span class="in">print flower.path</span>
<span class="out">'flower.png'</span>
</pre>

  <p>
    Unlike blocks grids,
    though,
    we can change some of these properties:
  </p>

<pre>
<span class="in">flower.size = (400, 100)
flower.show()</span>
FIXME: display
</pre>

  <p>
    We can also modify the colors of particular pixels:
  </p>

<pre>
<span class="in">for pixel in flower:
    pixel.red = 0
flower.show()</span>
FIXME: display
</pre>

  <p>
    Once we make changes,
    the picture object in memory knows that it has been modified,
    and its <code>path</code> is set to <code>None</code>
    to show that it doesn't correspond to a file on disk any longer:
  </p>

<pre>
<span class="in">print flower.modified</span>
<span class="out">True</span>
<span class="in">print flower.path</span>
<span class="out">None</span>
</pre>

  <p>
    We can easily save it to disk:
  </p>

<pre>
<span class="in">flower.save('/tmp/blue-green-flower.png')
print flower.modified</span>
<span class="out">False</span>
<span class="in">print flower.path</span>
<span class="out">/tmp/blue-green-flower.png</span>
</pre>

  <p>
    And yes,
    we can select individual pixels or entire slices,
    but the results may surprise you:
  </p>

<pre>
<span class="in">flower[0:100, 0:50] = (0, 0, 0)
flower.show()</span>
FIXME: display
</pre>

  <p>
    While <code>BlockGrid</code> uses a tabular coordinate system&mdash;the
    origin is in the upper left corner,
    and indices are (row, column)&mdash;the
    <code>skimage.novice</code> library uses a standard Cartesian coordinate system
    with the origin in the lower left and (X, Y) indices.
  </p>

  <p>
    Let's generate some images:
  </p>

<pre>
BASE    = 128
STEP    = 4
SPACING = 4
NUMBER  = 6
GRAY    = (BASE, BASE, BASE)
SIZE    = 200

for color in range(BASE + STEP, BASE + NUMBER * STEP, STEP):
    image = novice.new((SIZE, SIZE), GRAY)
    image[::SPACING, ::SPACING] = (color, color, color)
    filename = 'step-' + str(color) + '.png'
    image.save(filename)
</pre>

  <p>
    This program creates files with names like <code>step-132.png</code>,
    <code>step-136.png</code>,
    and so on.
    Each one has white pixels spaced evenly across a gray background,
    with the white slowly getting whiter.
    Images like these are sometimes used in vision tests,
    since different spacings and colorings are noticeable to different people.
  </p>

  <p>
    Having told you that,
    we've spoiled the second part of our experiment,
    which is to see how much knowing what a program does
    helps you figure out how it works.
    As you might suspect,
    the answer is, "A lot."
    Let's go through this one.
  </p>

  <p>
    The constants at the top don't tell us much,
    although <code>GRAY</code> is obviously an RGB color value
    and <code>SIZE</code> is (probably) an image size.
    Next is our loop:
    given the name of its index variable,
    <code>color</code>,
    we can guess that we're looping over colors,
    and sure enough,
    two lines down,
    we see <code>(color, color, color)</code>,
    which is creating a shade of gray defined by the current value of <code>color</code>.
  </p>

  <p>
    Backing up a line,
    we're creating a <code>SIZE</code>&times;<code>SIZE</code> image using <code>novice.new</code>
    and setting all its pixels to the fixed color <code>GRAY</code>.
    The loop is going from <code>BASE + STEP</code> up to <code>BASE + NUMBER * STEP</code>
    in increments of <code>STEP</code>.
    <code>BASE</code> is 128&mdash;our initial shade of gray.
    <code>STEP</code> is 4:
    that's the increment each time we go around the loop.
    And <code>NUMBER</code> is how many we're doing,
    so this loop is creating a bunch of images with the same gray background,
    but whiter and whiter points spaced at equal intervals across them.
  </p>

  <div class="keypoints">
    <h3>Summary</h3>
    <ul>
      <li class="fixme">key points</li>
    </ul>
  </div>

  <div class="challenges">
    <h3>Challenges</h3>
    <p class="fixme">write some</p>
  </div>

</section>

<section id="s:io">
  <h2>Reading Files</h2>

  <div class="understand">
    <h3>Learning Objectives</h3>
    <ul>
      <li>Draw a diagram to explain where computers store data.</li>
      <li>Write programs that open, read, and close files.</li>
      <li>Explain how "lines" of text are actually stored in files.</li>
      <li>Call a pre-defined method of a built-in type.</li>
      <li>Write programs that write data to files.</li>
    </ul>
    <p>
      <span class="duration">20 minutes</span>.
    </p>
  </div>

  <p>
    The IPython Notebook is great for interactive work,
    but we often want to run programs from the command line.
    Just as we saved shell commands in <a href="shell.html#s:scripts">shell scripts</a>,
    we can save Python commands in files
    and then have the Python interpreter run those.
    Using your favorite text editor,
    put the following three lines into a plain text file:
  </p>

<pre>
left = "hello"
right = "there"
print left, right
</pre>

  <p class="continue">
    and save it as <code>greeting.py</code>.
    (By convention,
    Python files end in '.py'
    rather than '.txt'.)
    To run it from the shell,
    type:
  </p>

<pre>
$ <span class="in">python greeting.py</span>
<span class="out">hello there</span>
</pre>

  <p>
    The next step is to read and write data files.
    Modern computers generally store data in one of six places
    (<a href="#f:memory_architecture">Figure 4</a>):
  </p>

  <ol>

    <li>
      Inside the processor itself.
    </li>

    <li>
      In memory.
    </li>

    <li>
      On a local disk.
    </li>

    <li>
      On disk somewhere else on a network.
    </li>

    <li>
      In an offline archive,
      such as a DVD jukebox.
    </li>

  </ol>

  <figure id="f:memory_architecture">
    <img src="pymedia/memory_architecture.png" alt="Where Data is Stored" />
    <figcaption>Figure 4: Where Data is Stored</figcaption>
  </figure>

  <p>
    Each level is tens to thousands of times faster than the one below it,
    but tens to thousands of times more expensive per byte.
    Broadly speaking,
    programs access information in three different ways:
  </p>

  <ol>

    <li>
      The data is in memory.
      The program can manipulate it directly,
      but changes will not be saved when the program ends.
    </li>

    <li>
      The data is on disk.
      The program has to read it into memory to work with it,
      and write changes back out,
      but those changes will persist after the program ends.
    </li>

    <li>
      The data is far away,
      and must be copied to the local machine for use
      (although given the speed of today's internet,
      there is much less difference between "local" and "remote"
      than there used to be).
    </li>

  </ol>

  <p>
    We know how to handle the first case (data in memory),
    and we'll deal with the third case <a href="web.html">later</a>.
    Right now,
    let's look at how to get data out of a file on our computer's hard drive.
    Suppose that Valerie has test scores in files like this:
  </p>

<pre>
Subject: 1782
Date:    2013-05-21
Alpha: 0.4
Range: 1.7
Discrimination: 4.5
</pre>

  <p class="continue">
    Let's write a small program that extracts the subject ID from a data file.
    Save the lines below in a file called <code>first.py</code>
    in the same directory as the data file
    (which is called <code>data01.txt</code>):
  </p>

<pre>
reader = open('data01.txt', 'r')
first_line = reader.readline()
print first_line
reader.close()
</pre>

  <p>
    The first line uses a built-in function called <code>open</code>
    to open our file.
    Its first parameter is the name of the file being opened.
    Its second is the string <code>'r'</code>,
    which signals that we want to read from this file
    (rather than write to it).
  </p>

  <p>
    <code>open</code>
    creates a connection (or <a href="glossary.html#handle">handle</a>)
    between the program and the data on disk
    (<a href="#f:file_object">Figure 5</a>),
    which is assigned to the variable <code>reader</code>.
    There's nothing special about that name&mdash;we could call it <code>orange</code>&mdash;but
    whatever we call it,
    we can ask it to read a line from the file for us
    and assign that string to <code>first_line</code>
    by calling its <a href="glossary.html#method">method</a> <code>readline</code>.
    The program then prints that line and tells the file to close itself.
    This last step isn't strictly necessary in a small program&mdash;Python
    automatically closes any files that are open when the program finishes&mdash;but
    it's a good habit to get into,
    since the operating system limits the number of files any one program can have open at a time.
  </p>

  <figure id="f:file_object">
    <img src="pymedia/file_object.png" alt="File Objects" />
    <figcaption>Figure 5: File Objects</figcaption>
  </figure>

  <div class="box">
    <h3>Methods</h3>

    <p>
      <code>readline</code> is a special kind of function
      called a <a href="glossary.html#method">method</a>.
      It's attached to a particular object&mdash;in this case,
      to the file handle <code>reader</code>.
      You can think of objects and methods as nouns and verbs,
      so when we write <code>reader.readline()</code>,
      we're asking whatever the variable <code>reader</code> points at
      to do <code>readline</code> for us.
      As <a href="#f:methods">Figure 6</a> shows,
      the methods are associated with the thing the variable points at,
      not with the variable itself.
    </p>

    <figure id="f:methods">
      <img src="pymedia/methods.png" alt="Where Methods Are Stored" />
      <figcaption>Figure 6: Where Methods Are Stored</figcaption>
    </figure>

  </div>

  <p>
    Here's what happens when we run our program:
  </p>

<pre>
$ <span class="in">python first.py</span>
<span class="out">Subject: 1782

</span>
</pre>

  <p>
    It's not easy to see, but there's actually an extra blank line in the output.
    Where does it come from?
  </p>

  <p>
    The answer depends on the fact that text files aren't stored in lines:
    that's just how things like text editors and shell commands display them.
    A text file is actually stored as a sequence of bytes
    (<a href="#f:text_file_storage">Figure 7</a>).
    Some of those happen to be newline characters,
    and most tools interpret them as meaning "end of line".
    In particular,
    when asked to read the next line from a file,
    Python's file-reading functions read up to and including the end-of-line marker
    and return that.
  </p>

  <figure id="f:text_file_storage">
    <img src="pymedia/text_file_storage.png" alt="Text File Storage" />
    <figcaption>Figure 7: Text File Storage</figcaption>
  </figure>

  <p>
    Nothing says files have to be stored this way, though.
    On Windows,
    text files use two characters&mdash;a carriage return and a newline&mdash;to
    mark the end of line.
    If we are using Python on Windows,
    it automatically translates those two characters into a single newline when reading,
    and translates newlines back into those two characters when writing,
    so that our programs don't have to worry about it.
  </p>

  <p>
    Coming back to our program,
    the <code>print</code> command automatically adds an end-of-line marker
    to its output.
    We can tell it not to do that by putting a comma at the end of the line:
  </p>

<pre>
reader = open('data01.txt', 'r')
first_line = reader.readline()
print first_line<span class="highlight">,</span>
reader.close()
<span class="out">Subject: 1782</span>
</pre>

  <p>
    A better way to solve the problem is to get rid of the line ending on the string:
  </p>

<pre>
reader = open('data01.txt', 'r')
first_line = reader.readline()
<span class="highlight">first_line = first_line.strip()</span>
print first_line
reader.close()
<span class="out">Subject: 1782</span>
</pre>

  <p class="continue">
    The variable <code>first_line</code> refers to a string,
    and strings in Python are also objects with methods.
    One of those methods,
    <code>strip</code>,
    creates a new string by removing any leading or trailing spaces, tabs, or line-ending characters
    from the original string
    (<a href="#f:string_strip">Figure 8</a>).
    It does <em>not</em> modify the original string:
    in Python,
    any string has a fixed value,
    just as the integer <code>5</code>'s value is always fixed at 5.
  </p>

  <figure id="f:string_strip">
    <img src="pymedia/string_strip.png" alt="Stripping Strings" />
    <figcaption>Figure 8: Stripping Strings</figcaption>
  </figure>

  <p>
    Writing to a file is as easy as reading from one:
  </p>

<pre>
writer = open('mydata.txt', 'w')
print &gt;&gt; writer, 'largest value:', 20
print &gt;&gt; writer, 'smallest value:', -2
writer.close()
</pre>

  <p class="continue">
    We begin by opening the file in <code>'w'</code> (write) mode.
    This gives us a handle that we can use in subsequent operations,
    which we assign to a variable.
    (We've called it <code>writer</code> here,
    but we could call it anything.)
    After that,
    we can print to the file exactly as we have been printing to the screen;
    as always,
    we close the file when we're done
    (which is when the last few things we've written to the file are actually stored on disk).
  </p>

  <p>
    Opening a file for writing erases its previous content,
    or creates the file if it didn't already exist.
    If we don't want to erase any previous content,
    we can open the file for appending using <code>'a'</code> instead of <code>'w'</code>.
  </p>

  <div class="box">
    <h3>File I/O in the Notebook</h3>
    <p class="fixme">explain file I/O from the notebook</p>
  </div>

  <div class="keypoints">
    <h3>Summary</h3>
    <ul>
      <li>Data is either in memory, on disk, or far away.</li>
      <li>Most things in Python are objects, and have attached functions called methods.</li>
      <li>When lines are read from files, Python keeps their end-of-line characters.</li>
      <li>Use <code>str.strip</code> to remove leading and trailing whitespace (including end-of-line characters).</li>
      <li>Use <code>open(<em>name</em>, <em>mode</em>)</code> to open a file for reading ('r'), writing ('w'), or appending ('a').</li>
      <li>Opening a file for writing erases any existing content.</li>
      <li>Use <code>file.readline</code> to read a line from a file.</li>
      <li>Use <code>file.close</code> to close an open file.</li>
      <li>Use <code>print &gt;&gt; file</code> to print to a file.</li>
    </ul>
  </div>

  <div class="challenges">
    <h3>Challenges</h3>

    <ol>

      <li>
        If <code>species.txt</code> is a text file,
        what do the following lines print?
<pre>
info = open('species.txt', 'r')
print info.readline().strip()
</pre>
      </li>

      <li>
        What does the following program leave in the file <code>output.txt</code>?
<pre>
results = open('output.txt', 'w')
results.write('first')
results.close()
results = open('output.txt', 'a')
results.write('second')
results.close()
</pre>
      </li>

      <li>
        If the file <code>square.txt</code> contains:
<pre>
abcde
fghij
klmno
</pre>
        what does the following program print?
<pre>
handle = open('square.txt', 'r')
result = len(handle)
handle.close()
print result
</pre>
      </li>

      <li>
        If <code>square.txt</code> contains the three lines shown above,
        and the file <code>final.txt</code> does not exist,
        what is the effect of the following program?
<pre>
reader = open('square.txt', 'r')
writer = open('final.txt', 'w')
writer = reader
reader.close()
writer.close()
</pre>
      </li>

    </ol>

  </div>

</section>

<section id="s:lists">
  <h2>Lists</h2>

  <div class="understand" id="u:lists">
    <h3>Understand:</h3>
    <ul>
      <li>How to store many related values in a list.</li>
      <li>How to use a loop to operate on the values in a list.</li>
      <li>That programs should be tested on small, simple cases.</li>
      <li>That lists can be modified in place.</li>
      <li>How to access arbitrary elements in a list.</li>
      <li>What an out-of-bounds error is.</li>
      <li>How to generate a list of legal indices for a list.</li>
      <li>When to use short or long variable names.</li>
    </ul>
  </div>

  <p>
    It's time to double back and have a closer look at <code>sys.argv</code>.
    It's obviously not an image;
    instead,
    it's a <a href="glossary.html#list">list</a>.
    To start our exploration of lists,
    let's run an interpreter and try this:
  </p>

<pre src="src/python/sum_values.py">
<span class="in">data = [1, 3, 5]
for value in data:</span>
... <span class="in">    print value</span>
...
<span class="out">1
3
5</span>
</pre>

  <p>
    <code>[1, 3, 5]</code> is a list:
    a single object that stores multiple values
    (<a href="#f:simple_list">Figure XXX</a>).
    Just as a <code>for</code> loop over an open file
    reads lines from that file one by one
    and assigns them to the loop variable,
    a <code>for</code> loop over a list assigns each value in the list
    to the loop variable in turn.
  </p>

  <figure id="f:simple_list">
    <img src="pymedia/simple_list.png" alt="A Simple List" />
  </figure>

  <p>
    Let's do something a bit more useful:
  </p>

<pre src="src/python/first_mean.py">
data = [1, 4, 2, 3, 3, 4, 3, 4, 1]
total = 0
for n in data:
    total += n
mean = total / len(data)
print "mean is", mean
<span class="out">mean is 2</span>
</pre>

  <p class="continue">
    This loop adds each value in the list to <code>total</code>.
    Once the loop is over,
    we divide <code>total</code> by the length of the list,
    which we find using the built-in function <code>len</code>.
  </p>

  <p>
    Unfortunately,
    the result in the example above is wrong:
    The total of the numbers in the list is 25,
    but we're printing 2 instead of 25/9
    (which is 2.7777&hellip;).
    The problem once again is that we're dividing one integer by another,
    which throws away the remainder.
    We can fix this by initializing <code>total</code> to 0.0
    (so that all the additions involve a floating-point number and an integer,
    which produces a floating-point number),
    or by using the <code>float</code> function to do the conversion explicitly:
  </p>

<pre src="src/python/second_mean.py">
data = [1, 4, 2, 3, 3, 4, 3, 4, 1]
total = 0
for n in data:
    total += n
mean = <span class="highlight">float(total)</span> / len(data)
print "mean is", mean
<span class="out">mean is 2.77777777778</span>
</pre>

  <p>
    The <em>real</em> problem isn't a matter of integers versus floats, though.
    The real problem with this program is that
    we didn't know whether the answer was right or wrong,
    so we couldn't tell if the program was correct or not.
    After all,
    the average of these nine numbers might well have been 2.
  </p>

  <p>
    The fact that a program runs without crashing doesn't mean it's correct.
    One way to make programs easier to check
    is to run them on smaller or more regular data.
    For example,
    If we ran the program on <code>[1, 4]</code>,
    we'd probably notice that we were getting 2 instead of 2.5.
    Writing programs so that they're checkable is another idea
    that we'll explore in detail <a href="quality.html">later</a>.
  </p>

  <div class="box">

    <h3>Even Simpler</h3>

    <p>
      Python actually has a built-in function called <code>sum</code>,
      so we can get rid of the loop entirely:
    </p>

<pre src="src/python/loopless.py">
total = sum(data)
print "mean is", float(total) / len(data)
</pre>

    <p class="continue">
      and shorten this even further by calling <code>float</code>
      directly on the result of <code>sum</code>:
    </p>

<pre src="src/python/one_liner.py">
print "mean is", float(sum(data)) / len(data)
</pre>

    <p>
      <code>float(sum(data))</code> is like <em>sin(log(x))</em>:
      the inner function is evaluated first,
      and its result is used as the input to the outer function.
      It's important to get the parentheses in the right place,
      since the expressions:
    </p>

<pre src="src/python/one_liner.py">
float(sum(data)) / len(data)
</pre>

    <p class="continue">
      and
    </p>

<pre src="src/python/incorrect_one_liner.py">
float(sum(data) / len(data))
</pre>

    <p class="continue">
      calculate different things.
      In the first,
      <code>float</code> is applied to <code>sum(data)</code>,
      i.e.,
      Python adds up all the numbers,
      then converts the result to a floating-point value
      before dividing by <code>len(data)</code>
      to get the mean.
    </p>

    <p>
      In the second,
      Python adds up the numbers,
      divides by <code>len(data)</code> to get an integer result,
      and then converts that integer to a floating point number.
      This is just our original bug in a more compact form.
      Once again,
      the only way to guard against it is to test the program.
    </p>

  </div>

  <p>
    Lists are used more than any other data structure,
    so let's have a closer look at them.
    First,
    lists are <a href="glossary.html#mutable">mutable</a>,
    i.e.,
    they can be changed after they are created:
  </p>

<pre>
data = [1, 4, 2, 3]
result = []
current = 0
for n in data:
    current = current + n
    result.append(current)
print "running total:", result
<span class="out">[1, 5, 7, 10]</span>
</pre>

  <p class="continue">
    <code>result</code> starts off as an <a href="glossary.html#empty-list">empty list</a>,
    and <code>current</code> starts off as zero
    (<a href="#f:running_total">Figure XXX</a>).
    Each time the loop executes&mdash;i.e.,
    for each number in <code>values</code>&mdash;Python
    adds the next value in the list to <code>current</code>
    to calculate the running total.
    It then append this value to <code>result</code>,
    so that when the program finishes,
    we have a complete list of partial sums.
  </p>

  <figure id="f:running_total">
    <img src="pymedia/running_total.png" alt="Running Total" />
  </figure>

  <p>
    What if we want to double the values in <code>data</code> in place?
    We could try this:
  </p>

<pre>
data = [1, 4, 2, 3]
for n in data:
    n = 2 * n
print "doubled data is:", data
<span class="out">doubled data is [1, 4, 2, 3]</span>
</pre>

  <p class="continue">
    but as we can see,
    it doesn't work.
    When Python calculates <code>2*n</code>,
    it creates a new value in memory
    (<a href="#f:doubling_list">Figure XXX</a>).
    It then makes the variable <code>n</code> point at the value for a few microseconds
    before going around the loop again
    and pointing <code>n</code> at the next value from the list instead.
    Since nothing is pointing to the temporary value we just created any longer,
    Python throws it away.
  </p>

  <figure id="f:doubling_list">
    <img src="pymedia/doubling_list.png" alt="Failed Attempt to Double Values in a List" />
  </figure>

  <p>
    The solution to our problem is,
    not surprisingly,
    to index the list.
    Here are some examples:
  </p>

<pre>
scientists = ["Newton", "Darwing", "Turing"]
print "length:", len(scientists)
<span class="out">length: 3</span>
print "first element:", scientists[0]
<span class="out">first element: Newton</span>
print "second element:", scientists[1]
<span class="out">second element: Darwing</span>
print "third element:", scientists[2]
<span class="out">third element: Turing</span>
</pre>

  <p>
    How does indexing help us?
    Well,
    after noticing that we have misspelled Darwin's name as "Darwing",
    we can fix it by assigning a new value to that location in the list:
  </p>

<pre>
scientists[1] = "Darwin"
print scientists
<span class="out">["Newton", "Darwin", "Turing"]</span>
</pre>

  <p class="continue">
    <a href="#f:update_list">Figure XXX</a> shows
    the list before and after the change.
    Again,
    once we've made the update,
    nothing is pointing to the string "Darwing" with a "g" on the end,
    so the memory it's using is recycled.
  </p>

  <figure id="f:update_list">
    <img src="pymedia/update_list.png" alt="Successfully Doubling Values in a List" />
  </figure>

  <p>
    Now, back to our original problem of doubling values in place.
    We now know that we can do this:
  </p>

<pre>
data = [1, 4, 2]
data[0] = 2 * data[0]
data[1] = 2 * data[1]
data[2] = 2 * data[2]
print "doubled data is:", data
<span class="out">doubled data is [2, 8, 4]</span>
</pre>

  <p class="continue">
    but it clearly doesn't scale:
    we're not going to write a million statements
    to update a list of a million values.
    We need to use a loop,
    but instead of looping over the values in the list,
    we want to loop over the allowed indices of the list.
    To do this,
    we will rely on a function called <code>range</code>
    which creates a list of the first N integers:
  </p>

<pre>
print range(5)
<span class="out">[0, 1, 2, 3, 4]</span>
</pre>

  <p>
    Once again,
    the values go from 0 to one less than the number given to <code>range</code>,
    which just happens to be exactly the indices of a list of that length.
    Let's try it out:
  </p>

<pre src="src/python/range_loop.py">
data = [1, 4, 2]
indices = range(3)
for i in indices:
    print i, data[i]
<span class="out">0 1
1 4
2 2</span>
</pre>

  <p class="continue">
    then fold the call to <code>range</code> into the loop:
  </p>

<pre>
data = [1, 4, 2]
for i in <span class="highlight">range(3)</span>:
    print i, data[i]
<span class="out">0 1
1 4
2 2</span>
</pre>

  <p>
    This program is correct, but fragile:
    if we add more values to the list,
    Python will still only execute the loop three times,
    so we'll still only print the first three values in the list:
  </p>

<pre>
data = [1, 4, 2<span class="highlight">, 5, 1, 3</span>]
for i in range(3):
    print i, data[i]
<span class="out">0 1
1 4
2 2</span>
</pre>

  <p>
    What we want is for the loop to automatically adjust itself
    based on the length of the list:
  </p>

<pre>
data = [1, 4, 2, 5, 1, 3]
<span class="highlight">data_length = len(data)</span>
for i in range(<span class="highlight">data_length</span>):
    print i, data[i]
<span class="out">0 1
1 4
2 2
3 5
4 1
5 3</span>
</pre>

  <p>
    We can get rid of the variable <code>data_length</code>
    by putting the call to <code>len(data)</code>
    inside the call to <code>range</code>:
  </p>

<pre>
data = [1, 4, 2, 5, 1, 3]
for i in range(<span class="highlight">len(data)</span>):
    print i, data[i]
<span class="out">0 1
1 4
2 2
3 5
4 1
5 3</span>
</pre>

  <p class="continue">
    Again,
    <code>range(len(data))</code> is like <em>sin(log(x))</em>:
    the inner function is evaluated first,
    and its result becomes the input to the outer function.
    Put together like this,
    they are a common <a href="glossary.html#idiom">idiom</a> in Python,
    i.e.,
    a way of saying something that everyone recognizes and uses.
    When an experienced programmer sees:
  </p>

<pre>
for i in range(len(something)):
</pre>

  <p class="continue">
    what she "hears" is:
  </p>

<pre>
for each legal index of something:
</pre>

  <p>
    The reason this idiom is better than what we started with is that
    there is no duplicated information.
    Instead of having a list of length 3,
    and looping from 0 up to 3,
    we have a list of any length whatever,
    and loop from 0 up to that length.
    In general,
    anything that is repeated two or more times in a program
    will eventually be wrong in at least one.
    Putting it another way,
    any piece of information should appear exactly once in a program,
    so that if it needs to change,
    it only needs to be changed in one place.
  </p>
  
  <div class="box">

    <h3>Short and Long Variable Names</h3>

    <p>
      We have said several times that programs should use meaningful variable names.
      Are we not violating our own rule by using <code>i</code> as a variable in this program?
      The short answer is "yes", but it's a defensible violation.
      Suppose we re-write our loop as:
    </p>

<pre>
data = [1, 4, 2, 5, 1, 3]
for location in range(len(data)):
    print location, data[location]
</pre>

    <p class="continue">
      The longer name are more meaningful,
      but it also takes longer to read.
      Since the original <code>i</code> is only used for a few lines,
      users will easily be able to keep its meaning in short-term memory
      as long as they need to.
      On balance,
      therefore,
      the short name are better in this case.
    </p>

    <p>
      This is actually a general principle in program design.
      A variable that holds a simple value,
      and is only used in a few adjacent lines of code,
      can (and usually should) have a short name.
      A variable that holds a complex value,
      or one which is used over more than a few lines of code,
      should have a longer name
      in order to optimize the tradeoff between reading speed
      and the limitations of human short-term memory.
    </p>

  </div>

  <p>
    Let's finally go back and double the values in place:
  </p>

<pre src="src/python/doubling_in_place.py">
data = [1, 4, 2, 5, 3, 4, 5]
for i in range(len(data)):
    data[i] = 2 * data[i]
print data
<span class="out">[2, 8, 4, 10, 6, 8, 10]</span>
</pre>

  <div class="box">
    <h3>Left and Right</h3>

    <p>
      Seeing the expression <em>x = 2x</em>,
      most mathematicians would say,
      "Right&mdash;so <em>x</em> is zero."
      Seeing the same expression,
      most programmers would say,
      "Right&mdash;you're doubling the value of <em>x</em>."
      <a href="#f:double_in_place">Figure XXX</a> shows
      how that actually works:
    </p>

    <ol>

      <li>
        Python reads the current value of <code>x</code> from memory.
      </li>

      <li>
        It multiplies that value by 2,
        storing the result in a temporary location&hellip;
      </li>

      <li>
        &hellip;and then modifies <code>x</code> to point at the new value.
      </li>

    </ol>

    <figure id="f:double_in_place">
      <img src="pymedia/double_in_place.png" alt="Doubling in Place" />
    </figure>

    <p>
      Now look at what happens when Python execute the statements:
    </p>

<pre>
x = 5
y = x
x = 2 * x
</pre>

  <ol>
    
    <li>
      The variable <code>x</code> is created,
      and set to point at the value 5
      (<a href="#f:new_values_for_variables">Figure XXX</a>).
    </li>
    
    <li>
      The variable <code>y</code> is created,
      and set to point at the same value.
    </li>
    
    <li>
      The value 10 (i.e., 2&times;5) is created and stored in a temporary location.
    </li>
    
    <li>
      <code>x</code> is altered to point at that value.
    </li>
    
  </ol>

  <figure id="f:new_values_for_variables">
    <img src="pymedia/new_values_for_variables.png" alt="New Values for Variables" />
  </figure>
  
    <p>
      After these operations are complete,
      <code>y</code> is left pointing at the original value, 5.
      It does <em>not</em> point at the same thing <code>x</code> does any longer,
      and its value is <em>not</em> automatically recalculated
      to keep it twice the value of <code>x</code>.
    </p>
    
  </div>

  <div class="keypoints">
    <h3>Summary</h3>
    <ul>
      <li>Use <code>[<em>value</em>, <em>value</em>, ...]</code> to create a list of values.</li>
      <li><code>for</code> loops process the elements of a list, in order.</li>
      <li><code>len(<em>list</em>)</code> returns the length of a list.</li>
      <li><code>[]</code> is an empty list with no values.</li>
      <li>Lists are mutable: they can be changed in place.</li>
      <li>Use <code><em>list</em>.append(<em>value</em>)</code> to append something to the end of a list.</li>
      <li>Use <code><em>list</em>[<em>index</em>]</code> to access a list element by location.</li>
      <li>The index of the first element of a list is 0; the index of the last element is <code>len(<em>list</em>)-1</code>.</li>
      <li>Negative indices count backward from the end of the list, so <code><em>list</em>[-1]</code> is the last element.</li>
      <li>Trying to access an element with an out-of-bounds index is an error.</li>
      <li><code>range(<em>number</em>)</code> produces the list of numbers <code>[0, 1, ..., <em>number</em>-1]</code>.</li>
      <li><code>range(len(<em>list</em>))</code> produces the list of legal indices for <code><em>list</em></code>.</li>
    </ul>
  </div>

  <div class="challenges">
    <h3>Challenges</h3>
    <p class="fixme">write challenges</p>
  </div>

</section>

<section id="s:sys">
  <h2>File I/O and Command-Line Arguments</h2>

  <div class="understand">
    <h3>Learning Objectives</h3>
    <ul>
      <li>Write programs that import standard library modules.</li>
      <li>Explain what standard input and output are, and how they relate to the <a href="shell.html#b:pipefilter">pipe-and-filter</a> model.</li>
      <li>Write programs that read from standard input.</li>
      <li>Write programs that write to standard output.</li>
    </ul>
    <p>
      <span class="duration">25 minutes</span>.
    </p>
  </div>

  <p>
    Our program currently reads the header from <code>data01.txt</code>
    every time we run it.
    There's not much point in that:
    what we really want is to read from any file,
    or from several files in turn.
    Doing that requires a bit of machinery we haven't seen yet,
    so let's solve a simpler problem:
    reading from standard input instead of from a file.
    Once we can do that,
    we can run our program as:
  </p>

<pre>
$ <span class="in">python first.py &lt; somefile.txt</span>
</pre>

  <p class="continue">
    or read from several files using:
  </p>

<pre>
$ <span class="in">for inputfile in data*.txt
do
    python first.py &lt; $inputfile
done</span>
</pre>

  <p>
    Here's the modified program:
  </p>

<pre>
<span class="highlight">import sys
first_line = sys.stdin.readline()</span>
first_line = first_line.strip()
print first_line
reader.close()
</pre>

  <p class="continue">
    The two lines that have changed are highlighted at the top of the program.
    The first loads a library called <code>sys</code>,
    which connects Python to the system it is running on.
    The second line reads from <code>sys.stdin</code>,
    which is just the standard input stream we met in
    <a href="shell.html#s:pipefilter:pipes">our discussion of pipes</a>.
    Nothing else changes,
    since standard input tries really hard to behave like an open file
    (<a href="#f:replacing_with_stdin">Figure 9</a>).
    In particular,
    the object that <code>sys.stdin</code> points at
    has a method with the same name and behavior as a file's <code>readline</code> method,
    and another with the same name and behavior as a file's <code>close</code>,
    so we can swap one for the other without having to modify anything else.
  </p>

  <figure id="f:replacing_with_stdin">
    <img src="pymedia/replacing_with_stdin.png" alt="Replacing a File with Standard Input" />
    <figcaption>Figure 9: Replacing a File with Standard Input</figcaption>
  </figure>

  <div class="box">
    <h3>Interactive Testing</h3>

    <p>
      One other benefit of reading from standard input when no files are supplied
      is that it allows interactive testing:
      we can run our program
      and then just type in things we want it to read.
      If we do this,
      we must type control-D to signal the end of input
      (or control-Z in a Windows shell).
    </p>

  </div>

  <div class="box">
    <h3>Writing to Standard Output</h3>

    <p>
      Just as we can write to an open file using <code>print &gt;&gt; handle</code>,
      we can write to standard output using <code>print &gt;&gt; sys.stdout</code>.
      This is redundant, though,
      since <code>print</code> sends things to standard output by default.
    </p>

  </div>

  <p>
    The most commonly-used element of <code>sys</code> is probably <code>sys.argv</code>,
    which holds the <a href="glossary.html#command-line-arguments">command-line arguments</a>
    used to run the program.
    The name of the script itself is in <code>sys.argv[0]</code>;
    all the other arguments are put in <code>sys.argv[1]</code>, <code>sys.argv[2]</code>, and so on.
    For example,
    here's a program that does nothing except print out its command-line arguments:
  </p>

<pre>
<span class="comment"># echo.py</span>
import sys
print "sys.argv is:", sys.argv
for i in range(len(sys.argv)):
  print i, '=', sys.argv[i]
</pre>

  <p class="continue">
    If it is run without any arguments,
    it reports that <code>sys.argv[0]</code> is <code>echo.py</code>:
  </p>

<pre>
$ <span class="in">python echo.py</span>
<span class="out">sys.argv is ['echo.py']
0 = echo.py</span>
</pre>

  <p class="continue">
    When it is run with arguments, though, it displays those as well:
  </p>

<pre>
$ <span class="in">python echo.py first second</span>
<span class="out">sys.argv is ['echo.py', 'first', 'second']
0 = echo.py
1 = first
2 = second</span>
</pre>

  <p>
    We can use this to write the world's simplest calculator:
  </p>

<pre>
import sys

total = 0
for value in sys.argv[1:]:
    total += float(value)
print total
$ <span class="in">python calculator.py 1 2 3</span>
<span class="out">6.0</span>
</pre>

  <p class="continue">
    Notice that we loop over <code>sys.argv[1:]</code>,
    i.e.,
    over everything except the first element of <code>sys.argv</code>.
    That first element is always the name of our program
    (in this case, <code>calculator.py</code>),
    which we definitely don't want to try to add to our running total.
  </p>

  <p>
    The most common use of <code>sys.argv</code> is
    to pass the names of a bunch of files into our program.
    Suppose that we have a function called <code>summarize</code>
    that reports the minimum and maximum values in a file:
  </p>

<pre>
def summarize(filename):
    reader = open(filename, 'r')
    least = 0.0
    greatest = 0.0
    for line in reader:
        current = float(line)
        least = min(least, current)
        greatest = max(least, current)
    reader.close()
    return least, greatest
</pre>

  <p class="continue">
    If we want to display summaries for several files at once,
    we can require the user to give them as command-line arguments:
  </p>

<pre>
$ python summarize.py july.dat august.dat september.dat
</pre>

  <p class="continue">
    and connect the command line with the program's internals using <code>sys.argv</code>:
  </p>

<pre>
all_filenames = sys.argv[1:]  <span class="comment"># Again, don't include the program name</span>
for filename in all_filenames:
    low, high = summarize(filename)
    print filename, low, ave, high
</pre>

  <div class="keypoints">
    <h3>Summary</h3>
    <ul>
      <li>The operating system automatically gives every program three open "files" called standard input, standard output, and standard error.</li>
      <li>Standard input gets data from the keyboard, from a file when redirected with '&lt;', or from the previous stage in a pipeline with '|'.</li>
      <li>Standard output writes data to the screen, to a file when redirected with '&gt;', or to the next stage in a pipeline with '|'.</li>
      <li>Standard error also writes data to the screen, and is not redirected by '&gt;' or '|'.</li>
      <li>The <code>sys</code> library provides open "files" called <code>sys.stdin</code> and <code>sys.stdout</code> for standard input and output.</li>
      <li><code>sys.argv</code> holds the command-line arguments given to a program.</li>
    </ul>
  </div>

  <div class="challenges">
    <h3>Challenges</h3>

    <ol>

      <li>
        What is the difference between:
<pre>
import sys
reader = sys.stdin
print len(reader.readline())
</pre>
        and:
<pre>
import sys
print len(sys.stdin.readline())
</pre>
      </li>

      <li>
        What is the error in the following program,
        and how would you fix it?
<pre>
import sys
sys.stdin = open('temporary.txt', 'w')
sys.stdin.write(123)
sys.stdin.close()
</pre>
      </li>

      <li>
        Nelle wants to copy the first line of <code>patients.txt</code>
        to the file <code>subjects.txt</code>
        using the shell command:
<pre>
$ <span class="in">python copier.py &gt; subjects.txt</span>
</pre>
        Fill in the blanks in the program below so that it does this.
<pre>
import sys
source = ________
line = ________
source.close()
________.________(line)
</pre>
      </li>

    </ol>

  </div>

</section>

<section id="s:summary">
  <h2>Summing Up</h2>

  <p class="fixme">sum up</p>
</section>
{% endblock content %}
